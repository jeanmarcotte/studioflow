"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvg";
exports.ids = ["vendor-chunks/canvg"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvg/lib/index.cjs":
/*!******************************************!*\
  !*** ./node_modules/canvg/lib/index.cjs ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"(ssr)/./node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.promise.js */ \"(ssr)/./node_modules/core-js/modules/es.promise.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.delete-property.js */ \"(ssr)/./node_modules/core-js/modules/es.reflect.delete-property.js\");\nvar _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"(ssr)/./node_modules/@babel/runtime/regenerator/index.js\");\nvar _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n__webpack_require__(/*! core-js/modules/es.array.map.js */ \"(ssr)/./node_modules/core-js/modules/es.array.map.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"(ssr)/./node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"(ssr)/./node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.match.js */ \"(ssr)/./node_modules/core-js/modules/es.string.match.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"(ssr)/./node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.starts-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.starts-with.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"(ssr)/./node_modules/core-js/modules/es.array.join.js\");\nvar _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"(ssr)/./node_modules/@babel/runtime/helpers/slicedToArray.js\");\nvar _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\nvar _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"(ssr)/./node_modules/@babel/runtime/helpers/classCallCheck.js\");\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"(ssr)/./node_modules/@babel/runtime/helpers/createClass.js\");\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"(ssr)/./node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.every.js */ \"(ssr)/./node_modules/core-js/modules/es.array.every.js\");\n__webpack_require__(/*! core-js/modules/es.array.reduce.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reduce.js\");\n__webpack_require__(/*! core-js/modules/es.string.ends-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.ends-with.js\");\n__webpack_require__(/*! core-js/modules/es.string.split.js */ \"(ssr)/./node_modules/core-js/modules/es.string.split.js\");\nvar requestAnimationFrame = __webpack_require__(/*! raf */ \"(ssr)/./node_modules/raf/index.js\");\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"(ssr)/./node_modules/core-js/modules/es.function.name.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"(ssr)/./node_modules/core-js/modules/es.string.trim.js\");\nvar RGBColor = __webpack_require__(/*! rgbcolor */ \"(ssr)/./node_modules/rgbcolor/index.js\");\n__webpack_require__(/*! core-js/modules/es.array.for-each.js */ \"(ssr)/./node_modules/core-js/modules/es.array.for-each.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.for-each.js\");\nvar _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"(ssr)/./node_modules/@babel/runtime/helpers/inherits.js\");\nvar _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"(ssr)/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\nvar _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"(ssr)/./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n__webpack_require__(/*! core-js/modules/es.array.from.js */ \"(ssr)/./node_modules/core-js/modules/es.array.from.js\");\n__webpack_require__(/*! core-js/modules/es.array.includes.js */ \"(ssr)/./node_modules/core-js/modules/es.array.includes.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"(ssr)/./node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.some.js */ \"(ssr)/./node_modules/core-js/modules/es.array.some.js\");\n__webpack_require__(/*! core-js/modules/es.string.includes.js */ \"(ssr)/./node_modules/core-js/modules/es.string.includes.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.string.iterator.js\");\nvar _toConsumableArray = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"(ssr)/./node_modules/@babel/runtime/helpers/toConsumableArray.js\");\n__webpack_require__(/*! core-js/modules/es.array.reverse.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reverse.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"(ssr)/./node_modules/core-js/modules/es.number.constructor.js\");\nvar _get = __webpack_require__(/*! @babel/runtime/helpers/get */ \"(ssr)/./node_modules/@babel/runtime/helpers/get.js\");\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"(ssr)/./node_modules/core-js/modules/es.array.fill.js\");\nvar svgPathdata = __webpack_require__(/*! svg-pathdata */ \"(ssr)/./node_modules/svg-pathdata/lib/SVGPathData.cjs\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"(ssr)/./node_modules/core-js/modules/es.regexp.to-string.js\");\nvar _assertThisInitialized = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.map.js */ \"(ssr)/./node_modules/core-js/modules/es.map.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.apply.js */ \"(ssr)/./node_modules/core-js/modules/es.reflect.apply.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.get-prototype-of.js */ \"(ssr)/./node_modules/core-js/modules/es.reflect.get-prototype-of.js\");\nvar stackblurCanvas = __webpack_require__(/*! stackblur-canvas */ \"(ssr)/./node_modules/stackblur-canvas/dist/stackblur-es.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar _regeneratorRuntime__default = /*#__PURE__*/ _interopDefaultLegacy(_regeneratorRuntime);\nvar _asyncToGenerator__default = /*#__PURE__*/ _interopDefaultLegacy(_asyncToGenerator);\nvar _slicedToArray__default = /*#__PURE__*/ _interopDefaultLegacy(_slicedToArray);\nvar _defineProperty__default = /*#__PURE__*/ _interopDefaultLegacy(_defineProperty);\nvar _classCallCheck__default = /*#__PURE__*/ _interopDefaultLegacy(_classCallCheck);\nvar _createClass__default = /*#__PURE__*/ _interopDefaultLegacy(_createClass);\nvar requestAnimationFrame__default = /*#__PURE__*/ _interopDefaultLegacy(requestAnimationFrame);\nvar RGBColor__default = /*#__PURE__*/ _interopDefaultLegacy(RGBColor);\nvar _inherits__default = /*#__PURE__*/ _interopDefaultLegacy(_inherits);\nvar _possibleConstructorReturn__default = /*#__PURE__*/ _interopDefaultLegacy(_possibleConstructorReturn);\nvar _getPrototypeOf__default = /*#__PURE__*/ _interopDefaultLegacy(_getPrototypeOf);\nvar _toConsumableArray__default = /*#__PURE__*/ _interopDefaultLegacy(_toConsumableArray);\nvar _get__default = /*#__PURE__*/ _interopDefaultLegacy(_get);\nvar _assertThisInitialized__default = /*#__PURE__*/ _interopDefaultLegacy(_assertThisInitialized);\n/**\r\n * Options preset for `OffscreenCanvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @returns Preset object.\r\n */ function offscreen() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, DOMParserFallback = _ref.DOMParser;\n    var preset = {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParserFallback,\n        createCanvas: function createCanvas(width, height) {\n            return new OffscreenCanvas(width, height);\n        },\n        createImage: function createImage(url) {\n            return _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee() {\n                var response, blob, img;\n                return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n                    while(1){\n                        switch(_context.prev = _context.next){\n                            case 0:\n                                _context.next = 2;\n                                return fetch(url);\n                            case 2:\n                                response = _context.sent;\n                                _context.next = 5;\n                                return response.blob();\n                            case 5:\n                                blob = _context.sent;\n                                _context.next = 8;\n                                return createImageBitmap(blob);\n                            case 8:\n                                img = _context.sent;\n                                return _context.abrupt(\"return\", img);\n                            case 10:\n                            case \"end\":\n                                return _context.stop();\n                        }\n                    }\n                }, _callee);\n            }))();\n        }\n    };\n    if (typeof DOMParser !== \"undefined\" || typeof DOMParserFallback === \"undefined\") {\n        Reflect.deleteProperty(preset, \"DOMParser\");\n    }\n    return preset;\n}\n/**\r\n * Options preset for `node-canvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @param config.canvas - `node-canvas` exports.\r\n * @param config.fetch - WHATWG-compatible `fetch` function.\r\n * @returns Preset object.\r\n */ function node(_ref) {\n    var DOMParser1 = _ref.DOMParser, canvas = _ref.canvas, fetch1 = _ref.fetch;\n    return {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParser1,\n        fetch: fetch1,\n        createCanvas: canvas.createCanvas,\n        createImage: canvas.loadImage\n    };\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    offscreen: offscreen,\n    node: node\n});\n/**\r\n * HTML-safe compress white-spaces.\r\n * @param str - String to compress.\r\n * @returns String.\r\n */ function compressSpaces(str) {\n    return str.replace(/(?!\\u3000)\\s+/gm, \" \");\n}\n/**\r\n * HTML-safe left trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimLeft(str) {\n    return str.replace(/^[\\n \\t]+/, \"\");\n}\n/**\r\n * HTML-safe right trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimRight(str) {\n    return str.replace(/[\\n \\t]+$/, \"\");\n}\n/**\r\n * String to numbers array.\r\n * @param str - Numbers string.\r\n * @returns Numbers array.\r\n */ function toNumbers(str) {\n    var matches = (str || \"\").match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm) || [];\n    return matches.map(parseFloat);\n} // Microsoft Edge fix\nvar allUppercase = /^[A-Z-]+$/;\n/**\r\n * Normalize attribute name.\r\n * @param name - Attribute name.\r\n * @returns Normalized attribute name.\r\n */ function normalizeAttributeName(name) {\n    if (allUppercase.test(name)) {\n        return name.toLowerCase();\n    }\n    return name;\n}\n/**\r\n * Parse external URL.\r\n * @param url - CSS url string.\r\n * @returns Parsed URL.\r\n */ function parseExternalUrl(url) {\n    //                      single quotes [2]\n    //                      v         double quotes [3]\n    //                      v         v         no quotes [4]\n    //                      v         v         v\n    var urlMatch = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(url) || [];\n    return urlMatch[2] || urlMatch[3] || urlMatch[4];\n}\n/**\r\n * Transform floats to integers in rgb colors.\r\n * @param color - Color to normalize.\r\n * @returns Normalized color.\r\n */ function normalizeColor(color) {\n    if (!color.startsWith(\"rgb\")) {\n        return color;\n    }\n    var rgbParts = 3;\n    var normalizedColor = color.replace(/\\d+(\\.\\d+)?/g, function(num, isFloat) {\n        return rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num;\n    });\n    return normalizedColor;\n}\n// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\nvar attributeRegex = /(\\[[^\\]]+\\])/g;\nvar idRegex = /(#[^\\s+>~.[:]+)/g;\nvar classRegex = /(\\.[^\\s+>~.[:]+)/g;\nvar pseudoElementRegex = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;\nvar pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^)]*\\))/gi;\nvar pseudoClassRegex = /(:[^\\s+>~.[:]+)/g;\nvar elementRegex = /([^\\s+>~.[:]+)/g;\nfunction findSelectorMatch(selector, regex) {\n    var matches = regex.exec(selector);\n    if (!matches) {\n        return [\n            selector,\n            0\n        ];\n    }\n    return [\n        selector.replace(regex, \" \"),\n        matches.length\n    ];\n}\n/**\r\n * Measure selector specificity.\r\n * @param selector - Selector to measure.\r\n * @returns Specificity.\r\n */ function getSelectorSpecificity(selector) {\n    var specificity = [\n        0,\n        0,\n        0\n    ];\n    var currentSelector = selector.replace(/:not\\(([^)]*)\\)/g, \"     $1 \").replace(/{[\\s\\S]*/gm, \" \");\n    var delta = 0;\n    var _findSelectorMatch = findSelectorMatch(currentSelector, attributeRegex);\n    var _findSelectorMatch2 = _slicedToArray__default[\"default\"](_findSelectorMatch, 2);\n    currentSelector = _findSelectorMatch2[0];\n    delta = _findSelectorMatch2[1];\n    specificity[1] += delta;\n    var _findSelectorMatch3 = findSelectorMatch(currentSelector, idRegex);\n    var _findSelectorMatch4 = _slicedToArray__default[\"default\"](_findSelectorMatch3, 2);\n    currentSelector = _findSelectorMatch4[0];\n    delta = _findSelectorMatch4[1];\n    specificity[0] += delta;\n    var _findSelectorMatch5 = findSelectorMatch(currentSelector, classRegex);\n    var _findSelectorMatch6 = _slicedToArray__default[\"default\"](_findSelectorMatch5, 2);\n    currentSelector = _findSelectorMatch6[0];\n    delta = _findSelectorMatch6[1];\n    specificity[1] += delta;\n    var _findSelectorMatch7 = findSelectorMatch(currentSelector, pseudoElementRegex);\n    var _findSelectorMatch8 = _slicedToArray__default[\"default\"](_findSelectorMatch7, 2);\n    currentSelector = _findSelectorMatch8[0];\n    delta = _findSelectorMatch8[1];\n    specificity[2] += delta;\n    var _findSelectorMatch9 = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);\n    var _findSelectorMatch10 = _slicedToArray__default[\"default\"](_findSelectorMatch9, 2);\n    currentSelector = _findSelectorMatch10[0];\n    delta = _findSelectorMatch10[1];\n    specificity[1] += delta;\n    var _findSelectorMatch11 = findSelectorMatch(currentSelector, pseudoClassRegex);\n    var _findSelectorMatch12 = _slicedToArray__default[\"default\"](_findSelectorMatch11, 2);\n    currentSelector = _findSelectorMatch12[0];\n    delta = _findSelectorMatch12[1];\n    specificity[1] += delta;\n    currentSelector = currentSelector.replace(/[*\\s+>~]/g, \" \").replace(/[#.]/g, \" \");\n    var _findSelectorMatch13 = findSelectorMatch(currentSelector, elementRegex);\n    var _findSelectorMatch14 = _slicedToArray__default[\"default\"](_findSelectorMatch13, 2);\n    currentSelector = _findSelectorMatch14[0];\n    delta = _findSelectorMatch14[1];\n    // lgtm [js/useless-assignment-to-local]\n    specificity[2] += delta;\n    return specificity.join(\"\");\n}\nvar PSEUDO_ZERO = .00000001;\n/**\r\n * Vector magnitude.\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorMagnitude(v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n}\n/**\r\n * Ratio between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsRatio(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));\n}\n/**\r\n * Angle between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));\n}\nfunction CB1(t) {\n    return t * t * t;\n}\nfunction CB2(t) {\n    return 3 * t * t * (1 - t);\n}\nfunction CB3(t) {\n    return 3 * t * (1 - t) * (1 - t);\n}\nfunction CB4(t) {\n    return (1 - t) * (1 - t) * (1 - t);\n}\nfunction QB1(t) {\n    return t * t;\n}\nfunction QB2(t) {\n    return 2 * t * (1 - t);\n}\nfunction QB3(t) {\n    return (1 - t) * (1 - t);\n}\nvar Property = /*#__PURE__*/ function() {\n    function Property(document1, name, value) {\n        _classCallCheck__default[\"default\"](this, Property);\n        this.document = document1;\n        this.name = name;\n        this.value = value;\n        this.isNormalizedColor = false;\n    }\n    _createClass__default[\"default\"](Property, [\n        {\n            key: \"split\",\n            value: function split() {\n                var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \" \";\n                var document1 = this.document, name = this.name;\n                return compressSpaces(this.getString()).trim().split(separator).map(function(value) {\n                    return new Property(document1, name, value);\n                });\n            }\n        },\n        {\n            key: \"hasValue\",\n            value: function hasValue(zeroIsValue) {\n                var value = this.value;\n                return value !== null && value !== \"\" && (zeroIsValue || value !== 0) && typeof value !== \"undefined\";\n            }\n        },\n        {\n            key: \"isString\",\n            value: function isString(regexp) {\n                var value = this.value;\n                var result = typeof value === \"string\";\n                if (!result || !regexp) {\n                    return result;\n                }\n                return regexp.test(value);\n            }\n        },\n        {\n            key: \"isUrlDefinition\",\n            value: function isUrlDefinition() {\n                return this.isString(/^url\\(/);\n            }\n        },\n        {\n            key: \"isPixels\",\n            value: function isPixels() {\n                if (!this.hasValue()) {\n                    return false;\n                }\n                var asString = this.getString();\n                switch(true){\n                    case asString.endsWith(\"px\"):\n                    case /^[0-9]+$/.test(asString):\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        },\n        {\n            key: \"setValue\",\n            value: function setValue(value) {\n                this.value = value;\n                return this;\n            }\n        },\n        {\n            key: \"getValue\",\n            value: function getValue(def) {\n                if (typeof def === \"undefined\" || this.hasValue()) {\n                    return this.value;\n                }\n                return def;\n            }\n        },\n        {\n            key: \"getNumber\",\n            value: function getNumber(def) {\n                if (!this.hasValue()) {\n                    if (typeof def === \"undefined\") {\n                        return 0;\n                    }\n                    return parseFloat(def);\n                }\n                var value = this.value;\n                var n = parseFloat(value);\n                if (this.isString(/%$/)) {\n                    n /= 100.0;\n                }\n                return n;\n            }\n        },\n        {\n            key: \"getString\",\n            value: function getString(def) {\n                if (typeof def === \"undefined\" || this.hasValue()) {\n                    return typeof this.value === \"undefined\" ? \"\" : String(this.value);\n                }\n                return String(def);\n            }\n        },\n        {\n            key: \"getColor\",\n            value: function getColor(def) {\n                var color = this.getString(def);\n                if (this.isNormalizedColor) {\n                    return color;\n                }\n                this.isNormalizedColor = true;\n                color = normalizeColor(color);\n                this.value = color;\n                return color;\n            }\n        },\n        {\n            key: \"getDpi\",\n            value: function getDpi() {\n                return 96.0; // TODO: compute?\n            }\n        },\n        {\n            key: \"getRem\",\n            value: function getRem() {\n                return this.document.rootEmSize;\n            }\n        },\n        {\n            key: \"getEm\",\n            value: function getEm() {\n                return this.document.emSize;\n            }\n        },\n        {\n            key: \"getUnits\",\n            value: function getUnits() {\n                return this.getString().replace(/[0-9.-]/g, \"\");\n            }\n        },\n        {\n            key: \"getPixels\",\n            value: function getPixels(axisOrIsFontSize) {\n                var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                if (!this.hasValue()) {\n                    return 0;\n                }\n                var _ref = typeof axisOrIsFontSize === \"boolean\" ? [\n                    undefined,\n                    axisOrIsFontSize\n                ] : [\n                    axisOrIsFontSize\n                ], _ref2 = _slicedToArray__default[\"default\"](_ref, 2), axis = _ref2[0], isFontSize = _ref2[1];\n                var viewPort = this.document.screen.viewPort;\n                switch(true){\n                    case this.isString(/vmin$/):\n                        return this.getNumber() / 100.0 * Math.min(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n                    case this.isString(/vmax$/):\n                        return this.getNumber() / 100.0 * Math.max(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n                    case this.isString(/vw$/):\n                        return this.getNumber() / 100.0 * viewPort.computeSize(\"x\");\n                    case this.isString(/vh$/):\n                        return this.getNumber() / 100.0 * viewPort.computeSize(\"y\");\n                    case this.isString(/rem$/):\n                        return this.getNumber() * this.getRem();\n                    case this.isString(/em$/):\n                        return this.getNumber() * this.getEm();\n                    case this.isString(/ex$/):\n                        return this.getNumber() * this.getEm() / 2.0;\n                    case this.isString(/px$/):\n                        return this.getNumber();\n                    case this.isString(/pt$/):\n                        return this.getNumber() * this.getDpi() * (1.0 / 72.0);\n                    case this.isString(/pc$/):\n                        return this.getNumber() * 15;\n                    case this.isString(/cm$/):\n                        return this.getNumber() * this.getDpi() / 2.54;\n                    case this.isString(/mm$/):\n                        return this.getNumber() * this.getDpi() / 25.4;\n                    case this.isString(/in$/):\n                        return this.getNumber() * this.getDpi();\n                    case this.isString(/%$/) && isFontSize:\n                        return this.getNumber() * this.getEm();\n                    case this.isString(/%$/):\n                        return this.getNumber() * viewPort.computeSize(axis);\n                    default:\n                        {\n                            var n = this.getNumber();\n                            if (processPercent && n < 1.0) {\n                                return n * viewPort.computeSize(axis);\n                            }\n                            return n;\n                        }\n                }\n            }\n        },\n        {\n            key: \"getMilliseconds\",\n            value: function getMilliseconds() {\n                if (!this.hasValue()) {\n                    return 0;\n                }\n                if (this.isString(/ms$/)) {\n                    return this.getNumber();\n                }\n                return this.getNumber() * 1000;\n            }\n        },\n        {\n            key: \"getRadians\",\n            value: function getRadians() {\n                if (!this.hasValue()) {\n                    return 0;\n                }\n                switch(true){\n                    case this.isString(/deg$/):\n                        return this.getNumber() * (Math.PI / 180.0);\n                    case this.isString(/grad$/):\n                        return this.getNumber() * (Math.PI / 200.0);\n                    case this.isString(/rad$/):\n                        return this.getNumber();\n                    default:\n                        return this.getNumber() * (Math.PI / 180.0);\n                }\n            }\n        },\n        {\n            key: \"getDefinition\",\n            value: function getDefinition() {\n                var asString = this.getString();\n                var name = /#([^)'\"]+)/.exec(asString);\n                if (name) {\n                    name = name[1];\n                }\n                if (!name) {\n                    name = asString;\n                }\n                return this.document.definitions[name];\n            }\n        },\n        {\n            key: \"getFillStyleDefinition\",\n            value: function getFillStyleDefinition(element, opacity) {\n                var def = this.getDefinition();\n                if (!def) {\n                    return null;\n                } // gradient\n                if (typeof def.createGradient === \"function\") {\n                    return def.createGradient(this.document.ctx, element, opacity);\n                } // pattern\n                if (typeof def.createPattern === \"function\") {\n                    if (def.getHrefAttribute().hasValue()) {\n                        var patternTransform = def.getAttribute(\"patternTransform\");\n                        def = def.getHrefAttribute().getDefinition();\n                        if (patternTransform.hasValue()) {\n                            def.getAttribute(\"patternTransform\", true).setValue(patternTransform.value);\n                        }\n                    }\n                    return def.createPattern(this.document.ctx, element, opacity);\n                }\n                return null;\n            }\n        },\n        {\n            key: \"getTextBaseline\",\n            value: function getTextBaseline() {\n                if (!this.hasValue()) {\n                    return null;\n                }\n                return Property.textBaselineMapping[this.getString()];\n            }\n        },\n        {\n            key: \"addOpacity\",\n            value: function addOpacity(opacity) {\n                var value = this.getColor();\n                var len = value.length;\n                var commas = 0; // Simulate old RGBColor version, which can't parse rgba.\n                for(var i = 0; i < len; i++){\n                    if (value[i] === \",\") {\n                        commas++;\n                    }\n                    if (commas === 3) {\n                        break;\n                    }\n                }\n                if (opacity.hasValue() && this.isString() && commas !== 3) {\n                    var color = new RGBColor__default[\"default\"](value);\n                    if (color.ok) {\n                        color.alpha = opacity.getNumber();\n                        value = color.toRGBA();\n                    }\n                }\n                return new Property(this.document, this.name, value);\n            }\n        }\n    ], [\n        {\n            key: \"empty\",\n            value: function empty(document1) {\n                return new Property(document1, \"EMPTY\", \"\");\n            }\n        }\n    ]);\n    return Property;\n}();\nProperty.textBaselineMapping = {\n    \"baseline\": \"alphabetic\",\n    \"before-edge\": \"top\",\n    \"text-before-edge\": \"top\",\n    \"middle\": \"middle\",\n    \"central\": \"middle\",\n    \"after-edge\": \"bottom\",\n    \"text-after-edge\": \"bottom\",\n    \"ideographic\": \"ideographic\",\n    \"alphabetic\": \"alphabetic\",\n    \"hanging\": \"hanging\",\n    \"mathematical\": \"alphabetic\"\n};\nvar ViewPort = /*#__PURE__*/ function() {\n    function ViewPort() {\n        _classCallCheck__default[\"default\"](this, ViewPort);\n        this.viewPorts = [];\n    }\n    _createClass__default[\"default\"](ViewPort, [\n        {\n            key: \"clear\",\n            value: function clear() {\n                this.viewPorts = [];\n            }\n        },\n        {\n            key: \"setCurrent\",\n            value: function setCurrent(width, height) {\n                this.viewPorts.push({\n                    width: width,\n                    height: height\n                });\n            }\n        },\n        {\n            key: \"removeCurrent\",\n            value: function removeCurrent() {\n                this.viewPorts.pop();\n            }\n        },\n        {\n            key: \"getCurrent\",\n            value: function getCurrent() {\n                var viewPorts = this.viewPorts;\n                return viewPorts[viewPorts.length - 1];\n            }\n        },\n        {\n            key: \"computeSize\",\n            value: function computeSize(d) {\n                if (typeof d === \"number\") {\n                    return d;\n                }\n                if (d === \"x\") {\n                    return this.width;\n                }\n                if (d === \"y\") {\n                    return this.height;\n                }\n                return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n            }\n        },\n        {\n            key: \"width\",\n            get: function get() {\n                return this.getCurrent().width;\n            }\n        },\n        {\n            key: \"height\",\n            get: function get() {\n                return this.getCurrent().height;\n            }\n        }\n    ]);\n    return ViewPort;\n}();\nvar Point = /*#__PURE__*/ function() {\n    function Point(x, y) {\n        _classCallCheck__default[\"default\"](this, Point);\n        this.x = x;\n        this.y = y;\n    }\n    _createClass__default[\"default\"](Point, [\n        {\n            key: \"angleTo\",\n            value: function angleTo(point) {\n                return Math.atan2(point.y - this.y, point.x - this.x);\n            }\n        },\n        {\n            key: \"applyTransform\",\n            value: function applyTransform(transform) {\n                var x = this.x, y = this.y;\n                var xp = x * transform[0] + y * transform[2] + transform[4];\n                var yp = x * transform[1] + y * transform[3] + transform[5];\n                this.x = xp;\n                this.y = yp;\n            }\n        }\n    ], [\n        {\n            key: \"parse\",\n            value: function parse(point) {\n                var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                var _toNumbers = toNumbers(point), _toNumbers2 = _slicedToArray__default[\"default\"](_toNumbers, 2), _toNumbers2$ = _toNumbers2[0], x = _toNumbers2$ === void 0 ? defaultValue : _toNumbers2$, _toNumbers2$2 = _toNumbers2[1], y = _toNumbers2$2 === void 0 ? defaultValue : _toNumbers2$2;\n                return new Point(x, y);\n            }\n        },\n        {\n            key: \"parseScale\",\n            value: function parseScale(scale) {\n                var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n                var _toNumbers3 = toNumbers(scale), _toNumbers4 = _slicedToArray__default[\"default\"](_toNumbers3, 2), _toNumbers4$ = _toNumbers4[0], x = _toNumbers4$ === void 0 ? defaultValue : _toNumbers4$, _toNumbers4$2 = _toNumbers4[1], y = _toNumbers4$2 === void 0 ? x : _toNumbers4$2;\n                return new Point(x, y);\n            }\n        },\n        {\n            key: \"parsePath\",\n            value: function parsePath(path) {\n                var points = toNumbers(path);\n                var len = points.length;\n                var pathPoints = [];\n                for(var i = 0; i < len; i += 2){\n                    pathPoints.push(new Point(points[i], points[i + 1]));\n                }\n                return pathPoints;\n            }\n        }\n    ]);\n    return Point;\n}();\nvar Mouse = /*#__PURE__*/ function() {\n    function Mouse(screen) {\n        _classCallCheck__default[\"default\"](this, Mouse);\n        this.screen = screen;\n        this.working = false;\n        this.events = [];\n        this.eventElements = []; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onClick = this.onClick.bind(this); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onMouseMove = this.onMouseMove.bind(this);\n    }\n    _createClass__default[\"default\"](Mouse, [\n        {\n            key: \"isWorking\",\n            value: function isWorking() {\n                return this.working;\n            }\n        },\n        {\n            key: \"start\",\n            value: function start() {\n                if (this.working) {\n                    return;\n                }\n                var screen = this.screen, onClick = this.onClick, onMouseMove = this.onMouseMove;\n                var canvas = screen.ctx.canvas;\n                canvas.onclick = onClick;\n                canvas.onmousemove = onMouseMove;\n                this.working = true;\n            }\n        },\n        {\n            key: \"stop\",\n            value: function stop() {\n                if (!this.working) {\n                    return;\n                }\n                var canvas = this.screen.ctx.canvas;\n                this.working = false;\n                canvas.onclick = null;\n                canvas.onmousemove = null;\n            }\n        },\n        {\n            key: \"hasEvents\",\n            value: function hasEvents() {\n                return this.working && this.events.length > 0;\n            }\n        },\n        {\n            key: \"runEvents\",\n            value: function runEvents() {\n                if (!this.working) {\n                    return;\n                }\n                var document1 = this.screen, events = this.events, eventElements = this.eventElements;\n                var style = document1.ctx.canvas.style;\n                if (style) {\n                    style.cursor = \"\";\n                }\n                events.forEach(function(_ref, i) {\n                    var run = _ref.run;\n                    var element = eventElements[i];\n                    while(element){\n                        run(element);\n                        element = element.parent;\n                    }\n                }); // done running, clear\n                this.events = [];\n                this.eventElements = [];\n            }\n        },\n        {\n            key: \"checkPath\",\n            value: function checkPath(element, ctx) {\n                if (!this.working || !ctx) {\n                    return;\n                }\n                var events = this.events, eventElements = this.eventElements;\n                events.forEach(function(_ref2, i) {\n                    var x = _ref2.x, y = _ref2.y;\n                    if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {\n                        eventElements[i] = element;\n                    }\n                });\n            }\n        },\n        {\n            key: \"checkBoundingBox\",\n            value: function checkBoundingBox(element, boundingBox) {\n                if (!this.working || !boundingBox) {\n                    return;\n                }\n                var events = this.events, eventElements = this.eventElements;\n                events.forEach(function(_ref3, i) {\n                    var x = _ref3.x, y = _ref3.y;\n                    if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {\n                        eventElements[i] = element;\n                    }\n                });\n            }\n        },\n        {\n            key: \"mapXY\",\n            value: function mapXY(x, y) {\n                var _this$screen = this.screen, window1 = _this$screen.window, ctx = _this$screen.ctx;\n                var point = new Point(x, y);\n                var element = ctx.canvas;\n                while(element){\n                    point.x -= element.offsetLeft;\n                    point.y -= element.offsetTop;\n                    element = element.offsetParent;\n                }\n                if (window1.scrollX) {\n                    point.x += window1.scrollX;\n                }\n                if (window1.scrollY) {\n                    point.y += window1.scrollY;\n                }\n                return point;\n            }\n        },\n        {\n            key: \"onClick\",\n            value: function onClick(event) {\n                var _this$mapXY = this.mapXY(event.clientX, event.clientY), x = _this$mapXY.x, y = _this$mapXY.y;\n                this.events.push({\n                    type: \"onclick\",\n                    x: x,\n                    y: y,\n                    run: function run(eventTarget) {\n                        if (eventTarget.onClick) {\n                            eventTarget.onClick();\n                        }\n                    }\n                });\n            }\n        },\n        {\n            key: \"onMouseMove\",\n            value: function onMouseMove(event) {\n                var _this$mapXY2 = this.mapXY(event.clientX, event.clientY), x = _this$mapXY2.x, y = _this$mapXY2.y;\n                this.events.push({\n                    type: \"onmousemove\",\n                    x: x,\n                    y: y,\n                    run: function run(eventTarget) {\n                        if (eventTarget.onMouseMove) {\n                            eventTarget.onMouseMove();\n                        }\n                    }\n                });\n            }\n        }\n    ]);\n    return Mouse;\n}();\nvar defaultWindow =  false ? 0 : null;\nvar defaultFetch$1 = typeof fetch !== \"undefined\" ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.\n : null;\nvar Screen = /*#__PURE__*/ function() {\n    function Screen(ctx) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$fetch = _ref.fetch, fetch1 = _ref$fetch === void 0 ? defaultFetch$1 : _ref$fetch, _ref$window = _ref.window, window1 = _ref$window === void 0 ? defaultWindow : _ref$window;\n        _classCallCheck__default[\"default\"](this, Screen);\n        this.ctx = ctx;\n        this.FRAMERATE = 30;\n        this.MAX_VIRTUAL_PIXELS = 30000;\n        this.CLIENT_WIDTH = 800;\n        this.CLIENT_HEIGHT = 600;\n        this.viewPort = new ViewPort();\n        this.mouse = new Mouse(this);\n        this.animations = [];\n        this.waits = [];\n        this.frameDuration = 0;\n        this.isReadyLock = false;\n        this.isFirstRender = true;\n        this.intervalId = null;\n        this.window = window1;\n        this.fetch = fetch1;\n    }\n    _createClass__default[\"default\"](Screen, [\n        {\n            key: \"wait\",\n            value: function wait(checker) {\n                this.waits.push(checker);\n            }\n        },\n        {\n            key: \"ready\",\n            value: function ready() {\n                // eslint-disable-next-line @typescript-eslint/no-misused-promises\n                if (!this.readyPromise) {\n                    return Promise.resolve();\n                }\n                return this.readyPromise;\n            }\n        },\n        {\n            key: \"isReady\",\n            value: function isReady() {\n                if (this.isReadyLock) {\n                    return true;\n                }\n                var isReadyLock = this.waits.every(function(_) {\n                    return _();\n                });\n                if (isReadyLock) {\n                    this.waits = [];\n                    if (this.resolveReady) {\n                        this.resolveReady();\n                    }\n                }\n                this.isReadyLock = isReadyLock;\n                return isReadyLock;\n            }\n        },\n        {\n            key: \"setDefaults\",\n            value: function setDefaults(ctx) {\n                // initial values and defaults\n                ctx.strokeStyle = \"rgba(0,0,0,0)\";\n                ctx.lineCap = \"butt\";\n                ctx.lineJoin = \"miter\";\n                ctx.miterLimit = 4;\n            }\n        },\n        {\n            key: \"setViewBox\",\n            value: function setViewBox(_ref2) {\n                var document1 = _ref2.document, ctx = _ref2.ctx, aspectRatio = _ref2.aspectRatio, width = _ref2.width, desiredWidth = _ref2.desiredWidth, height = _ref2.height, desiredHeight = _ref2.desiredHeight, _ref2$minX = _ref2.minX, minX = _ref2$minX === void 0 ? 0 : _ref2$minX, _ref2$minY = _ref2.minY, minY = _ref2$minY === void 0 ? 0 : _ref2$minY, refX = _ref2.refX, refY = _ref2.refY, _ref2$clip = _ref2.clip, clip = _ref2$clip === void 0 ? false : _ref2$clip, _ref2$clipX = _ref2.clipX, clipX = _ref2$clipX === void 0 ? 0 : _ref2$clipX, _ref2$clipY = _ref2.clipY, clipY = _ref2$clipY === void 0 ? 0 : _ref2$clipY;\n                // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n                var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\\s/, \"\"); // ignore defer\n                var _cleanAspectRatio$spl = cleanAspectRatio.split(\" \"), _cleanAspectRatio$spl2 = _slicedToArray__default[\"default\"](_cleanAspectRatio$spl, 2), aspectRatioAlign = _cleanAspectRatio$spl2[0], aspectRatioMeetOrSlice = _cleanAspectRatio$spl2[1];\n                var align = aspectRatioAlign || \"xMidYMid\";\n                var meetOrSlice = aspectRatioMeetOrSlice || \"meet\"; // calculate scale\n                var scaleX = width / desiredWidth;\n                var scaleY = height / desiredHeight;\n                var scaleMin = Math.min(scaleX, scaleY);\n                var scaleMax = Math.max(scaleX, scaleY);\n                var finalDesiredWidth = desiredWidth;\n                var finalDesiredHeight = desiredHeight;\n                if (meetOrSlice === \"meet\") {\n                    finalDesiredWidth *= scaleMin;\n                    finalDesiredHeight *= scaleMin;\n                }\n                if (meetOrSlice === \"slice\") {\n                    finalDesiredWidth *= scaleMax;\n                    finalDesiredHeight *= scaleMax;\n                }\n                var refXProp = new Property(document1, \"refX\", refX);\n                var refYProp = new Property(document1, \"refY\", refY);\n                var hasRefs = refXProp.hasValue() && refYProp.hasValue();\n                if (hasRefs) {\n                    ctx.translate(-scaleMin * refXProp.getPixels(\"x\"), -scaleMin * refYProp.getPixels(\"y\"));\n                }\n                if (clip) {\n                    var scaledClipX = scaleMin * clipX;\n                    var scaledClipY = scaleMin * clipY;\n                    ctx.beginPath();\n                    ctx.moveTo(scaledClipX, scaledClipY);\n                    ctx.lineTo(width, scaledClipY);\n                    ctx.lineTo(width, height);\n                    ctx.lineTo(scaledClipX, height);\n                    ctx.closePath();\n                    ctx.clip();\n                }\n                if (!hasRefs) {\n                    var isMeetMinY = meetOrSlice === \"meet\" && scaleMin === scaleY;\n                    var isSliceMaxY = meetOrSlice === \"slice\" && scaleMax === scaleY;\n                    var isMeetMinX = meetOrSlice === \"meet\" && scaleMin === scaleX;\n                    var isSliceMaxX = meetOrSlice === \"slice\" && scaleMax === scaleX;\n                    if (align.startsWith(\"xMid\") && (isMeetMinY || isSliceMaxY)) {\n                        ctx.translate(width / 2.0 - finalDesiredWidth / 2.0, 0);\n                    }\n                    if (align.endsWith(\"YMid\") && (isMeetMinX || isSliceMaxX)) {\n                        ctx.translate(0, height / 2.0 - finalDesiredHeight / 2.0);\n                    }\n                    if (align.startsWith(\"xMax\") && (isMeetMinY || isSliceMaxY)) {\n                        ctx.translate(width - finalDesiredWidth, 0);\n                    }\n                    if (align.endsWith(\"YMax\") && (isMeetMinX || isSliceMaxX)) {\n                        ctx.translate(0, height - finalDesiredHeight);\n                    }\n                } // scale\n                switch(true){\n                    case align === \"none\":\n                        ctx.scale(scaleX, scaleY);\n                        break;\n                    case meetOrSlice === \"meet\":\n                        ctx.scale(scaleMin, scaleMin);\n                        break;\n                    case meetOrSlice === \"slice\":\n                        ctx.scale(scaleMax, scaleMax);\n                        break;\n                } // translate\n                ctx.translate(-minX, -minY);\n            }\n        },\n        {\n            key: \"start\",\n            value: function start(element) {\n                var _this = this;\n                var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref3$enableRedraw = _ref3.enableRedraw, enableRedraw = _ref3$enableRedraw === void 0 ? false : _ref3$enableRedraw, _ref3$ignoreMouse = _ref3.ignoreMouse, ignoreMouse = _ref3$ignoreMouse === void 0 ? false : _ref3$ignoreMouse, _ref3$ignoreAnimation = _ref3.ignoreAnimation, ignoreAnimation = _ref3$ignoreAnimation === void 0 ? false : _ref3$ignoreAnimation, _ref3$ignoreDimension = _ref3.ignoreDimensions, ignoreDimensions = _ref3$ignoreDimension === void 0 ? false : _ref3$ignoreDimension, _ref3$ignoreClear = _ref3.ignoreClear, ignoreClear = _ref3$ignoreClear === void 0 ? false : _ref3$ignoreClear, forceRedraw = _ref3.forceRedraw, scaleWidth = _ref3.scaleWidth, scaleHeight = _ref3.scaleHeight, offsetX = _ref3.offsetX, offsetY = _ref3.offsetY;\n                var FRAMERATE = this.FRAMERATE, mouse = this.mouse;\n                var frameDuration = 1000 / FRAMERATE;\n                this.frameDuration = frameDuration;\n                this.readyPromise = new Promise(function(resolve) {\n                    _this.resolveReady = resolve;\n                });\n                if (this.isReady()) {\n                    this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                }\n                if (!enableRedraw) {\n                    return;\n                }\n                var now = Date.now();\n                var then = now;\n                var delta = 0;\n                var tick = function tick() {\n                    now = Date.now();\n                    delta = now - then;\n                    if (delta >= frameDuration) {\n                        then = now - delta % frameDuration;\n                        if (_this.shouldUpdate(ignoreAnimation, forceRedraw)) {\n                            _this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                            mouse.runEvents();\n                        }\n                    }\n                    _this.intervalId = requestAnimationFrame__default[\"default\"](tick);\n                };\n                if (!ignoreMouse) {\n                    mouse.start();\n                }\n                this.intervalId = requestAnimationFrame__default[\"default\"](tick);\n            }\n        },\n        {\n            key: \"stop\",\n            value: function stop() {\n                if (this.intervalId) {\n                    requestAnimationFrame__default[\"default\"].cancel(this.intervalId);\n                    this.intervalId = null;\n                }\n                this.mouse.stop();\n            }\n        },\n        {\n            key: \"shouldUpdate\",\n            value: function shouldUpdate(ignoreAnimation, forceRedraw) {\n                // need update from animations?\n                if (!ignoreAnimation) {\n                    var frameDuration = this.frameDuration;\n                    var shouldUpdate = this.animations.reduce(function(shouldUpdate, animation) {\n                        return animation.update(frameDuration) || shouldUpdate;\n                    }, false);\n                    if (shouldUpdate) {\n                        return true;\n                    }\n                } // need update from redraw?\n                if (typeof forceRedraw === \"function\" && forceRedraw()) {\n                    return true;\n                }\n                if (!this.isReadyLock && this.isReady()) {\n                    return true;\n                } // need update from mouse events?\n                if (this.mouse.hasEvents()) {\n                    return true;\n                }\n                return false;\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {\n                var CLIENT_WIDTH = this.CLIENT_WIDTH, CLIENT_HEIGHT = this.CLIENT_HEIGHT, viewPort = this.viewPort, ctx = this.ctx, isFirstRender = this.isFirstRender;\n                var canvas = ctx.canvas;\n                viewPort.clear();\n                if (canvas.width && canvas.height) {\n                    viewPort.setCurrent(canvas.width, canvas.height);\n                } else {\n                    viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);\n                }\n                var widthStyle = element.getStyle(\"width\");\n                var heightStyle = element.getStyle(\"height\");\n                if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== \"number\" && typeof scaleHeight !== \"number\")) {\n                    // set canvas size\n                    if (widthStyle.hasValue()) {\n                        canvas.width = widthStyle.getPixels(\"x\");\n                        if (canvas.style) {\n                            canvas.style.width = \"\".concat(canvas.width, \"px\");\n                        }\n                    }\n                    if (heightStyle.hasValue()) {\n                        canvas.height = heightStyle.getPixels(\"y\");\n                        if (canvas.style) {\n                            canvas.style.height = \"\".concat(canvas.height, \"px\");\n                        }\n                    }\n                }\n                var cWidth = canvas.clientWidth || canvas.width;\n                var cHeight = canvas.clientHeight || canvas.height;\n                if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {\n                    cWidth = widthStyle.getPixels(\"x\");\n                    cHeight = heightStyle.getPixels(\"y\");\n                }\n                viewPort.setCurrent(cWidth, cHeight);\n                if (typeof offsetX === \"number\") {\n                    element.getAttribute(\"x\", true).setValue(offsetX);\n                }\n                if (typeof offsetY === \"number\") {\n                    element.getAttribute(\"y\", true).setValue(offsetY);\n                }\n                if (typeof scaleWidth === \"number\" || typeof scaleHeight === \"number\") {\n                    var viewBox = toNumbers(element.getAttribute(\"viewBox\").getString());\n                    var xRatio = 0;\n                    var yRatio = 0;\n                    if (typeof scaleWidth === \"number\") {\n                        var _widthStyle = element.getStyle(\"width\");\n                        if (_widthStyle.hasValue()) {\n                            xRatio = _widthStyle.getPixels(\"x\") / scaleWidth;\n                        } else if (!isNaN(viewBox[2])) {\n                            xRatio = viewBox[2] / scaleWidth;\n                        }\n                    }\n                    if (typeof scaleHeight === \"number\") {\n                        var _heightStyle = element.getStyle(\"height\");\n                        if (_heightStyle.hasValue()) {\n                            yRatio = _heightStyle.getPixels(\"y\") / scaleHeight;\n                        } else if (!isNaN(viewBox[3])) {\n                            yRatio = viewBox[3] / scaleHeight;\n                        }\n                    }\n                    if (!xRatio) {\n                        xRatio = yRatio;\n                    }\n                    if (!yRatio) {\n                        yRatio = xRatio;\n                    }\n                    element.getAttribute(\"width\", true).setValue(scaleWidth);\n                    element.getAttribute(\"height\", true).setValue(scaleHeight);\n                    var transformStyle = element.getStyle(\"transform\", true, true);\n                    transformStyle.setValue(\"\".concat(transformStyle.getString(), \" scale(\").concat(1.0 / xRatio, \", \").concat(1.0 / yRatio, \")\"));\n                } // clear and render\n                if (!ignoreClear) {\n                    ctx.clearRect(0, 0, cWidth, cHeight);\n                }\n                element.render(ctx);\n                if (isFirstRender) {\n                    this.isFirstRender = false;\n                }\n            }\n        }\n    ]);\n    return Screen;\n}();\nScreen.defaultWindow = defaultWindow;\nScreen.defaultFetch = defaultFetch$1;\nvar defaultFetch = Screen.defaultFetch;\nvar DefaultDOMParser = typeof DOMParser !== \"undefined\" ? DOMParser : null;\nvar Parser = /*#__PURE__*/ function() {\n    function Parser() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$fetch = _ref.fetch, fetch1 = _ref$fetch === void 0 ? defaultFetch : _ref$fetch, _ref$DOMParser = _ref.DOMParser, DOMParser1 = _ref$DOMParser === void 0 ? DefaultDOMParser : _ref$DOMParser;\n        _classCallCheck__default[\"default\"](this, Parser);\n        this.fetch = fetch1;\n        this.DOMParser = DOMParser1;\n    }\n    _createClass__default[\"default\"](Parser, [\n        {\n            key: \"parse\",\n            value: function() {\n                var _parse = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee(resource) {\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    if (!resource.startsWith(\"<\")) {\n                                        _context.next = 2;\n                                        break;\n                                    }\n                                    return _context.abrupt(\"return\", this.parseFromString(resource));\n                                case 2:\n                                    return _context.abrupt(\"return\", this.load(resource));\n                                case 3:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, this);\n                }));\n                function parse(_x) {\n                    return _parse.apply(this, arguments);\n                }\n                return parse;\n            }()\n        },\n        {\n            key: \"parseFromString\",\n            value: function parseFromString(xml) {\n                var parser = new this.DOMParser();\n                try {\n                    return this.checkDocument(parser.parseFromString(xml, \"image/svg+xml\"));\n                } catch (err) {\n                    return this.checkDocument(parser.parseFromString(xml, \"text/xml\"));\n                }\n            }\n        },\n        {\n            key: \"checkDocument\",\n            value: function checkDocument(document1) {\n                var parserError = document1.getElementsByTagName(\"parsererror\")[0];\n                if (parserError) {\n                    throw new Error(parserError.textContent);\n                }\n                return document1;\n            }\n        },\n        {\n            key: \"load\",\n            value: function() {\n                var _load = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee2(url) {\n                    var response, xml;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee2$(_context2) {\n                        while(1){\n                            switch(_context2.prev = _context2.next){\n                                case 0:\n                                    _context2.next = 2;\n                                    return this.fetch(url);\n                                case 2:\n                                    response = _context2.sent;\n                                    _context2.next = 5;\n                                    return response.text();\n                                case 5:\n                                    xml = _context2.sent;\n                                    return _context2.abrupt(\"return\", this.parseFromString(xml));\n                                case 7:\n                                case \"end\":\n                                    return _context2.stop();\n                            }\n                        }\n                    }, _callee2, this);\n                }));\n                function load(_x2) {\n                    return _load.apply(this, arguments);\n                }\n                return load;\n            }()\n        }\n    ]);\n    return Parser;\n}();\nvar Translate = /*#__PURE__*/ function() {\n    function Translate(_, point) {\n        _classCallCheck__default[\"default\"](this, Translate);\n        this.type = \"translate\";\n        this.point = null;\n        this.point = Point.parse(point);\n    }\n    _createClass__default[\"default\"](Translate, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var _this$point = this.point, x = _this$point.x, y = _this$point.y;\n                ctx.translate(x || 0.0, y || 0.0);\n            }\n        },\n        {\n            key: \"unapply\",\n            value: function unapply(ctx) {\n                var _this$point2 = this.point, x = _this$point2.x, y = _this$point2.y;\n                ctx.translate(-1.0 * x || 0.0, -1.0 * y || 0.0);\n            }\n        },\n        {\n            key: \"applyToPoint\",\n            value: function applyToPoint(point) {\n                var _this$point3 = this.point, x = _this$point3.x, y = _this$point3.y;\n                point.applyTransform([\n                    1,\n                    0,\n                    0,\n                    1,\n                    x || 0.0,\n                    y || 0.0\n                ]);\n            }\n        }\n    ]);\n    return Translate;\n}();\nvar Rotate = /*#__PURE__*/ function() {\n    function Rotate(document1, rotate, transformOrigin) {\n        _classCallCheck__default[\"default\"](this, Rotate);\n        this.type = \"rotate\";\n        this.angle = null;\n        this.originX = null;\n        this.originY = null;\n        this.cx = 0;\n        this.cy = 0;\n        var numbers = toNumbers(rotate);\n        this.angle = new Property(document1, \"angle\", numbers[0]);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n        this.cx = numbers[1] || 0;\n        this.cy = numbers[2] || 0;\n    }\n    _createClass__default[\"default\"](Rotate, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var cx = this.cx, cy = this.cy, originX = this.originX, originY = this.originY, angle = this.angle;\n                var tx = cx + originX.getPixels(\"x\");\n                var ty = cy + originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.rotate(angle.getRadians());\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"unapply\",\n            value: function unapply(ctx) {\n                var cx = this.cx, cy = this.cy, originX = this.originX, originY = this.originY, angle = this.angle;\n                var tx = cx + originX.getPixels(\"x\");\n                var ty = cy + originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.rotate(-1.0 * angle.getRadians());\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"applyToPoint\",\n            value: function applyToPoint(point) {\n                var cx = this.cx, cy = this.cy, angle = this.angle;\n                var rad = angle.getRadians();\n                point.applyTransform([\n                    1,\n                    0,\n                    0,\n                    1,\n                    cx || 0.0,\n                    cy || 0.0 // this.p.y\n                ]);\n                point.applyTransform([\n                    Math.cos(rad),\n                    Math.sin(rad),\n                    -Math.sin(rad),\n                    Math.cos(rad),\n                    0,\n                    0\n                ]);\n                point.applyTransform([\n                    1,\n                    0,\n                    0,\n                    1,\n                    -cx || 0.0,\n                    -cy || 0.0 // -this.p.y\n                ]);\n            }\n        }\n    ]);\n    return Rotate;\n}();\nvar Scale = /*#__PURE__*/ function() {\n    function Scale(_, scale, transformOrigin) {\n        _classCallCheck__default[\"default\"](this, Scale);\n        this.type = \"scale\";\n        this.scale = null;\n        this.originX = null;\n        this.originY = null;\n        var scaleSize = Point.parseScale(scale); // Workaround for node-canvas\n        if (scaleSize.x === 0 || scaleSize.y === 0) {\n            scaleSize.x = PSEUDO_ZERO;\n            scaleSize.y = PSEUDO_ZERO;\n        }\n        this.scale = scaleSize;\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    _createClass__default[\"default\"](Scale, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var _this$scale = this.scale, x = _this$scale.x, y = _this$scale.y, originX = this.originX, originY = this.originY;\n                var tx = originX.getPixels(\"x\");\n                var ty = originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.scale(x, y || x);\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"unapply\",\n            value: function unapply(ctx) {\n                var _this$scale2 = this.scale, x = _this$scale2.x, y = _this$scale2.y, originX = this.originX, originY = this.originY;\n                var tx = originX.getPixels(\"x\");\n                var ty = originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.scale(1.0 / x, 1.0 / y || x);\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"applyToPoint\",\n            value: function applyToPoint(point) {\n                var _this$scale3 = this.scale, x = _this$scale3.x, y = _this$scale3.y;\n                point.applyTransform([\n                    x || 0.0,\n                    0,\n                    0,\n                    y || 0.0,\n                    0,\n                    0\n                ]);\n            }\n        }\n    ]);\n    return Scale;\n}();\nvar Matrix = /*#__PURE__*/ function() {\n    function Matrix(_, matrix, transformOrigin) {\n        _classCallCheck__default[\"default\"](this, Matrix);\n        this.type = \"matrix\";\n        this.matrix = [];\n        this.originX = null;\n        this.originY = null;\n        this.matrix = toNumbers(matrix);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    _createClass__default[\"default\"](Matrix, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var originX = this.originX, originY = this.originY, matrix = this.matrix;\n                var tx = originX.getPixels(\"x\");\n                var ty = originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"unapply\",\n            value: function unapply(ctx) {\n                var originX = this.originX, originY = this.originY, matrix = this.matrix;\n                var a = matrix[0];\n                var b = matrix[2];\n                var c = matrix[4];\n                var d = matrix[1];\n                var e = matrix[3];\n                var f = matrix[5];\n                var g = 0.0;\n                var h = 0.0;\n                var i = 1.0;\n                var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));\n                var tx = originX.getPixels(\"x\");\n                var ty = originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"applyToPoint\",\n            value: function applyToPoint(point) {\n                point.applyTransform(this.matrix);\n            }\n        }\n    ]);\n    return Matrix;\n}();\nfunction _createSuper$M(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$M();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$M() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar Skew = /*#__PURE__*/ function(_Matrix) {\n    _inherits__default[\"default\"](Skew, _Matrix);\n    var _super = _createSuper$M(Skew);\n    function Skew(document1, skew, transformOrigin) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, Skew);\n        _this = _super.call(this, document1, skew, transformOrigin);\n        _this.type = \"skew\";\n        _this.angle = null;\n        _this.angle = new Property(document1, \"angle\", skew);\n        return _this;\n    }\n    return Skew;\n}(Matrix);\nfunction _createSuper$L(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$L();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$L() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar SkewX = /*#__PURE__*/ function(_Skew) {\n    _inherits__default[\"default\"](SkewX, _Skew);\n    var _super = _createSuper$L(SkewX);\n    function SkewX(document1, skew, transformOrigin) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, SkewX);\n        _this = _super.call(this, document1, skew, transformOrigin);\n        _this.type = \"skewX\";\n        _this.matrix = [\n            1,\n            0,\n            Math.tan(_this.angle.getRadians()),\n            1,\n            0,\n            0\n        ];\n        return _this;\n    }\n    return SkewX;\n}(Skew);\nfunction _createSuper$K(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$K();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$K() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar SkewY = /*#__PURE__*/ function(_Skew) {\n    _inherits__default[\"default\"](SkewY, _Skew);\n    var _super = _createSuper$K(SkewY);\n    function SkewY(document1, skew, transformOrigin) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, SkewY);\n        _this = _super.call(this, document1, skew, transformOrigin);\n        _this.type = \"skewY\";\n        _this.matrix = [\n            1,\n            Math.tan(_this.angle.getRadians()),\n            0,\n            1,\n            0,\n            0\n        ];\n        return _this;\n    }\n    return SkewY;\n}(Skew);\nfunction parseTransforms(transform) {\n    return compressSpaces(transform).trim().replace(/\\)([a-zA-Z])/g, \") $1\").replace(/\\)(\\s?,\\s?)/g, \") \").split(/\\s(?=[a-z])/);\n}\nfunction parseTransform(transform) {\n    var _transform$split = transform.split(\"(\"), _transform$split2 = _slicedToArray__default[\"default\"](_transform$split, 2), type = _transform$split2[0], value = _transform$split2[1];\n    return [\n        type.trim(),\n        value.trim().replace(\")\", \"\")\n    ];\n}\nvar Transform = /*#__PURE__*/ function() {\n    function Transform(document1, transform, transformOrigin) {\n        var _this = this;\n        _classCallCheck__default[\"default\"](this, Transform);\n        this.document = document1;\n        this.transforms = [];\n        var data = parseTransforms(transform);\n        data.forEach(function(transform) {\n            if (transform === \"none\") {\n                return;\n            }\n            var _parseTransform = parseTransform(transform), _parseTransform2 = _slicedToArray__default[\"default\"](_parseTransform, 2), type = _parseTransform2[0], value = _parseTransform2[1];\n            var TransformType = Transform.transformTypes[type];\n            if (typeof TransformType !== \"undefined\") {\n                _this.transforms.push(new TransformType(_this.document, value, transformOrigin));\n            }\n        });\n    }\n    _createClass__default[\"default\"](Transform, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var transforms = this.transforms;\n                var len = transforms.length;\n                for(var i = 0; i < len; i++){\n                    transforms[i].apply(ctx);\n                }\n            }\n        },\n        {\n            key: \"unapply\",\n            value: function unapply(ctx) {\n                var transforms = this.transforms;\n                var len = transforms.length;\n                for(var i = len - 1; i >= 0; i--){\n                    transforms[i].unapply(ctx);\n                }\n            } // TODO: applyToPoint unused ... remove?\n        },\n        {\n            key: \"applyToPoint\",\n            value: function applyToPoint(point) {\n                var transforms = this.transforms;\n                var len = transforms.length;\n                for(var i = 0; i < len; i++){\n                    transforms[i].applyToPoint(point);\n                }\n            }\n        }\n    ], [\n        {\n            key: \"fromElement\",\n            value: function fromElement(document1, element) {\n                var transformStyle = element.getStyle(\"transform\", false, true);\n                var _element$getStyle$spl = element.getStyle(\"transform-origin\", false, true).split(), _element$getStyle$spl2 = _slicedToArray__default[\"default\"](_element$getStyle$spl, 2), transformOriginXProperty = _element$getStyle$spl2[0], _element$getStyle$spl3 = _element$getStyle$spl2[1], transformOriginYProperty = _element$getStyle$spl3 === void 0 ? transformOriginXProperty : _element$getStyle$spl3;\n                var transformOrigin = [\n                    transformOriginXProperty,\n                    transformOriginYProperty\n                ];\n                if (transformStyle.hasValue()) {\n                    return new Transform(document1, transformStyle.getString(), transformOrigin);\n                }\n                return null;\n            }\n        }\n    ]);\n    return Transform;\n}();\nTransform.transformTypes = {\n    translate: Translate,\n    rotate: Rotate,\n    scale: Scale,\n    matrix: Matrix,\n    skewX: SkewX,\n    skewY: SkewY\n};\nvar Element = /*#__PURE__*/ function() {\n    function Element(document1, node) {\n        var _this = this;\n        var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        _classCallCheck__default[\"default\"](this, Element);\n        this.document = document1;\n        this.node = node;\n        this.captureTextNodes = captureTextNodes;\n        this.attributes = Object.create(null);\n        this.styles = Object.create(null);\n        this.stylesSpecificity = Object.create(null);\n        this.animationFrozen = false;\n        this.animationFrozenValue = \"\";\n        this.parent = null;\n        this.children = [];\n        if (!node || node.nodeType !== 1) {\n            // ELEMENT_NODE\n            return;\n        } // add attributes\n        Array.from(node.attributes).forEach(function(attribute) {\n            var nodeName = normalizeAttributeName(attribute.nodeName);\n            _this.attributes[nodeName] = new Property(document1, nodeName, attribute.value);\n        });\n        this.addStylesFromStyleDefinition(); // add inline styles\n        if (this.getAttribute(\"style\").hasValue()) {\n            var styles = this.getAttribute(\"style\").getString().split(\";\").map(function(_) {\n                return _.trim();\n            });\n            styles.forEach(function(style) {\n                if (!style) {\n                    return;\n                }\n                var _style$split$map = style.split(\":\").map(function(_) {\n                    return _.trim();\n                }), _style$split$map2 = _slicedToArray__default[\"default\"](_style$split$map, 2), name = _style$split$map2[0], value = _style$split$map2[1];\n                _this.styles[name] = new Property(document1, name, value);\n            });\n        }\n        var definitions = document1.definitions;\n        var id = this.getAttribute(\"id\"); // add id\n        if (id.hasValue()) {\n            if (!definitions[id.getString()]) {\n                definitions[id.getString()] = this;\n            }\n        }\n        Array.from(node.childNodes).forEach(function(childNode) {\n            if (childNode.nodeType === 1) {\n                _this.addChild(childNode); // ELEMENT_NODE\n            } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {\n                var textNode = document1.createTextNode(childNode);\n                if (textNode.getText().length > 0) {\n                    _this.addChild(textNode); // TEXT_NODE\n                }\n            }\n        });\n    }\n    _createClass__default[\"default\"](Element, [\n        {\n            key: \"getAttribute\",\n            value: function getAttribute(name) {\n                var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var attr = this.attributes[name];\n                if (!attr && createIfNotExists) {\n                    var _attr = new Property(this.document, name, \"\");\n                    this.attributes[name] = _attr;\n                    return _attr;\n                }\n                return attr || Property.empty(this.document);\n            }\n        },\n        {\n            key: \"getHrefAttribute\",\n            value: function getHrefAttribute() {\n                for(var key in this.attributes){\n                    if (key === \"href\" || key.endsWith(\":href\")) {\n                        return this.attributes[key];\n                    }\n                }\n                return Property.empty(this.document);\n            }\n        },\n        {\n            key: \"getStyle\",\n            value: function getStyle(name) {\n                var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                var style = this.styles[name];\n                if (style) {\n                    return style;\n                }\n                var attr = this.getAttribute(name);\n                if (attr !== null && attr !== void 0 && attr.hasValue()) {\n                    this.styles[name] = attr; // move up to me to cache\n                    return attr;\n                }\n                if (!skipAncestors) {\n                    var parent = this.parent;\n                    if (parent) {\n                        var parentStyle = parent.getStyle(name);\n                        if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {\n                            return parentStyle;\n                        }\n                    }\n                }\n                if (createIfNotExists) {\n                    var _style = new Property(this.document, name, \"\");\n                    this.styles[name] = _style;\n                    return _style;\n                }\n                return style || Property.empty(this.document);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(ctx) {\n                // don't render display=none\n                // don't render visibility=hidden\n                if (this.getStyle(\"display\").getString() === \"none\" || this.getStyle(\"visibility\").getString() === \"hidden\") {\n                    return;\n                }\n                ctx.save();\n                if (this.getStyle(\"mask\").hasValue()) {\n                    // mask\n                    var mask = this.getStyle(\"mask\").getDefinition();\n                    if (mask) {\n                        this.applyEffects(ctx);\n                        mask.apply(ctx, this);\n                    }\n                } else if (this.getStyle(\"filter\").getValue(\"none\") !== \"none\") {\n                    // filter\n                    var filter = this.getStyle(\"filter\").getDefinition();\n                    if (filter) {\n                        this.applyEffects(ctx);\n                        filter.apply(ctx, this);\n                    }\n                } else {\n                    this.setContext(ctx);\n                    this.renderChildren(ctx);\n                    this.clearContext(ctx);\n                }\n                ctx.restore();\n            }\n        },\n        {\n            key: \"setContext\",\n            value: function setContext(_) {}\n        },\n        {\n            key: \"applyEffects\",\n            value: function applyEffects(ctx) {\n                // transform\n                var transform = Transform.fromElement(this.document, this);\n                if (transform) {\n                    transform.apply(ctx);\n                } // clip\n                var clipPathStyleProp = this.getStyle(\"clip-path\", false, true);\n                if (clipPathStyleProp.hasValue()) {\n                    var clip = clipPathStyleProp.getDefinition();\n                    if (clip) {\n                        clip.apply(ctx);\n                    }\n                }\n            }\n        },\n        {\n            key: \"clearContext\",\n            value: function clearContext(_) {}\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                this.children.forEach(function(child) {\n                    child.render(ctx);\n                });\n            }\n        },\n        {\n            key: \"addChild\",\n            value: function addChild(childNode) {\n                var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);\n                child.parent = this;\n                if (!Element.ignoreChildTypes.includes(child.type)) {\n                    this.children.push(child);\n                }\n            }\n        },\n        {\n            key: \"matchesSelector\",\n            value: function matchesSelector(selector) {\n                var _node$getAttribute;\n                var node = this.node;\n                if (typeof node.matches === \"function\") {\n                    return node.matches(selector);\n                }\n                var styleClasses = (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, \"class\");\n                if (!styleClasses || styleClasses === \"\") {\n                    return false;\n                }\n                return styleClasses.split(\" \").some(function(styleClass) {\n                    return \".\".concat(styleClass) === selector;\n                });\n            }\n        },\n        {\n            key: \"addStylesFromStyleDefinition\",\n            value: function addStylesFromStyleDefinition() {\n                var _this$document = this.document, styles = _this$document.styles, stylesSpecificity = _this$document.stylesSpecificity;\n                for(var selector in styles){\n                    if (!selector.startsWith(\"@\") && this.matchesSelector(selector)) {\n                        var style = styles[selector];\n                        var specificity = stylesSpecificity[selector];\n                        if (style) {\n                            for(var name in style){\n                                var existingSpecificity = this.stylesSpecificity[name];\n                                if (typeof existingSpecificity === \"undefined\") {\n                                    existingSpecificity = \"000\";\n                                }\n                                if (specificity >= existingSpecificity) {\n                                    this.styles[name] = style[name];\n                                    this.stylesSpecificity[name] = specificity;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        {\n            key: \"removeStyles\",\n            value: function removeStyles(element, ignoreStyles) {\n                var toRestore = ignoreStyles.reduce(function(toRestore, name) {\n                    var styleProp = element.getStyle(name);\n                    if (!styleProp.hasValue()) {\n                        return toRestore;\n                    }\n                    var value = styleProp.getString();\n                    styleProp.setValue(\"\");\n                    return [].concat(_toConsumableArray__default[\"default\"](toRestore), [\n                        [\n                            name,\n                            value\n                        ]\n                    ]);\n                }, []);\n                return toRestore;\n            }\n        },\n        {\n            key: \"restoreStyles\",\n            value: function restoreStyles(element, styles) {\n                styles.forEach(function(_ref) {\n                    var _ref2 = _slicedToArray__default[\"default\"](_ref, 2), name = _ref2[0], value = _ref2[1];\n                    element.getStyle(name, true).setValue(value);\n                });\n            }\n        },\n        {\n            key: \"isFirstChild\",\n            value: function isFirstChild() {\n                var _this$parent;\n                return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;\n            }\n        }\n    ]);\n    return Element;\n}();\nElement.ignoreChildTypes = [\n    \"title\"\n];\nfunction _createSuper$J(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$J();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$J() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar UnknownElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](UnknownElement, _Element);\n    var _super = _createSuper$J(UnknownElement);\n    function UnknownElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, UnknownElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        return _this;\n    }\n    return UnknownElement;\n}(Element);\nfunction wrapFontFamily(fontFamily) {\n    var trimmed = fontFamily.trim();\n    return /^('|\")/.test(trimmed) ? trimmed : '\"'.concat(trimmed, '\"');\n}\nfunction prepareFontFamily(fontFamily) {\n    return typeof process === \"undefined\" ? fontFamily : fontFamily.trim().split(\",\").map(wrapFontFamily).join(\",\");\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style\r\n * @param fontStyle\r\n * @returns CSS font style.\r\n */ function prepareFontStyle(fontStyle) {\n    if (!fontStyle) {\n        return \"\";\n    }\n    var targetFontStyle = fontStyle.trim().toLowerCase();\n    switch(targetFontStyle){\n        case \"normal\":\n        case \"italic\":\n        case \"oblique\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontStyle;\n        default:\n            if (/^oblique\\s+(-|)\\d+deg$/.test(targetFontStyle)) {\n                return targetFontStyle;\n            }\n            return \"\";\n    }\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight\r\n * @param fontWeight\r\n * @returns CSS font weight.\r\n */ function prepareFontWeight(fontWeight) {\n    if (!fontWeight) {\n        return \"\";\n    }\n    var targetFontWeight = fontWeight.trim().toLowerCase();\n    switch(targetFontWeight){\n        case \"normal\":\n        case \"bold\":\n        case \"lighter\":\n        case \"bolder\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontWeight;\n        default:\n            if (/^[\\d.]+$/.test(targetFontWeight)) {\n                return targetFontWeight;\n            }\n            return \"\";\n    }\n}\nvar Font = /*#__PURE__*/ function() {\n    function Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {\n        _classCallCheck__default[\"default\"](this, Font);\n        var inheritFont = inherit ? typeof inherit === \"string\" ? Font.parse(inherit) : inherit : {};\n        this.fontFamily = fontFamily || inheritFont.fontFamily;\n        this.fontSize = fontSize || inheritFont.fontSize;\n        this.fontStyle = fontStyle || inheritFont.fontStyle;\n        this.fontWeight = fontWeight || inheritFont.fontWeight;\n        this.fontVariant = fontVariant || inheritFont.fontVariant;\n    }\n    _createClass__default[\"default\"](Font, [\n        {\n            key: \"toString\",\n            value: function toString() {\n                return [\n                    prepareFontStyle(this.fontStyle),\n                    this.fontVariant,\n                    prepareFontWeight(this.fontWeight),\n                    this.fontSize,\n                    prepareFontFamily(this.fontFamily)\n                ].join(\" \").trim();\n            }\n        }\n    ], [\n        {\n            key: \"parse\",\n            value: function parse() {\n                var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n                var inherit = arguments.length > 1 ? arguments[1] : undefined;\n                var fontStyle = \"\";\n                var fontVariant = \"\";\n                var fontWeight = \"\";\n                var fontSize = \"\";\n                var fontFamily = \"\";\n                var parts = compressSpaces(font).trim().split(\" \");\n                var set = {\n                    fontSize: false,\n                    fontStyle: false,\n                    fontWeight: false,\n                    fontVariant: false\n                };\n                parts.forEach(function(part) {\n                    switch(true){\n                        case !set.fontStyle && Font.styles.includes(part):\n                            if (part !== \"inherit\") {\n                                fontStyle = part;\n                            }\n                            set.fontStyle = true;\n                            break;\n                        case !set.fontVariant && Font.variants.includes(part):\n                            if (part !== \"inherit\") {\n                                fontVariant = part;\n                            }\n                            set.fontStyle = true;\n                            set.fontVariant = true;\n                            break;\n                        case !set.fontWeight && Font.weights.includes(part):\n                            if (part !== \"inherit\") {\n                                fontWeight = part;\n                            }\n                            set.fontStyle = true;\n                            set.fontVariant = true;\n                            set.fontWeight = true;\n                            break;\n                        case !set.fontSize:\n                            if (part !== \"inherit\") {\n                                var _part$split = part.split(\"/\");\n                                var _part$split2 = _slicedToArray__default[\"default\"](_part$split, 1);\n                                fontSize = _part$split2[0];\n                            }\n                            set.fontStyle = true;\n                            set.fontVariant = true;\n                            set.fontWeight = true;\n                            set.fontSize = true;\n                            break;\n                        default:\n                            if (part !== \"inherit\") {\n                                fontFamily += part;\n                            }\n                    }\n                });\n                return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);\n            }\n        }\n    ]);\n    return Font;\n}();\nFont.styles = \"normal|italic|oblique|inherit\";\nFont.variants = \"normal|small-caps|inherit\";\nFont.weights = \"normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit\";\nvar BoundingBox = /*#__PURE__*/ function() {\n    function BoundingBox() {\n        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;\n        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;\n        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;\n        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;\n        _classCallCheck__default[\"default\"](this, BoundingBox);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    _createClass__default[\"default\"](BoundingBox, [\n        {\n            key: \"addPoint\",\n            value: function addPoint(x, y) {\n                if (typeof x !== \"undefined\") {\n                    if (isNaN(this.x1) || isNaN(this.x2)) {\n                        this.x1 = x;\n                        this.x2 = x;\n                    }\n                    if (x < this.x1) {\n                        this.x1 = x;\n                    }\n                    if (x > this.x2) {\n                        this.x2 = x;\n                    }\n                }\n                if (typeof y !== \"undefined\") {\n                    if (isNaN(this.y1) || isNaN(this.y2)) {\n                        this.y1 = y;\n                        this.y2 = y;\n                    }\n                    if (y < this.y1) {\n                        this.y1 = y;\n                    }\n                    if (y > this.y2) {\n                        this.y2 = y;\n                    }\n                }\n            }\n        },\n        {\n            key: \"addX\",\n            value: function addX(x) {\n                this.addPoint(x, null);\n            }\n        },\n        {\n            key: \"addY\",\n            value: function addY(y) {\n                this.addPoint(null, y);\n            }\n        },\n        {\n            key: \"addBoundingBox\",\n            value: function addBoundingBox(boundingBox) {\n                if (!boundingBox) {\n                    return;\n                }\n                var x1 = boundingBox.x1, y1 = boundingBox.y1, x2 = boundingBox.x2, y2 = boundingBox.y2;\n                this.addPoint(x1, y1);\n                this.addPoint(x2, y2);\n            }\n        },\n        {\n            key: \"sumCubic\",\n            value: function sumCubic(t, p0, p1, p2, p3) {\n                return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n            }\n        },\n        {\n            key: \"bezierCurveAdd\",\n            value: function bezierCurveAdd(forX, p0, p1, p2, p3) {\n                var b = 6 * p0 - 12 * p1 + 6 * p2;\n                var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n                var c = 3 * p1 - 3 * p0;\n                if (a === 0) {\n                    if (b === 0) {\n                        return;\n                    }\n                    var t = -c / b;\n                    if (0 < t && t < 1) {\n                        if (forX) {\n                            this.addX(this.sumCubic(t, p0, p1, p2, p3));\n                        } else {\n                            this.addY(this.sumCubic(t, p0, p1, p2, p3));\n                        }\n                    }\n                    return;\n                }\n                var b2ac = Math.pow(b, 2) - 4 * c * a;\n                if (b2ac < 0) {\n                    return;\n                }\n                var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n                if (0 < t1 && t1 < 1) {\n                    if (forX) {\n                        this.addX(this.sumCubic(t1, p0, p1, p2, p3));\n                    } else {\n                        this.addY(this.sumCubic(t1, p0, p1, p2, p3));\n                    }\n                }\n                var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n                if (0 < t2 && t2 < 1) {\n                    if (forX) {\n                        this.addX(this.sumCubic(t2, p0, p1, p2, p3));\n                    } else {\n                        this.addY(this.sumCubic(t2, p0, p1, p2, p3));\n                    }\n                }\n            } // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n        },\n        {\n            key: \"addBezierCurve\",\n            value: function addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n                this.addPoint(p0x, p0y);\n                this.addPoint(p3x, p3y);\n                this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);\n                this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);\n            }\n        },\n        {\n            key: \"addQuadraticCurve\",\n            value: function addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {\n                var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)\n                var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)\n                var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)\n                var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)\n                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n            }\n        },\n        {\n            key: \"isPointInBox\",\n            value: function isPointInBox(x, y) {\n                var x1 = this.x1, y1 = this.y1, x2 = this.x2, y2 = this.y2;\n                return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n            }\n        },\n        {\n            key: \"x\",\n            get: function get() {\n                return this.x1;\n            }\n        },\n        {\n            key: \"y\",\n            get: function get() {\n                return this.y1;\n            }\n        },\n        {\n            key: \"width\",\n            get: function get() {\n                return this.x2 - this.x1;\n            }\n        },\n        {\n            key: \"height\",\n            get: function get() {\n                return this.y2 - this.y1;\n            }\n        }\n    ]);\n    return BoundingBox;\n}();\nfunction _createSuper$I(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$I();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$I() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar PathParser = /*#__PURE__*/ function(_SVGPathData) {\n    _inherits__default[\"default\"](PathParser, _SVGPathData);\n    var _super = _createSuper$I(PathParser);\n    function PathParser(path) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, PathParser);\n        _this = _super.call(this, path // Fix spaces after signs.\n        .replace(/([+\\-.])\\s+/gm, \"$1\") // Remove invalid part.\n        .replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, \"\"));\n        _this.control = null;\n        _this.start = null;\n        _this.current = null;\n        _this.command = null;\n        _this.commands = _this.commands;\n        _this.i = -1;\n        _this.previousCommand = null;\n        _this.points = [];\n        _this.angles = [];\n        return _this;\n    }\n    _createClass__default[\"default\"](PathParser, [\n        {\n            key: \"reset\",\n            value: function reset() {\n                this.i = -1;\n                this.command = null;\n                this.previousCommand = null;\n                this.start = new Point(0, 0);\n                this.control = new Point(0, 0);\n                this.current = new Point(0, 0);\n                this.points = [];\n                this.angles = [];\n            }\n        },\n        {\n            key: \"isEnd\",\n            value: function isEnd() {\n                var i = this.i, commands = this.commands;\n                return i >= commands.length - 1;\n            }\n        },\n        {\n            key: \"next\",\n            value: function next() {\n                var command = this.commands[++this.i];\n                this.previousCommand = this.command;\n                this.command = command;\n                return command;\n            }\n        },\n        {\n            key: \"getPoint\",\n            value: function getPoint() {\n                var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"x\";\n                var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"y\";\n                var point = new Point(this.command[xProp], this.command[yProp]);\n                return this.makeAbsolute(point);\n            }\n        },\n        {\n            key: \"getAsControlPoint\",\n            value: function getAsControlPoint(xProp, yProp) {\n                var point = this.getPoint(xProp, yProp);\n                this.control = point;\n                return point;\n            }\n        },\n        {\n            key: \"getAsCurrentPoint\",\n            value: function getAsCurrentPoint(xProp, yProp) {\n                var point = this.getPoint(xProp, yProp);\n                this.current = point;\n                return point;\n            }\n        },\n        {\n            key: \"getReflectedControlPoint\",\n            value: function getReflectedControlPoint() {\n                var previousCommand = this.previousCommand.type;\n                if (previousCommand !== svgPathdata.SVGPathData.CURVE_TO && previousCommand !== svgPathdata.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svgPathdata.SVGPathData.QUAD_TO && previousCommand !== svgPathdata.SVGPathData.SMOOTH_QUAD_TO) {\n                    return this.current;\n                } // reflect point\n                var _this$current = this.current, cx = _this$current.x, cy = _this$current.y, _this$control = this.control, ox = _this$control.x, oy = _this$control.y;\n                var point = new Point(2 * cx - ox, 2 * cy - oy);\n                return point;\n            }\n        },\n        {\n            key: \"makeAbsolute\",\n            value: function makeAbsolute(point) {\n                if (this.command.relative) {\n                    var _this$current2 = this.current, x = _this$current2.x, y = _this$current2.y;\n                    point.x += x;\n                    point.y += y;\n                }\n                return point;\n            }\n        },\n        {\n            key: \"addMarker\",\n            value: function addMarker(point, from, priorTo) {\n                var points = this.points, angles = this.angles; // if the last angle isn't filled in because we didn't have this point yet ...\n                if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {\n                    angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);\n                }\n                this.addMarkerAngle(point, from ? from.angleTo(point) : null);\n            }\n        },\n        {\n            key: \"addMarkerAngle\",\n            value: function addMarkerAngle(point, angle) {\n                this.points.push(point);\n                this.angles.push(angle);\n            }\n        },\n        {\n            key: \"getMarkerPoints\",\n            value: function getMarkerPoints() {\n                return this.points;\n            }\n        },\n        {\n            key: \"getMarkerAngles\",\n            value: function getMarkerAngles() {\n                var angles = this.angles;\n                var len = angles.length;\n                for(var i = 0; i < len; i++){\n                    if (!angles[i]) {\n                        for(var j = i + 1; j < len; j++){\n                            if (angles[j]) {\n                                angles[i] = angles[j];\n                                break;\n                            }\n                        }\n                    }\n                }\n                return angles;\n            }\n        }\n    ]);\n    return PathParser;\n}(svgPathdata.SVGPathData);\nfunction _createSuper$H(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$H();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$H() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar RenderedElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](RenderedElement, _Element);\n    var _super = _createSuper$H(RenderedElement);\n    function RenderedElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, RenderedElement);\n        _this = _super.apply(this, arguments);\n        _this.modifiedEmSizeStack = false;\n        return _this;\n    }\n    _createClass__default[\"default\"](RenderedElement, [\n        {\n            key: \"calculateOpacity\",\n            value: function calculateOpacity() {\n                var opacity = 1.0; // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n                var element = this;\n                while(element){\n                    var opacityStyle = element.getStyle(\"opacity\", false, true); // no ancestors on style call\n                    if (opacityStyle.hasValue(true)) {\n                        opacity *= opacityStyle.getNumber();\n                    }\n                    element = element.parent;\n                }\n                return opacity;\n            }\n        },\n        {\n            key: \"setContext\",\n            value: function setContext(ctx) {\n                var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                if (!fromMeasure) {\n                    // causes stack overflow when measuring text with gradients\n                    // fill\n                    var fillStyleProp = this.getStyle(\"fill\");\n                    var fillOpacityStyleProp = this.getStyle(\"fill-opacity\");\n                    var strokeStyleProp = this.getStyle(\"stroke\");\n                    var strokeOpacityProp = this.getStyle(\"stroke-opacity\");\n                    if (fillStyleProp.isUrlDefinition()) {\n                        var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);\n                        if (fillStyle) {\n                            ctx.fillStyle = fillStyle;\n                        }\n                    } else if (fillStyleProp.hasValue()) {\n                        if (fillStyleProp.getString() === \"currentColor\") {\n                            fillStyleProp.setValue(this.getStyle(\"color\").getColor());\n                        }\n                        var _fillStyle = fillStyleProp.getColor();\n                        if (_fillStyle !== \"inherit\") {\n                            ctx.fillStyle = _fillStyle === \"none\" ? \"rgba(0,0,0,0)\" : _fillStyle;\n                        }\n                    }\n                    if (fillOpacityStyleProp.hasValue()) {\n                        var _fillStyle2 = new Property(this.document, \"fill\", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();\n                        ctx.fillStyle = _fillStyle2;\n                    } // stroke\n                    if (strokeStyleProp.isUrlDefinition()) {\n                        var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);\n                        if (strokeStyle) {\n                            ctx.strokeStyle = strokeStyle;\n                        }\n                    } else if (strokeStyleProp.hasValue()) {\n                        if (strokeStyleProp.getString() === \"currentColor\") {\n                            strokeStyleProp.setValue(this.getStyle(\"color\").getColor());\n                        }\n                        var _strokeStyle = strokeStyleProp.getString();\n                        if (_strokeStyle !== \"inherit\") {\n                            ctx.strokeStyle = _strokeStyle === \"none\" ? \"rgba(0,0,0,0)\" : _strokeStyle;\n                        }\n                    }\n                    if (strokeOpacityProp.hasValue()) {\n                        var _strokeStyle2 = new Property(this.document, \"stroke\", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();\n                        ctx.strokeStyle = _strokeStyle2;\n                    }\n                    var strokeWidthStyleProp = this.getStyle(\"stroke-width\");\n                    if (strokeWidthStyleProp.hasValue()) {\n                        var newLineWidth = strokeWidthStyleProp.getPixels();\n                        ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)\n                         : newLineWidth;\n                    }\n                    var strokeLinecapStyleProp = this.getStyle(\"stroke-linecap\");\n                    var strokeLinejoinStyleProp = this.getStyle(\"stroke-linejoin\");\n                    var strokeMiterlimitProp = this.getStyle(\"stroke-miterlimit\"); // NEED TEST\n                    // const pointOrderStyleProp = this.getStyle('paint-order');\n                    var strokeDasharrayStyleProp = this.getStyle(\"stroke-dasharray\");\n                    var strokeDashoffsetProp = this.getStyle(\"stroke-dashoffset\");\n                    if (strokeLinecapStyleProp.hasValue()) {\n                        ctx.lineCap = strokeLinecapStyleProp.getString();\n                    }\n                    if (strokeLinejoinStyleProp.hasValue()) {\n                        ctx.lineJoin = strokeLinejoinStyleProp.getString();\n                    }\n                    if (strokeMiterlimitProp.hasValue()) {\n                        ctx.miterLimit = strokeMiterlimitProp.getNumber();\n                    } // NEED TEST\n                    // if (pointOrderStyleProp.hasValue()) {\n                    // \t// ?\n                    // \tctx.paintOrder = pointOrderStyleProp.getValue();\n                    // }\n                    if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== \"none\") {\n                        var gaps = toNumbers(strokeDasharrayStyleProp.getString());\n                        if (typeof ctx.setLineDash !== \"undefined\") {\n                            ctx.setLineDash(gaps);\n                        } else if (typeof ctx.webkitLineDash !== \"undefined\") {\n                            // @ts-expect-error Handle browser prefix.\n                            ctx.webkitLineDash = gaps;\n                        } else if (typeof ctx.mozDash !== \"undefined\" && !(gaps.length === 1 && gaps[0] === 0)) {\n                            // @ts-expect-error Handle browser prefix.\n                            ctx.mozDash = gaps;\n                        }\n                        var offset = strokeDashoffsetProp.getPixels();\n                        if (typeof ctx.lineDashOffset !== \"undefined\") {\n                            ctx.lineDashOffset = offset;\n                        } else if (typeof ctx.webkitLineDashOffset !== \"undefined\") {\n                            // @ts-expect-error Handle browser prefix.\n                            ctx.webkitLineDashOffset = offset;\n                        } else if (typeof ctx.mozDashOffset !== \"undefined\") {\n                            // @ts-expect-error Handle browser prefix.\n                            ctx.mozDashOffset = offset;\n                        }\n                    }\n                } // font\n                this.modifiedEmSizeStack = false;\n                if (typeof ctx.font !== \"undefined\") {\n                    var fontStyleProp = this.getStyle(\"font\");\n                    var fontStyleStyleProp = this.getStyle(\"font-style\");\n                    var fontVariantStyleProp = this.getStyle(\"font-variant\");\n                    var fontWeightStyleProp = this.getStyle(\"font-weight\");\n                    var fontSizeStyleProp = this.getStyle(\"font-size\");\n                    var fontFamilyStyleProp = this.getStyle(\"font-family\");\n                    var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? \"\".concat(fontSizeStyleProp.getPixels(true), \"px\") : \"\", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));\n                    fontStyleStyleProp.setValue(font.fontStyle);\n                    fontVariantStyleProp.setValue(font.fontVariant);\n                    fontWeightStyleProp.setValue(font.fontWeight);\n                    fontSizeStyleProp.setValue(font.fontSize);\n                    fontFamilyStyleProp.setValue(font.fontFamily);\n                    ctx.font = font.toString();\n                    if (fontSizeStyleProp.isPixels()) {\n                        this.document.emSize = fontSizeStyleProp.getPixels();\n                        this.modifiedEmSizeStack = true;\n                    }\n                }\n                if (!fromMeasure) {\n                    // effects\n                    this.applyEffects(ctx); // opacity\n                    ctx.globalAlpha = this.calculateOpacity();\n                }\n            }\n        },\n        {\n            key: \"clearContext\",\n            value: function clearContext(ctx) {\n                _get__default[\"default\"](_getPrototypeOf__default[\"default\"](RenderedElement.prototype), \"clearContext\", this).call(this, ctx);\n                if (this.modifiedEmSizeStack) {\n                    this.document.popEmSize();\n                }\n            }\n        }\n    ]);\n    return RenderedElement;\n}(Element);\nfunction _createSuper$G(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$G();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$G() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar PathElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](PathElement, _RenderedElement);\n    var _super = _createSuper$G(PathElement);\n    function PathElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, PathElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"path\";\n        _this.pathParser = null;\n        _this.pathParser = new PathParser(_this.getAttribute(\"d\").getString());\n        return _this;\n    }\n    _createClass__default[\"default\"](PathElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var pathParser = this.pathParser;\n                var boundingBox = new BoundingBox();\n                pathParser.reset();\n                if (ctx) {\n                    ctx.beginPath();\n                }\n                while(!pathParser.isEnd()){\n                    switch(pathParser.next().type){\n                        case PathParser.MOVE_TO:\n                            this.pathM(ctx, boundingBox);\n                            break;\n                        case PathParser.LINE_TO:\n                            this.pathL(ctx, boundingBox);\n                            break;\n                        case PathParser.HORIZ_LINE_TO:\n                            this.pathH(ctx, boundingBox);\n                            break;\n                        case PathParser.VERT_LINE_TO:\n                            this.pathV(ctx, boundingBox);\n                            break;\n                        case PathParser.CURVE_TO:\n                            this.pathC(ctx, boundingBox);\n                            break;\n                        case PathParser.SMOOTH_CURVE_TO:\n                            this.pathS(ctx, boundingBox);\n                            break;\n                        case PathParser.QUAD_TO:\n                            this.pathQ(ctx, boundingBox);\n                            break;\n                        case PathParser.SMOOTH_QUAD_TO:\n                            this.pathT(ctx, boundingBox);\n                            break;\n                        case PathParser.ARC:\n                            this.pathA(ctx, boundingBox);\n                            break;\n                        case PathParser.CLOSE_PATH:\n                            this.pathZ(ctx, boundingBox);\n                            break;\n                    }\n                }\n                return boundingBox;\n            }\n        },\n        {\n            key: \"getBoundingBox\",\n            value: function getBoundingBox(_) {\n                return this.path();\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                var pathParser = this.pathParser;\n                var points = pathParser.getMarkerPoints();\n                var angles = pathParser.getMarkerAngles();\n                var markers = points.map(function(point, i) {\n                    return [\n                        point,\n                        angles[i]\n                    ];\n                });\n                return markers;\n            }\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                this.path(ctx);\n                this.document.screen.mouse.checkPath(this, ctx);\n                var fillRuleStyleProp = this.getStyle(\"fill-rule\");\n                if (ctx.fillStyle !== \"\") {\n                    if (fillRuleStyleProp.getString(\"inherit\") !== \"inherit\") {\n                        ctx.fill(fillRuleStyleProp.getString());\n                    } else {\n                        ctx.fill();\n                    }\n                }\n                if (ctx.strokeStyle !== \"\") {\n                    if (this.getAttribute(\"vector-effect\").getString() === \"non-scaling-stroke\") {\n                        ctx.save();\n                        ctx.setTransform(1, 0, 0, 1, 0, 0);\n                        ctx.stroke();\n                        ctx.restore();\n                    } else {\n                        ctx.stroke();\n                    }\n                }\n                var markers = this.getMarkers();\n                if (markers) {\n                    var markersLastIndex = markers.length - 1;\n                    var markerStartStyleProp = this.getStyle(\"marker-start\");\n                    var markerMidStyleProp = this.getStyle(\"marker-mid\");\n                    var markerEndStyleProp = this.getStyle(\"marker-end\");\n                    if (markerStartStyleProp.isUrlDefinition()) {\n                        var marker = markerStartStyleProp.getDefinition();\n                        var _markers$ = _slicedToArray__default[\"default\"](markers[0], 2), point = _markers$[0], angle = _markers$[1];\n                        marker.render(ctx, point, angle);\n                    }\n                    if (markerMidStyleProp.isUrlDefinition()) {\n                        var _marker = markerMidStyleProp.getDefinition();\n                        for(var i = 1; i < markersLastIndex; i++){\n                            var _markers$i = _slicedToArray__default[\"default\"](markers[i], 2), _point = _markers$i[0], _angle = _markers$i[1];\n                            _marker.render(ctx, _point, _angle);\n                        }\n                    }\n                    if (markerEndStyleProp.isUrlDefinition()) {\n                        var _marker2 = markerEndStyleProp.getDefinition();\n                        var _markers$markersLastI = _slicedToArray__default[\"default\"](markers[markersLastIndex], 2), _point2 = _markers$markersLastI[0], _angle2 = _markers$markersLastI[1];\n                        _marker2.render(ctx, _point2, _angle2);\n                    }\n                }\n            }\n        },\n        {\n            key: \"pathM\",\n            value: function pathM(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathM = PathElement.pathM(pathParser), point = _PathElement$pathM.point;\n                var x = point.x, y = point.y;\n                pathParser.addMarker(point);\n                boundingBox.addPoint(x, y);\n                if (ctx) {\n                    ctx.moveTo(x, y);\n                }\n            }\n        },\n        {\n            key: \"pathL\",\n            value: function pathL(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathL = PathElement.pathL(pathParser), current = _PathElement$pathL.current, point = _PathElement$pathL.point;\n                var x = point.x, y = point.y;\n                pathParser.addMarker(point, current);\n                boundingBox.addPoint(x, y);\n                if (ctx) {\n                    ctx.lineTo(x, y);\n                }\n            }\n        },\n        {\n            key: \"pathH\",\n            value: function pathH(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathH = PathElement.pathH(pathParser), current = _PathElement$pathH.current, point = _PathElement$pathH.point;\n                var x = point.x, y = point.y;\n                pathParser.addMarker(point, current);\n                boundingBox.addPoint(x, y);\n                if (ctx) {\n                    ctx.lineTo(x, y);\n                }\n            }\n        },\n        {\n            key: \"pathV\",\n            value: function pathV(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathV = PathElement.pathV(pathParser), current = _PathElement$pathV.current, point = _PathElement$pathV.point;\n                var x = point.x, y = point.y;\n                pathParser.addMarker(point, current);\n                boundingBox.addPoint(x, y);\n                if (ctx) {\n                    ctx.lineTo(x, y);\n                }\n            }\n        },\n        {\n            key: \"pathC\",\n            value: function pathC(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathC = PathElement.pathC(pathParser), current = _PathElement$pathC.current, point = _PathElement$pathC.point, controlPoint = _PathElement$pathC.controlPoint, currentPoint = _PathElement$pathC.currentPoint;\n                pathParser.addMarker(currentPoint, controlPoint, point);\n                boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                if (ctx) {\n                    ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                }\n            }\n        },\n        {\n            key: \"pathS\",\n            value: function pathS(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathS = PathElement.pathS(pathParser), current = _PathElement$pathS.current, point = _PathElement$pathS.point, controlPoint = _PathElement$pathS.controlPoint, currentPoint = _PathElement$pathS.currentPoint;\n                pathParser.addMarker(currentPoint, controlPoint, point);\n                boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                if (ctx) {\n                    ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                }\n            }\n        },\n        {\n            key: \"pathQ\",\n            value: function pathQ(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathQ = PathElement.pathQ(pathParser), current = _PathElement$pathQ.current, controlPoint = _PathElement$pathQ.controlPoint, currentPoint = _PathElement$pathQ.currentPoint;\n                pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n                boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                if (ctx) {\n                    ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                }\n            }\n        },\n        {\n            key: \"pathT\",\n            value: function pathT(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathT = PathElement.pathT(pathParser), current = _PathElement$pathT.current, controlPoint = _PathElement$pathT.controlPoint, currentPoint = _PathElement$pathT.currentPoint;\n                pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n                boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                if (ctx) {\n                    ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                }\n            }\n        },\n        {\n            key: \"pathA\",\n            value: function pathA(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathA = PathElement.pathA(pathParser), currentPoint = _PathElement$pathA.currentPoint, rX = _PathElement$pathA.rX, rY = _PathElement$pathA.rY, sweepFlag = _PathElement$pathA.sweepFlag, xAxisRotation = _PathElement$pathA.xAxisRotation, centp = _PathElement$pathA.centp, a1 = _PathElement$pathA.a1, ad = _PathElement$pathA.ad; // for markers\n                var dir = 1 - sweepFlag ? 1.0 : -1.0;\n                var ah = a1 + dir * (ad / 2.0);\n                var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));\n                pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n                pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);\n                boundingBox.addPoint(currentPoint.x, currentPoint.y); // TODO: this is too naive, make it better\n                if (ctx && !isNaN(a1) && !isNaN(ad)) {\n                    var r = rX > rY ? rX : rY;\n                    var sx = rX > rY ? 1 : rX / rY;\n                    var sy = rX > rY ? rY / rX : 1;\n                    ctx.translate(centp.x, centp.y);\n                    ctx.rotate(xAxisRotation);\n                    ctx.scale(sx, sy);\n                    ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));\n                    ctx.scale(1 / sx, 1 / sy);\n                    ctx.rotate(-xAxisRotation);\n                    ctx.translate(-centp.x, -centp.y);\n                }\n            }\n        },\n        {\n            key: \"pathZ\",\n            value: function pathZ(ctx, boundingBox) {\n                PathElement.pathZ(this.pathParser);\n                if (ctx) {\n                    // only close path if it is not a straight line\n                    if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {\n                        ctx.closePath();\n                    }\n                }\n            }\n        }\n    ], [\n        {\n            key: \"pathM\",\n            value: function pathM(pathParser) {\n                var point = pathParser.getAsCurrentPoint();\n                pathParser.start = pathParser.current;\n                return {\n                    point: point\n                };\n            }\n        },\n        {\n            key: \"pathL\",\n            value: function pathL(pathParser) {\n                var current = pathParser.current;\n                var point = pathParser.getAsCurrentPoint();\n                return {\n                    current: current,\n                    point: point\n                };\n            }\n        },\n        {\n            key: \"pathH\",\n            value: function pathH(pathParser) {\n                var current = pathParser.current, command = pathParser.command;\n                var point = new Point((command.relative ? current.x : 0) + command.x, current.y);\n                pathParser.current = point;\n                return {\n                    current: current,\n                    point: point\n                };\n            }\n        },\n        {\n            key: \"pathV\",\n            value: function pathV(pathParser) {\n                var current = pathParser.current, command = pathParser.command;\n                var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);\n                pathParser.current = point;\n                return {\n                    current: current,\n                    point: point\n                };\n            }\n        },\n        {\n            key: \"pathC\",\n            value: function pathC(pathParser) {\n                var current = pathParser.current;\n                var point = pathParser.getPoint(\"x1\", \"y1\");\n                var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n                var currentPoint = pathParser.getAsCurrentPoint();\n                return {\n                    current: current,\n                    point: point,\n                    controlPoint: controlPoint,\n                    currentPoint: currentPoint\n                };\n            }\n        },\n        {\n            key: \"pathS\",\n            value: function pathS(pathParser) {\n                var current = pathParser.current;\n                var point = pathParser.getReflectedControlPoint();\n                var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n                var currentPoint = pathParser.getAsCurrentPoint();\n                return {\n                    current: current,\n                    point: point,\n                    controlPoint: controlPoint,\n                    currentPoint: currentPoint\n                };\n            }\n        },\n        {\n            key: \"pathQ\",\n            value: function pathQ(pathParser) {\n                var current = pathParser.current;\n                var controlPoint = pathParser.getAsControlPoint(\"x1\", \"y1\");\n                var currentPoint = pathParser.getAsCurrentPoint();\n                return {\n                    current: current,\n                    controlPoint: controlPoint,\n                    currentPoint: currentPoint\n                };\n            }\n        },\n        {\n            key: \"pathT\",\n            value: function pathT(pathParser) {\n                var current = pathParser.current;\n                var controlPoint = pathParser.getReflectedControlPoint();\n                pathParser.control = controlPoint;\n                var currentPoint = pathParser.getAsCurrentPoint();\n                return {\n                    current: current,\n                    controlPoint: controlPoint,\n                    currentPoint: currentPoint\n                };\n            }\n        },\n        {\n            key: \"pathA\",\n            value: function pathA(pathParser) {\n                var current = pathParser.current, command = pathParser.command;\n                var rX = command.rX, rY = command.rY, xRot = command.xRot, lArcFlag = command.lArcFlag, sweepFlag = command.sweepFlag;\n                var xAxisRotation = xRot * (Math.PI / 180.0);\n                var currentPoint = pathParser.getAsCurrentPoint(); // Conversion from endpoint to center parameterization\n                // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n                // x1', y1'\n                var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2.0, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2.0); // adjust radii\n                var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);\n                if (l > 1) {\n                    rX *= Math.sqrt(l);\n                    rY *= Math.sqrt(l);\n                } // cx', cy'\n                var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));\n                if (isNaN(s)) {\n                    s = 0;\n                }\n                var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX); // cx, cy\n                var centp = new Point((current.x + currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y); // initial angle\n                var a1 = vectorsAngle([\n                    1,\n                    0\n                ], [\n                    (currp.x - cpp.x) / rX,\n                    (currp.y - cpp.y) / rY\n                ]); // 1\n                // angle delta\n                var u = [\n                    (currp.x - cpp.x) / rX,\n                    (currp.y - cpp.y) / rY\n                ];\n                var v = [\n                    (-currp.x - cpp.x) / rX,\n                    (-currp.y - cpp.y) / rY\n                ];\n                var ad = vectorsAngle(u, v); // \n                if (vectorsRatio(u, v) <= -1) {\n                    ad = Math.PI;\n                }\n                if (vectorsRatio(u, v) >= 1) {\n                    ad = 0;\n                }\n                return {\n                    currentPoint: currentPoint,\n                    rX: rX,\n                    rY: rY,\n                    sweepFlag: sweepFlag,\n                    xAxisRotation: xAxisRotation,\n                    centp: centp,\n                    a1: a1,\n                    ad: ad\n                };\n            }\n        },\n        {\n            key: \"pathZ\",\n            value: function pathZ(pathParser) {\n                pathParser.current = pathParser.start;\n            }\n        }\n    ]);\n    return PathElement;\n}(RenderedElement);\nfunction _createSuper$F(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$F();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$F() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar GlyphElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](GlyphElement, _PathElement);\n    var _super = _createSuper$F(GlyphElement);\n    function GlyphElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, GlyphElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"glyph\";\n        _this.horizAdvX = _this.getAttribute(\"horiz-adv-x\").getNumber();\n        _this.unicode = _this.getAttribute(\"unicode\").getString();\n        _this.arabicForm = _this.getAttribute(\"arabic-form\").getString();\n        return _this;\n    }\n    return GlyphElement;\n}(PathElement);\nfunction _createSuper$E(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$E();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$E() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TextElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](TextElement, _RenderedElement);\n    var _super = _createSuper$E(TextElement);\n    function TextElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TextElement);\n        _this = _super.call(this, document1, node, (this instanceof TextElement ? this.constructor : void 0) === TextElement ? true : captureTextNodes);\n        _this.type = \"text\";\n        _this.x = 0;\n        _this.y = 0;\n        _this.measureCache = -1;\n        return _this;\n    }\n    _createClass__default[\"default\"](TextElement, [\n        {\n            key: \"setContext\",\n            value: function setContext(ctx) {\n                var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                _get__default[\"default\"](_getPrototypeOf__default[\"default\"](TextElement.prototype), \"setContext\", this).call(this, ctx, fromMeasure);\n                var textBaseline = this.getStyle(\"dominant-baseline\").getTextBaseline() || this.getStyle(\"alignment-baseline\").getTextBaseline();\n                if (textBaseline) {\n                    ctx.textBaseline = textBaseline;\n                }\n            }\n        },\n        {\n            key: \"initializeCoordinates\",\n            value: function initializeCoordinates() {\n                this.x = 0;\n                this.y = 0;\n                this.leafTexts = [];\n                this.textChunkStart = 0;\n                this.minX = Number.POSITIVE_INFINITY;\n                this.maxX = Number.NEGATIVE_INFINITY;\n            }\n        },\n        {\n            key: \"getBoundingBox\",\n            value: function getBoundingBox(ctx) {\n                var _this2 = this;\n                if (this.type !== \"text\") {\n                    return this.getTElementBoundingBox(ctx);\n                } // first, calculate child positions\n                this.initializeCoordinates();\n                this.adjustChildCoordinatesRecursive(ctx);\n                var boundingBox = null; // then calculate bounding box\n                this.children.forEach(function(_, i) {\n                    var childBoundingBox = _this2.getChildBoundingBox(ctx, _this2, _this2, i);\n                    if (!boundingBox) {\n                        boundingBox = childBoundingBox;\n                    } else {\n                        boundingBox.addBoundingBox(childBoundingBox);\n                    }\n                });\n                return boundingBox;\n            }\n        },\n        {\n            key: \"getFontSize\",\n            value: function getFontSize() {\n                var document1 = this.document, parent = this.parent;\n                var inheritFontSize = Font.parse(document1.ctx.font).fontSize;\n                var fontSize = parent.getStyle(\"font-size\").getNumber(inheritFontSize);\n                return fontSize;\n            }\n        },\n        {\n            key: \"getTElementBoundingBox\",\n            value: function getTElementBoundingBox(ctx) {\n                var fontSize = this.getFontSize();\n                return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);\n            }\n        },\n        {\n            key: \"getGlyph\",\n            value: function getGlyph(font, text, i) {\n                var char = text[i];\n                var glyph = null;\n                if (font.isArabic) {\n                    var len = text.length;\n                    var prevChar = text[i - 1];\n                    var nextChar = text[i + 1];\n                    var arabicForm = \"isolated\";\n                    if ((i === 0 || prevChar === \" \") && i < len - 1 && nextChar !== \" \") {\n                        arabicForm = \"terminal\";\n                    }\n                    if (i > 0 && prevChar !== \" \" && i < len - 1 && nextChar !== \" \") {\n                        arabicForm = \"medial\";\n                    }\n                    if (i > 0 && prevChar !== \" \" && (i === len - 1 || nextChar === \" \")) {\n                        arabicForm = \"initial\";\n                    }\n                    if (typeof font.glyphs[char] !== \"undefined\") {\n                        // NEED TEST\n                        var maybeGlyph = font.glyphs[char];\n                        glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];\n                    }\n                } else {\n                    glyph = font.glyphs[char];\n                }\n                if (!glyph) {\n                    glyph = font.missingGlyph;\n                }\n                return glyph;\n            }\n        },\n        {\n            key: \"getText\",\n            value: function getText() {\n                return \"\";\n            }\n        },\n        {\n            key: \"getTextFromNode\",\n            value: function getTextFromNode(node) {\n                var textNode = node || this.node;\n                var childNodes = Array.from(textNode.parentNode.childNodes);\n                var index = childNodes.indexOf(textNode);\n                var lastIndex = childNodes.length - 1;\n                var text = compressSpaces(// || textNode.text\n                textNode.textContent || \"\");\n                if (index === 0) {\n                    text = trimLeft(text);\n                }\n                if (index === lastIndex) {\n                    text = trimRight(text);\n                }\n                return text;\n            }\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                var _this3 = this;\n                if (this.type !== \"text\") {\n                    this.renderTElementChildren(ctx);\n                    return;\n                } // first, calculate child positions\n                this.initializeCoordinates();\n                this.adjustChildCoordinatesRecursive(ctx); // then render\n                this.children.forEach(function(_, i) {\n                    _this3.renderChild(ctx, _this3, _this3, i);\n                });\n                var mouse = this.document.screen.mouse; // Do not calc bounding box if mouse is not working.\n                if (mouse.isWorking()) {\n                    mouse.checkBoundingBox(this, this.getBoundingBox(ctx));\n                }\n            }\n        },\n        {\n            key: \"renderTElementChildren\",\n            value: function renderTElementChildren(ctx) {\n                var document1 = this.document, parent = this.parent;\n                var renderText = this.getText();\n                var customFont = parent.getStyle(\"font-family\").getDefinition();\n                if (customFont) {\n                    var unitsPerEm = customFont.fontFace.unitsPerEm;\n                    var ctxFont = Font.parse(document1.ctx.font);\n                    var fontSize = parent.getStyle(\"font-size\").getNumber(ctxFont.fontSize);\n                    var fontStyle = parent.getStyle(\"font-style\").getString(ctxFont.fontStyle);\n                    var scale = fontSize / unitsPerEm;\n                    var text = customFont.isRTL ? renderText.split(\"\").reverse().join(\"\") : renderText;\n                    var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n                    var len = text.length;\n                    for(var i = 0; i < len; i++){\n                        var glyph = this.getGlyph(customFont, text, i);\n                        ctx.translate(this.x, this.y);\n                        ctx.scale(scale, -scale);\n                        var lw = ctx.lineWidth;\n                        ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;\n                        if (fontStyle === \"italic\") {\n                            ctx.transform(1, 0, .4, 1, 0, 0);\n                        }\n                        glyph.render(ctx);\n                        if (fontStyle === \"italic\") {\n                            ctx.transform(1, 0, -.4, 1, 0, 0);\n                        }\n                        ctx.lineWidth = lw;\n                        ctx.scale(1 / scale, -1 / scale);\n                        ctx.translate(-this.x, -this.y);\n                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;\n                        if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                            this.x += dx[i];\n                        }\n                    }\n                    return;\n                }\n                var x = this.x, y = this.y; // NEED TEST\n                // if (ctx.paintOrder === 'stroke') {\n                // \tif (ctx.strokeStyle) {\n                // \t\tctx.strokeText(renderText, x, y);\n                // \t}\n                // \tif (ctx.fillStyle) {\n                // \t\tctx.fillText(renderText, x, y);\n                // \t}\n                // } else {\n                if (ctx.fillStyle) {\n                    ctx.fillText(renderText, x, y);\n                }\n                if (ctx.strokeStyle) {\n                    ctx.strokeText(renderText, x, y);\n                } // }\n            }\n        },\n        {\n            key: \"applyAnchoring\",\n            value: function applyAnchoring() {\n                if (this.textChunkStart >= this.leafTexts.length) {\n                    return;\n                } // This is basically the \"Apply anchoring\" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.\n                // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.\n                // Vertical text is not supported.\n                var firstElement = this.leafTexts[this.textChunkStart];\n                var textAnchor = firstElement.getStyle(\"text-anchor\").getString(\"start\");\n                var isRTL = false; // we treat RTL like LTR\n                var shift = 0;\n                if (textAnchor === \"start\" && !isRTL || textAnchor === \"end\" && isRTL) {\n                    shift = firstElement.x - this.minX;\n                } else if (textAnchor === \"end\" && !isRTL || textAnchor === \"start\" && isRTL) {\n                    shift = firstElement.x - this.maxX;\n                } else {\n                    shift = firstElement.x - (this.minX + this.maxX) / 2;\n                }\n                for(var i = this.textChunkStart; i < this.leafTexts.length; i++){\n                    this.leafTexts[i].x += shift;\n                } // start new chunk\n                this.minX = Number.POSITIVE_INFINITY;\n                this.maxX = Number.NEGATIVE_INFINITY;\n                this.textChunkStart = this.leafTexts.length;\n            }\n        },\n        {\n            key: \"adjustChildCoordinatesRecursive\",\n            value: function adjustChildCoordinatesRecursive(ctx) {\n                var _this4 = this;\n                this.children.forEach(function(_, i) {\n                    _this4.adjustChildCoordinatesRecursiveCore(ctx, _this4, _this4, i);\n                });\n                this.applyAnchoring();\n            }\n        },\n        {\n            key: \"adjustChildCoordinatesRecursiveCore\",\n            value: function adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {\n                var child = parent.children[i];\n                if (child.children.length > 0) {\n                    child.children.forEach(function(_, i) {\n                        textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);\n                    });\n                } else {\n                    // only leafs are relevant\n                    this.adjustChildCoordinates(ctx, textParent, parent, i);\n                }\n            }\n        },\n        {\n            key: \"adjustChildCoordinates\",\n            value: function adjustChildCoordinates(ctx, textParent, parent, i) {\n                var child = parent.children[i];\n                if (typeof child.measureText !== \"function\") {\n                    return child;\n                }\n                ctx.save();\n                child.setContext(ctx, true);\n                var xAttr = child.getAttribute(\"x\");\n                var yAttr = child.getAttribute(\"y\");\n                var dxAttr = child.getAttribute(\"dx\");\n                var dyAttr = child.getAttribute(\"dy\");\n                var customFont = child.getStyle(\"font-family\").getDefinition();\n                var isRTL = Boolean(customFont) && customFont.isRTL;\n                if (i === 0) {\n                    // First children inherit attributes from parent(s). Positional attributes\n                    // are only inherited from a parent to it's first child.\n                    if (!xAttr.hasValue()) {\n                        xAttr.setValue(child.getInheritedAttribute(\"x\"));\n                    }\n                    if (!yAttr.hasValue()) {\n                        yAttr.setValue(child.getInheritedAttribute(\"y\"));\n                    }\n                    if (!dxAttr.hasValue()) {\n                        dxAttr.setValue(child.getInheritedAttribute(\"dx\"));\n                    }\n                    if (!dyAttr.hasValue()) {\n                        dyAttr.setValue(child.getInheritedAttribute(\"dy\"));\n                    }\n                }\n                var width = child.measureText(ctx);\n                if (isRTL) {\n                    textParent.x -= width;\n                }\n                if (xAttr.hasValue()) {\n                    // an \"x\" attribute marks the start of a new chunk\n                    textParent.applyAnchoring();\n                    child.x = xAttr.getPixels(\"x\");\n                    if (dxAttr.hasValue()) {\n                        child.x += dxAttr.getPixels(\"x\");\n                    }\n                } else {\n                    if (dxAttr.hasValue()) {\n                        textParent.x += dxAttr.getPixels(\"x\");\n                    }\n                    child.x = textParent.x;\n                }\n                textParent.x = child.x;\n                if (!isRTL) {\n                    textParent.x += width;\n                }\n                if (yAttr.hasValue()) {\n                    child.y = yAttr.getPixels(\"y\");\n                    if (dyAttr.hasValue()) {\n                        child.y += dyAttr.getPixels(\"y\");\n                    }\n                } else {\n                    if (dyAttr.hasValue()) {\n                        textParent.y += dyAttr.getPixels(\"y\");\n                    }\n                    child.y = textParent.y;\n                }\n                textParent.y = child.y; // update the current chunk and it's bounds\n                textParent.leafTexts.push(child);\n                textParent.minX = Math.min(textParent.minX, child.x, child.x + width);\n                textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);\n                child.clearContext(ctx);\n                ctx.restore();\n                return child;\n            }\n        },\n        {\n            key: \"getChildBoundingBox\",\n            value: function getChildBoundingBox(ctx, textParent, parent, i) {\n                var child = parent.children[i]; // not a text node?\n                if (typeof child.getBoundingBox !== \"function\") {\n                    return null;\n                }\n                var boundingBox = child.getBoundingBox(ctx);\n                if (!boundingBox) {\n                    return null;\n                }\n                child.children.forEach(function(_, i) {\n                    var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);\n                    boundingBox.addBoundingBox(childBoundingBox);\n                });\n                return boundingBox;\n            }\n        },\n        {\n            key: \"renderChild\",\n            value: function renderChild(ctx, textParent, parent, i) {\n                var child = parent.children[i];\n                child.render(ctx);\n                child.children.forEach(function(_, i) {\n                    textParent.renderChild(ctx, textParent, child, i);\n                });\n            }\n        },\n        {\n            key: \"measureText\",\n            value: function measureText(ctx) {\n                var measureCache = this.measureCache;\n                if (~measureCache) {\n                    return measureCache;\n                }\n                var renderText = this.getText();\n                var measure = this.measureTargetText(ctx, renderText);\n                this.measureCache = measure;\n                return measure;\n            }\n        },\n        {\n            key: \"measureTargetText\",\n            value: function measureTargetText(ctx, targetText) {\n                if (!targetText.length) {\n                    return 0;\n                }\n                var parent = this.parent;\n                var customFont = parent.getStyle(\"font-family\").getDefinition();\n                if (customFont) {\n                    var fontSize = this.getFontSize();\n                    var text = customFont.isRTL ? targetText.split(\"\").reverse().join(\"\") : targetText;\n                    var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n                    var len = text.length;\n                    var _measure = 0;\n                    for(var i = 0; i < len; i++){\n                        var glyph = this.getGlyph(customFont, text, i);\n                        _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n                        if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                            _measure += dx[i];\n                        }\n                    }\n                    return _measure;\n                }\n                if (!ctx.measureText) {\n                    return targetText.length * 10;\n                }\n                ctx.save();\n                this.setContext(ctx, true);\n                var _ctx$measureText = ctx.measureText(targetText), measure = _ctx$measureText.width;\n                this.clearContext(ctx);\n                ctx.restore();\n                return measure;\n            }\n        },\n        {\n            key: \"getInheritedAttribute\",\n            value: function getInheritedAttribute(name) {\n                // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n                var current = this;\n                while(current instanceof TextElement && current.isFirstChild()){\n                    var parentAttr = current.parent.getAttribute(name);\n                    if (parentAttr.hasValue(true)) {\n                        return parentAttr.getValue(\"0\");\n                    }\n                    current = current.parent;\n                }\n                return null;\n            }\n        }\n    ]);\n    return TextElement;\n}(RenderedElement);\nfunction _createSuper$D(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$D();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$D() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TSpanElement = /*#__PURE__*/ function(_TextElement) {\n    _inherits__default[\"default\"](TSpanElement, _TextElement);\n    var _super = _createSuper$D(TSpanElement);\n    function TSpanElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TSpanElement);\n        _this = _super.call(this, document1, node, (this instanceof TSpanElement ? this.constructor : void 0) === TSpanElement ? true : captureTextNodes);\n        _this.type = \"tspan\"; // if this node has children, then they own the text\n        _this.text = _this.children.length > 0 ? \"\" : _this.getTextFromNode();\n        return _this;\n    }\n    _createClass__default[\"default\"](TSpanElement, [\n        {\n            key: \"getText\",\n            value: function getText() {\n                return this.text;\n            }\n        }\n    ]);\n    return TSpanElement;\n}(TextElement);\nfunction _createSuper$C(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$C();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$C() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TextNode = /*#__PURE__*/ function(_TSpanElement) {\n    _inherits__default[\"default\"](TextNode, _TSpanElement);\n    var _super = _createSuper$C(TextNode);\n    function TextNode() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TextNode);\n        _this = _super.apply(this, arguments);\n        _this.type = \"textNode\";\n        return _this;\n    }\n    return TextNode;\n}(TSpanElement);\nfunction _createSuper$B(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$B();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$B() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar SVGElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](SVGElement, _RenderedElement);\n    var _super = _createSuper$B(SVGElement);\n    function SVGElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, SVGElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"svg\";\n        _this.root = false;\n        return _this;\n    }\n    _createClass__default[\"default\"](SVGElement, [\n        {\n            key: \"setContext\",\n            value: function setContext(ctx) {\n                var _this$node$parentNode;\n                var document1 = this.document;\n                var screen = document1.screen, window1 = document1.window;\n                var canvas = ctx.canvas;\n                screen.setDefaults(ctx);\n                if (canvas.style && typeof ctx.font !== \"undefined\" && window1 && typeof window1.getComputedStyle !== \"undefined\") {\n                    ctx.font = window1.getComputedStyle(canvas).getPropertyValue(\"font\");\n                    var fontSizeProp = new Property(document1, \"fontSize\", Font.parse(ctx.font).fontSize);\n                    if (fontSizeProp.hasValue()) {\n                        document1.rootEmSize = fontSizeProp.getPixels(\"y\");\n                        document1.emSize = document1.rootEmSize;\n                    }\n                } // create new view port\n                if (!this.getAttribute(\"x\").hasValue()) {\n                    this.getAttribute(\"x\", true).setValue(0);\n                }\n                if (!this.getAttribute(\"y\").hasValue()) {\n                    this.getAttribute(\"y\", true).setValue(0);\n                }\n                var _screen$viewPort = screen.viewPort, width = _screen$viewPort.width, height = _screen$viewPort.height;\n                if (!this.getStyle(\"width\").hasValue()) {\n                    this.getStyle(\"width\", true).setValue(\"100%\");\n                }\n                if (!this.getStyle(\"height\").hasValue()) {\n                    this.getStyle(\"height\", true).setValue(\"100%\");\n                }\n                if (!this.getStyle(\"color\").hasValue()) {\n                    this.getStyle(\"color\", true).setValue(\"black\");\n                }\n                var refXAttr = this.getAttribute(\"refX\");\n                var refYAttr = this.getAttribute(\"refY\");\n                var viewBoxAttr = this.getAttribute(\"viewBox\");\n                var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;\n                var clip = !this.root && this.getStyle(\"overflow\").getValue(\"hidden\") !== \"visible\";\n                var minX = 0;\n                var minY = 0;\n                var clipX = 0;\n                var clipY = 0;\n                if (viewBox) {\n                    minX = viewBox[0];\n                    minY = viewBox[1];\n                }\n                if (!this.root) {\n                    width = this.getStyle(\"width\").getPixels(\"x\");\n                    height = this.getStyle(\"height\").getPixels(\"y\");\n                    if (this.type === \"marker\") {\n                        clipX = minX;\n                        clipY = minY;\n                        minX = 0;\n                        minY = 0;\n                    }\n                }\n                screen.viewPort.setCurrent(width, height); // Default value of transform-origin is center only for root SVG elements\n                // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin\n                if (this.node // is not temporary SVGElement\n                 && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === \"foreignObject\") && this.getStyle(\"transform\", false, true).hasValue() && !this.getStyle(\"transform-origin\", false, true).hasValue()) {\n                    this.getStyle(\"transform-origin\", true, true).setValue(\"50% 50%\");\n                }\n                _get__default[\"default\"](_getPrototypeOf__default[\"default\"](SVGElement.prototype), \"setContext\", this).call(this, ctx);\n                ctx.translate(this.getAttribute(\"x\").getPixels(\"x\"), this.getAttribute(\"y\").getPixels(\"y\"));\n                if (viewBox) {\n                    width = viewBox[2];\n                    height = viewBox[3];\n                }\n                document1.setViewBox({\n                    ctx: ctx,\n                    aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n                    width: screen.viewPort.width,\n                    desiredWidth: width,\n                    height: screen.viewPort.height,\n                    desiredHeight: height,\n                    minX: minX,\n                    minY: minY,\n                    refX: refXAttr.getValue(),\n                    refY: refYAttr.getValue(),\n                    clip: clip,\n                    clipX: clipX,\n                    clipY: clipY\n                });\n                if (viewBox) {\n                    screen.viewPort.removeCurrent();\n                    screen.viewPort.setCurrent(width, height);\n                }\n            }\n        },\n        {\n            key: \"clearContext\",\n            value: function clearContext(ctx) {\n                _get__default[\"default\"](_getPrototypeOf__default[\"default\"](SVGElement.prototype), \"clearContext\", this).call(this, ctx);\n                this.document.screen.viewPort.removeCurrent();\n            }\n        },\n        {\n            key: \"resize\",\n            value: function resize(width) {\n                var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n                var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                var widthAttr = this.getAttribute(\"width\", true);\n                var heightAttr = this.getAttribute(\"height\", true);\n                var viewBoxAttr = this.getAttribute(\"viewBox\");\n                var styleAttr = this.getAttribute(\"style\");\n                var originWidth = widthAttr.getNumber(0);\n                var originHeight = heightAttr.getNumber(0);\n                if (preserveAspectRatio) {\n                    if (typeof preserveAspectRatio === \"string\") {\n                        this.getAttribute(\"preserveAspectRatio\", true).setValue(preserveAspectRatio);\n                    } else {\n                        var preserveAspectRatioAttr = this.getAttribute(\"preserveAspectRatio\");\n                        if (preserveAspectRatioAttr.hasValue()) {\n                            preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, \"$1\"));\n                        }\n                    }\n                }\n                widthAttr.setValue(width);\n                heightAttr.setValue(height);\n                if (!viewBoxAttr.hasValue()) {\n                    viewBoxAttr.setValue(\"0 0 \".concat(originWidth || width, \" \").concat(originHeight || height));\n                }\n                if (styleAttr.hasValue()) {\n                    var widthStyle = this.getStyle(\"width\");\n                    var heightStyle = this.getStyle(\"height\");\n                    if (widthStyle.hasValue()) {\n                        widthStyle.setValue(\"\".concat(width, \"px\"));\n                    }\n                    if (heightStyle.hasValue()) {\n                        heightStyle.setValue(\"\".concat(height, \"px\"));\n                    }\n                }\n            }\n        }\n    ]);\n    return SVGElement;\n}(RenderedElement);\nfunction _createSuper$A(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$A();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$A() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar RectElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](RectElement, _PathElement);\n    var _super = _createSuper$A(RectElement);\n    function RectElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, RectElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"rect\";\n        return _this;\n    }\n    _createClass__default[\"default\"](RectElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var x = this.getAttribute(\"x\").getPixels(\"x\");\n                var y = this.getAttribute(\"y\").getPixels(\"y\");\n                var width = this.getStyle(\"width\", false, true).getPixels(\"x\");\n                var height = this.getStyle(\"height\", false, true).getPixels(\"y\");\n                var rxAttr = this.getAttribute(\"rx\");\n                var ryAttr = this.getAttribute(\"ry\");\n                var rx = rxAttr.getPixels(\"x\");\n                var ry = ryAttr.getPixels(\"y\");\n                if (rxAttr.hasValue() && !ryAttr.hasValue()) {\n                    ry = rx;\n                }\n                if (ryAttr.hasValue() && !rxAttr.hasValue()) {\n                    rx = ry;\n                }\n                rx = Math.min(rx, width / 2.0);\n                ry = Math.min(ry, height / 2.0);\n                if (ctx) {\n                    var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n                    ctx.beginPath(); // always start the path so we don't fill prior paths\n                    if (height > 0 && width > 0) {\n                        ctx.moveTo(x + rx, y);\n                        ctx.lineTo(x + width - rx, y);\n                        ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);\n                        ctx.lineTo(x + width, y + height - ry);\n                        ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);\n                        ctx.lineTo(x + rx, y + height);\n                        ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);\n                        ctx.lineTo(x, y + ry);\n                        ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);\n                        ctx.closePath();\n                    }\n                }\n                return new BoundingBox(x, y, x + width, y + height);\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                return null;\n            }\n        }\n    ]);\n    return RectElement;\n}(PathElement);\nfunction _createSuper$z(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$z();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$z() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar CircleElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](CircleElement, _PathElement);\n    var _super = _createSuper$z(CircleElement);\n    function CircleElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, CircleElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"circle\";\n        return _this;\n    }\n    _createClass__default[\"default\"](CircleElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n                var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n                var r = this.getAttribute(\"r\").getPixels();\n                if (ctx && r > 0) {\n                    ctx.beginPath();\n                    ctx.arc(cx, cy, r, 0, Math.PI * 2, false);\n                    ctx.closePath();\n                }\n                return new BoundingBox(cx - r, cy - r, cx + r, cy + r);\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                return null;\n            }\n        }\n    ]);\n    return CircleElement;\n}(PathElement);\nfunction _createSuper$y(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$y();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$y() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar EllipseElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](EllipseElement, _PathElement);\n    var _super = _createSuper$y(EllipseElement);\n    function EllipseElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, EllipseElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"ellipse\";\n        return _this;\n    }\n    _createClass__default[\"default\"](EllipseElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n                var rx = this.getAttribute(\"rx\").getPixels(\"x\");\n                var ry = this.getAttribute(\"ry\").getPixels(\"y\");\n                var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n                var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n                if (ctx && rx > 0 && ry > 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(cx + rx, cy);\n                    ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n                    ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n                    ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n                    ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n                    ctx.closePath();\n                }\n                return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                return null;\n            }\n        }\n    ]);\n    return EllipseElement;\n}(PathElement);\nfunction _createSuper$x(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$x();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$x() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar LineElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](LineElement, _PathElement);\n    var _super = _createSuper$x(LineElement);\n    function LineElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, LineElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"line\";\n        return _this;\n    }\n    _createClass__default[\"default\"](LineElement, [\n        {\n            key: \"getPoints\",\n            value: function getPoints() {\n                return [\n                    new Point(this.getAttribute(\"x1\").getPixels(\"x\"), this.getAttribute(\"y1\").getPixels(\"y\")),\n                    new Point(this.getAttribute(\"x2\").getPixels(\"x\"), this.getAttribute(\"y2\").getPixels(\"y\"))\n                ];\n            }\n        },\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var _this$getPoints = this.getPoints(), _this$getPoints2 = _slicedToArray__default[\"default\"](_this$getPoints, 2), _this$getPoints2$ = _this$getPoints2[0], x0 = _this$getPoints2$.x, y0 = _this$getPoints2$.y, _this$getPoints2$2 = _this$getPoints2[1], x1 = _this$getPoints2$2.x, y1 = _this$getPoints2$2.y;\n                if (ctx) {\n                    ctx.beginPath();\n                    ctx.moveTo(x0, y0);\n                    ctx.lineTo(x1, y1);\n                }\n                return new BoundingBox(x0, y0, x1, y1);\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                var _this$getPoints3 = this.getPoints(), _this$getPoints4 = _slicedToArray__default[\"default\"](_this$getPoints3, 2), p0 = _this$getPoints4[0], p1 = _this$getPoints4[1];\n                var a = p0.angleTo(p1);\n                return [\n                    [\n                        p0,\n                        a\n                    ],\n                    [\n                        p1,\n                        a\n                    ]\n                ];\n            }\n        }\n    ]);\n    return LineElement;\n}(PathElement);\nfunction _createSuper$w(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$w();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$w() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar PolylineElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](PolylineElement, _PathElement);\n    var _super = _createSuper$w(PolylineElement);\n    function PolylineElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, PolylineElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"polyline\";\n        _this.points = [];\n        _this.points = Point.parsePath(_this.getAttribute(\"points\").getString());\n        return _this;\n    }\n    _createClass__default[\"default\"](PolylineElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var points = this.points;\n                var _points = _slicedToArray__default[\"default\"](points, 1), _points$ = _points[0], x0 = _points$.x, y0 = _points$.y;\n                var boundingBox = new BoundingBox(x0, y0);\n                if (ctx) {\n                    ctx.beginPath();\n                    ctx.moveTo(x0, y0);\n                }\n                points.forEach(function(_ref) {\n                    var x = _ref.x, y = _ref.y;\n                    boundingBox.addPoint(x, y);\n                    if (ctx) {\n                        ctx.lineTo(x, y);\n                    }\n                });\n                return boundingBox;\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                var points = this.points;\n                var lastIndex = points.length - 1;\n                var markers = [];\n                points.forEach(function(point, i) {\n                    if (i === lastIndex) {\n                        return;\n                    }\n                    markers.push([\n                        point,\n                        point.angleTo(points[i + 1])\n                    ]);\n                });\n                if (markers.length > 0) {\n                    markers.push([\n                        points[points.length - 1],\n                        markers[markers.length - 1][1]\n                    ]);\n                }\n                return markers;\n            }\n        }\n    ]);\n    return PolylineElement;\n}(PathElement);\nfunction _createSuper$v(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$v();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$v() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar PolygonElement = /*#__PURE__*/ function(_PolylineElement) {\n    _inherits__default[\"default\"](PolygonElement, _PolylineElement);\n    var _super = _createSuper$v(PolygonElement);\n    function PolygonElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, PolygonElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"polygon\";\n        return _this;\n    }\n    _createClass__default[\"default\"](PolygonElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var boundingBox = _get__default[\"default\"](_getPrototypeOf__default[\"default\"](PolygonElement.prototype), \"path\", this).call(this, ctx);\n                var _this$points = _slicedToArray__default[\"default\"](this.points, 1), _this$points$ = _this$points[0], x = _this$points$.x, y = _this$points$.y;\n                if (ctx) {\n                    ctx.lineTo(x, y);\n                    ctx.closePath();\n                }\n                return boundingBox;\n            }\n        }\n    ]);\n    return PolygonElement;\n}(PolylineElement);\nfunction _createSuper$u(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$u();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$u() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar PatternElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](PatternElement, _Element);\n    var _super = _createSuper$u(PatternElement);\n    function PatternElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, PatternElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"pattern\";\n        return _this;\n    }\n    _createClass__default[\"default\"](PatternElement, [\n        {\n            key: \"createPattern\",\n            value: function createPattern(ctx, _, parentOpacityProp) {\n                var width = this.getStyle(\"width\").getPixels(\"x\", true);\n                var height = this.getStyle(\"height\").getPixels(\"y\", true); // render me using a temporary svg element\n                var patternSvg = new SVGElement(this.document, null);\n                patternSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n                patternSvg.attributes.width = new Property(this.document, \"width\", \"\".concat(width, \"px\"));\n                patternSvg.attributes.height = new Property(this.document, \"height\", \"\".concat(height, \"px\"));\n                patternSvg.attributes.transform = new Property(this.document, \"transform\", this.getAttribute(\"patternTransform\").getValue());\n                patternSvg.children = this.children;\n                var patternCanvas = this.document.createCanvas(width, height);\n                var patternCtx = patternCanvas.getContext(\"2d\");\n                var xAttr = this.getAttribute(\"x\");\n                var yAttr = this.getAttribute(\"y\");\n                if (xAttr.hasValue() && yAttr.hasValue()) {\n                    patternCtx.translate(xAttr.getPixels(\"x\", true), yAttr.getPixels(\"y\", true));\n                }\n                if (parentOpacityProp.hasValue()) {\n                    this.styles[\"fill-opacity\"] = parentOpacityProp;\n                } else {\n                    Reflect.deleteProperty(this.styles, \"fill-opacity\");\n                } // render 3x3 grid so when we transform there's no white space on edges\n                for(var x = -1; x <= 1; x++){\n                    for(var y = -1; y <= 1; y++){\n                        patternCtx.save();\n                        patternSvg.attributes.x = new Property(this.document, \"x\", x * patternCanvas.width);\n                        patternSvg.attributes.y = new Property(this.document, \"y\", y * patternCanvas.height);\n                        patternSvg.render(patternCtx);\n                        patternCtx.restore();\n                    }\n                }\n                var pattern = ctx.createPattern(patternCanvas, \"repeat\");\n                return pattern;\n            }\n        }\n    ]);\n    return PatternElement;\n}(Element);\nfunction _createSuper$t(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$t();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$t() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar MarkerElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](MarkerElement, _Element);\n    var _super = _createSuper$t(MarkerElement);\n    function MarkerElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, MarkerElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"marker\";\n        return _this;\n    }\n    _createClass__default[\"default\"](MarkerElement, [\n        {\n            key: \"render\",\n            value: function render(ctx, point, angle) {\n                if (!point) {\n                    return;\n                }\n                var x = point.x, y = point.y;\n                var orient = this.getAttribute(\"orient\").getString(\"auto\");\n                var markerUnits = this.getAttribute(\"markerUnits\").getString(\"strokeWidth\");\n                ctx.translate(x, y);\n                if (orient === \"auto\") {\n                    ctx.rotate(angle);\n                }\n                if (markerUnits === \"strokeWidth\") {\n                    ctx.scale(ctx.lineWidth, ctx.lineWidth);\n                }\n                ctx.save(); // render me using a temporary svg element\n                var markerSvg = new SVGElement(this.document, null);\n                markerSvg.type = this.type;\n                markerSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n                markerSvg.attributes.refX = new Property(this.document, \"refX\", this.getAttribute(\"refX\").getValue());\n                markerSvg.attributes.refY = new Property(this.document, \"refY\", this.getAttribute(\"refY\").getValue());\n                markerSvg.attributes.width = new Property(this.document, \"width\", this.getAttribute(\"markerWidth\").getValue());\n                markerSvg.attributes.height = new Property(this.document, \"height\", this.getAttribute(\"markerHeight\").getValue());\n                markerSvg.attributes.overflow = new Property(this.document, \"overflow\", this.getAttribute(\"overflow\").getValue());\n                markerSvg.attributes.fill = new Property(this.document, \"fill\", this.getAttribute(\"fill\").getColor(\"black\"));\n                markerSvg.attributes.stroke = new Property(this.document, \"stroke\", this.getAttribute(\"stroke\").getValue(\"none\"));\n                markerSvg.children = this.children;\n                markerSvg.render(ctx);\n                ctx.restore();\n                if (markerUnits === \"strokeWidth\") {\n                    ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n                }\n                if (orient === \"auto\") {\n                    ctx.rotate(-angle);\n                }\n                ctx.translate(-x, -y);\n            }\n        }\n    ]);\n    return MarkerElement;\n}(Element);\nfunction _createSuper$s(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$s();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$s() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar DefsElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](DefsElement, _Element);\n    var _super = _createSuper$s(DefsElement);\n    function DefsElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, DefsElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"defs\";\n        return _this;\n    }\n    _createClass__default[\"default\"](DefsElement, [\n        {\n            key: \"render\",\n            value: function render() {}\n        }\n    ]);\n    return DefsElement;\n}(Element);\nfunction _createSuper$r(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$r();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$r() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar GElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](GElement, _RenderedElement);\n    var _super = _createSuper$r(GElement);\n    function GElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, GElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"g\";\n        return _this;\n    }\n    _createClass__default[\"default\"](GElement, [\n        {\n            key: \"getBoundingBox\",\n            value: function getBoundingBox(ctx) {\n                var boundingBox = new BoundingBox();\n                this.children.forEach(function(child) {\n                    boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n                });\n                return boundingBox;\n            }\n        }\n    ]);\n    return GElement;\n}(RenderedElement);\nfunction _createSuper$q(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$q();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$q() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar GradientElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](GradientElement, _Element);\n    var _super = _createSuper$q(GradientElement);\n    function GradientElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, GradientElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.attributesToInherit = [\n            \"gradientUnits\"\n        ];\n        _this.stops = [];\n        var _assertThisInitialize = _assertThisInitialized__default[\"default\"](_this), stops = _assertThisInitialize.stops, children = _assertThisInitialize.children;\n        children.forEach(function(child) {\n            if (child.type === \"stop\") {\n                stops.push(child);\n            }\n        });\n        return _this;\n    }\n    _createClass__default[\"default\"](GradientElement, [\n        {\n            key: \"getGradientUnits\",\n            value: function getGradientUnits() {\n                return this.getAttribute(\"gradientUnits\").getString(\"objectBoundingBox\");\n            }\n        },\n        {\n            key: \"createGradient\",\n            value: function createGradient(ctx, element, parentOpacityProp) {\n                var _this2 = this;\n                // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n                var stopsContainer = this;\n                if (this.getHrefAttribute().hasValue()) {\n                    stopsContainer = this.getHrefAttribute().getDefinition();\n                    this.inheritStopContainer(stopsContainer);\n                }\n                var _stopsContainer = stopsContainer, stops = _stopsContainer.stops;\n                var gradient = this.getGradient(ctx, element);\n                if (!gradient) {\n                    return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);\n                }\n                stops.forEach(function(stop) {\n                    gradient.addColorStop(stop.offset, _this2.addParentOpacity(parentOpacityProp, stop.color));\n                });\n                if (this.getAttribute(\"gradientTransform\").hasValue()) {\n                    // render as transformed pattern on temporary canvas\n                    var document1 = this.document;\n                    var _document$screen = document1.screen, MAX_VIRTUAL_PIXELS = _document$screen.MAX_VIRTUAL_PIXELS, viewPort = _document$screen.viewPort;\n                    var _viewPort$viewPorts = _slicedToArray__default[\"default\"](viewPort.viewPorts, 1), rootView = _viewPort$viewPorts[0];\n                    var rect = new RectElement(document1, null);\n                    rect.attributes.x = new Property(document1, \"x\", -MAX_VIRTUAL_PIXELS / 3.0);\n                    rect.attributes.y = new Property(document1, \"y\", -MAX_VIRTUAL_PIXELS / 3.0);\n                    rect.attributes.width = new Property(document1, \"width\", MAX_VIRTUAL_PIXELS);\n                    rect.attributes.height = new Property(document1, \"height\", MAX_VIRTUAL_PIXELS);\n                    var group = new GElement(document1, null);\n                    group.attributes.transform = new Property(document1, \"transform\", this.getAttribute(\"gradientTransform\").getValue());\n                    group.children = [\n                        rect\n                    ];\n                    var patternSvg = new SVGElement(document1, null);\n                    patternSvg.attributes.x = new Property(document1, \"x\", 0);\n                    patternSvg.attributes.y = new Property(document1, \"y\", 0);\n                    patternSvg.attributes.width = new Property(document1, \"width\", rootView.width);\n                    patternSvg.attributes.height = new Property(document1, \"height\", rootView.height);\n                    patternSvg.children = [\n                        group\n                    ];\n                    var patternCanvas = document1.createCanvas(rootView.width, rootView.height);\n                    var patternCtx = patternCanvas.getContext(\"2d\");\n                    patternCtx.fillStyle = gradient;\n                    patternSvg.render(patternCtx);\n                    return patternCtx.createPattern(patternCanvas, \"no-repeat\");\n                }\n                return gradient;\n            }\n        },\n        {\n            key: \"inheritStopContainer\",\n            value: function inheritStopContainer(stopsContainer) {\n                var _this3 = this;\n                this.attributesToInherit.forEach(function(attributeToInherit) {\n                    if (!_this3.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {\n                        _this3.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());\n                    }\n                });\n            }\n        },\n        {\n            key: \"addParentOpacity\",\n            value: function addParentOpacity(parentOpacityProp, color) {\n                if (parentOpacityProp.hasValue()) {\n                    var colorProp = new Property(this.document, \"color\", color);\n                    return colorProp.addOpacity(parentOpacityProp).getColor();\n                }\n                return color;\n            }\n        }\n    ]);\n    return GradientElement;\n}(Element);\nfunction _createSuper$p(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$p();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$p() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar LinearGradientElement = /*#__PURE__*/ function(_GradientElement) {\n    _inherits__default[\"default\"](LinearGradientElement, _GradientElement);\n    var _super = _createSuper$p(LinearGradientElement);\n    function LinearGradientElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, LinearGradientElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"linearGradient\";\n        _this.attributesToInherit.push(\"x1\", \"y1\", \"x2\", \"y2\");\n        return _this;\n    }\n    _createClass__default[\"default\"](LinearGradientElement, [\n        {\n            key: \"getGradient\",\n            value: function getGradient(ctx, element) {\n                var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n                var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;\n                if (isBoundingBoxUnits && !boundingBox) {\n                    return null;\n                }\n                if (!this.getAttribute(\"x1\").hasValue() && !this.getAttribute(\"y1\").hasValue() && !this.getAttribute(\"x2\").hasValue() && !this.getAttribute(\"y2\").hasValue()) {\n                    this.getAttribute(\"x1\", true).setValue(0);\n                    this.getAttribute(\"y1\", true).setValue(0);\n                    this.getAttribute(\"x2\", true).setValue(1);\n                    this.getAttribute(\"y2\", true).setValue(0);\n                }\n                var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x1\").getNumber() : this.getAttribute(\"x1\").getPixels(\"x\");\n                var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y1\").getNumber() : this.getAttribute(\"y1\").getPixels(\"y\");\n                var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x2\").getNumber() : this.getAttribute(\"x2\").getPixels(\"x\");\n                var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y2\").getNumber() : this.getAttribute(\"y2\").getPixels(\"y\");\n                if (x1 === x2 && y1 === y2) {\n                    return null;\n                }\n                return ctx.createLinearGradient(x1, y1, x2, y2);\n            }\n        }\n    ]);\n    return LinearGradientElement;\n}(GradientElement);\nfunction _createSuper$o(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$o();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$o() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar RadialGradientElement = /*#__PURE__*/ function(_GradientElement) {\n    _inherits__default[\"default\"](RadialGradientElement, _GradientElement);\n    var _super = _createSuper$o(RadialGradientElement);\n    function RadialGradientElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, RadialGradientElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"radialGradient\";\n        _this.attributesToInherit.push(\"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\");\n        return _this;\n    }\n    _createClass__default[\"default\"](RadialGradientElement, [\n        {\n            key: \"getGradient\",\n            value: function getGradient(ctx, element) {\n                var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n                var boundingBox = element.getBoundingBox(ctx);\n                if (isBoundingBoxUnits && !boundingBox) {\n                    return null;\n                }\n                if (!this.getAttribute(\"cx\").hasValue()) {\n                    this.getAttribute(\"cx\", true).setValue(\"50%\");\n                }\n                if (!this.getAttribute(\"cy\").hasValue()) {\n                    this.getAttribute(\"cy\", true).setValue(\"50%\");\n                }\n                if (!this.getAttribute(\"r\").hasValue()) {\n                    this.getAttribute(\"r\", true).setValue(\"50%\");\n                }\n                var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"cx\").getNumber() : this.getAttribute(\"cx\").getPixels(\"x\");\n                var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"cy\").getNumber() : this.getAttribute(\"cy\").getPixels(\"y\");\n                var fx = cx;\n                var fy = cy;\n                if (this.getAttribute(\"fx\").hasValue()) {\n                    fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"fx\").getNumber() : this.getAttribute(\"fx\").getPixels(\"x\");\n                }\n                if (this.getAttribute(\"fy\").hasValue()) {\n                    fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"fy\").getNumber() : this.getAttribute(\"fy\").getPixels(\"y\");\n                }\n                var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2.0 * this.getAttribute(\"r\").getNumber() : this.getAttribute(\"r\").getPixels();\n                var fr = this.getAttribute(\"fr\").getPixels();\n                return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);\n            }\n        }\n    ]);\n    return RadialGradientElement;\n}(GradientElement);\nfunction _createSuper$n(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$n();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$n() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar StopElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](StopElement, _Element);\n    var _super = _createSuper$n(StopElement);\n    function StopElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, StopElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"stop\";\n        var offset = Math.max(0, Math.min(1, _this.getAttribute(\"offset\").getNumber()));\n        var stopOpacity = _this.getStyle(\"stop-opacity\");\n        var stopColor = _this.getStyle(\"stop-color\", true);\n        if (stopColor.getString() === \"\") {\n            stopColor.setValue(\"#000\");\n        }\n        if (stopOpacity.hasValue()) {\n            stopColor = stopColor.addOpacity(stopOpacity);\n        }\n        _this.offset = offset;\n        _this.color = stopColor.getColor();\n        return _this;\n    }\n    return StopElement;\n}(Element);\nfunction _createSuper$m(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$m();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$m() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar AnimateElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](AnimateElement, _Element);\n    var _super = _createSuper$m(AnimateElement);\n    function AnimateElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, AnimateElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"animate\";\n        _this.duration = 0;\n        _this.initialValue = null;\n        _this.initialUnits = \"\";\n        _this.removed = false;\n        _this.frozen = false;\n        document1.screen.animations.push(_assertThisInitialized__default[\"default\"](_this));\n        _this.begin = _this.getAttribute(\"begin\").getMilliseconds();\n        _this.maxDuration = _this.begin + _this.getAttribute(\"dur\").getMilliseconds();\n        _this.from = _this.getAttribute(\"from\");\n        _this.to = _this.getAttribute(\"to\");\n        _this.values = new Property(document1, \"values\", null);\n        var valuesAttr = _this.getAttribute(\"values\");\n        if (valuesAttr.hasValue()) {\n            _this.values.setValue(valuesAttr.getString().split(\";\"));\n        }\n        return _this;\n    }\n    _createClass__default[\"default\"](AnimateElement, [\n        {\n            key: \"getProperty\",\n            value: function getProperty() {\n                var attributeType = this.getAttribute(\"attributeType\").getString();\n                var attributeName = this.getAttribute(\"attributeName\").getString();\n                if (attributeType === \"CSS\") {\n                    return this.parent.getStyle(attributeName, true);\n                }\n                return this.parent.getAttribute(attributeName, true);\n            }\n        },\n        {\n            key: \"calcValue\",\n            value: function calcValue() {\n                var initialUnits = this.initialUnits;\n                var _this$getProgress = this.getProgress(), progress = _this$getProgress.progress, from = _this$getProgress.from, to = _this$getProgress.to; // tween value linearly\n                var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;\n                if (initialUnits === \"%\") {\n                    newValue *= 100.0; // numValue() returns 0-1 whereas properties are 0-100\n                }\n                return \"\".concat(newValue).concat(initialUnits);\n            }\n        },\n        {\n            key: \"update\",\n            value: function update(delta) {\n                var parent = this.parent;\n                var prop = this.getProperty(); // set initial value\n                if (!this.initialValue) {\n                    this.initialValue = prop.getString();\n                    this.initialUnits = prop.getUnits();\n                } // if we're past the end time\n                if (this.duration > this.maxDuration) {\n                    var fill = this.getAttribute(\"fill\").getString(\"remove\"); // loop for indefinitely repeating animations\n                    if (this.getAttribute(\"repeatCount\").getString() === \"indefinite\" || this.getAttribute(\"repeatDur\").getString() === \"indefinite\") {\n                        this.duration = 0;\n                    } else if (fill === \"freeze\" && !this.frozen) {\n                        this.frozen = true;\n                        parent.animationFrozen = true;\n                        parent.animationFrozenValue = prop.getString();\n                    } else if (fill === \"remove\" && !this.removed) {\n                        this.removed = true;\n                        prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);\n                        return true;\n                    }\n                    return false;\n                }\n                this.duration += delta; // if we're past the begin time\n                var updated = false;\n                if (this.begin < this.duration) {\n                    var newValue = this.calcValue(); // tween\n                    var typeAttr = this.getAttribute(\"type\");\n                    if (typeAttr.hasValue()) {\n                        // for transform, etc.\n                        var type = typeAttr.getString();\n                        newValue = \"\".concat(type, \"(\").concat(newValue, \")\");\n                    }\n                    prop.setValue(newValue);\n                    updated = true;\n                }\n                return updated;\n            }\n        },\n        {\n            key: \"getProgress\",\n            value: function getProgress() {\n                var document1 = this.document, values = this.values;\n                var result = {\n                    progress: (this.duration - this.begin) / (this.maxDuration - this.begin)\n                };\n                if (values.hasValue()) {\n                    var p = result.progress * (values.getValue().length - 1);\n                    var lb = Math.floor(p);\n                    var ub = Math.ceil(p);\n                    result.from = new Property(document1, \"from\", parseFloat(values.getValue()[lb]));\n                    result.to = new Property(document1, \"to\", parseFloat(values.getValue()[ub]));\n                    result.progress = (p - lb) / (ub - lb);\n                } else {\n                    result.from = this.from;\n                    result.to = this.to;\n                }\n                return result;\n            }\n        }\n    ]);\n    return AnimateElement;\n}(Element);\nfunction _createSuper$l(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$l();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$l() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar AnimateColorElement = /*#__PURE__*/ function(_AnimateElement) {\n    _inherits__default[\"default\"](AnimateColorElement, _AnimateElement);\n    var _super = _createSuper$l(AnimateColorElement);\n    function AnimateColorElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, AnimateColorElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"animateColor\";\n        return _this;\n    }\n    _createClass__default[\"default\"](AnimateColorElement, [\n        {\n            key: \"calcValue\",\n            value: function calcValue() {\n                var _this$getProgress = this.getProgress(), progress = _this$getProgress.progress, from = _this$getProgress.from, to = _this$getProgress.to;\n                var colorFrom = new RGBColor__default[\"default\"](from.getColor());\n                var colorTo = new RGBColor__default[\"default\"](to.getColor());\n                if (colorFrom.ok && colorTo.ok) {\n                    // tween color linearly\n                    var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;\n                    var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;\n                    var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress; // ? alpha\n                    return \"rgb(\".concat(Math.floor(r), \", \").concat(Math.floor(g), \", \").concat(Math.floor(b), \")\");\n                }\n                return this.getAttribute(\"from\").getColor();\n            }\n        }\n    ]);\n    return AnimateColorElement;\n}(AnimateElement);\nfunction _createSuper$k(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$k();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$k() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar AnimateTransformElement = /*#__PURE__*/ function(_AnimateElement) {\n    _inherits__default[\"default\"](AnimateTransformElement, _AnimateElement);\n    var _super = _createSuper$k(AnimateTransformElement);\n    function AnimateTransformElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, AnimateTransformElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"animateTransform\";\n        return _this;\n    }\n    _createClass__default[\"default\"](AnimateTransformElement, [\n        {\n            key: \"calcValue\",\n            value: function calcValue() {\n                var _this$getProgress = this.getProgress(), progress = _this$getProgress.progress, from = _this$getProgress.from, to = _this$getProgress.to; // tween value linearly\n                var transformFrom = toNumbers(from.getString());\n                var transformTo = toNumbers(to.getString());\n                var newValue = transformFrom.map(function(from, i) {\n                    var to = transformTo[i];\n                    return from + (to - from) * progress;\n                }).join(\" \");\n                return newValue;\n            }\n        }\n    ]);\n    return AnimateTransformElement;\n}(AnimateElement);\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it.return != null) it.return();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$1(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\nfunction _arrayLikeToArray$1(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction _createSuper$j(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$j();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$j() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FontElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FontElement, _Element);\n    var _super = _createSuper$j(FontElement);\n    function FontElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FontElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"font\";\n        _this.glyphs = Object.create(null);\n        _this.horizAdvX = _this.getAttribute(\"horiz-adv-x\").getNumber();\n        var definitions = document1.definitions;\n        var _assertThisInitialize = _assertThisInitialized__default[\"default\"](_this), children = _assertThisInitialize.children;\n        var _iterator = _createForOfIteratorHelper$1(children), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var child = _step.value;\n                switch(child.type){\n                    case \"font-face\":\n                        {\n                            _this.fontFace = child;\n                            var fontFamilyStyle = child.getStyle(\"font-family\");\n                            if (fontFamilyStyle.hasValue()) {\n                                definitions[fontFamilyStyle.getString()] = _assertThisInitialized__default[\"default\"](_this);\n                            }\n                            break;\n                        }\n                    case \"missing-glyph\":\n                        _this.missingGlyph = child;\n                        break;\n                    case \"glyph\":\n                        {\n                            var glyph = child;\n                            if (glyph.arabicForm) {\n                                _this.isRTL = true;\n                                _this.isArabic = true;\n                                if (typeof _this.glyphs[glyph.unicode] === \"undefined\") {\n                                    _this.glyphs[glyph.unicode] = Object.create(null);\n                                }\n                                _this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;\n                            } else {\n                                _this.glyphs[glyph.unicode] = glyph;\n                            }\n                            break;\n                        }\n                    default:\n                }\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n        return _this;\n    }\n    _createClass__default[\"default\"](FontElement, [\n        {\n            key: \"render\",\n            value: function render() {}\n        }\n    ]);\n    return FontElement;\n}(Element);\nfunction _createSuper$i(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$i();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$i() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FontFaceElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FontFaceElement, _Element);\n    var _super = _createSuper$i(FontFaceElement);\n    function FontFaceElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FontFaceElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"font-face\";\n        _this.ascent = _this.getAttribute(\"ascent\").getNumber();\n        _this.descent = _this.getAttribute(\"descent\").getNumber();\n        _this.unitsPerEm = _this.getAttribute(\"units-per-em\").getNumber();\n        return _this;\n    }\n    return FontFaceElement;\n}(Element);\nfunction _createSuper$h(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$h();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$h() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar MissingGlyphElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](MissingGlyphElement, _PathElement);\n    var _super = _createSuper$h(MissingGlyphElement);\n    function MissingGlyphElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, MissingGlyphElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"missing-glyph\";\n        _this.horizAdvX = 0;\n        return _this;\n    }\n    return MissingGlyphElement;\n}(PathElement);\nfunction _createSuper$g(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$g();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$g() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TRefElement = /*#__PURE__*/ function(_TextElement) {\n    _inherits__default[\"default\"](TRefElement, _TextElement);\n    var _super = _createSuper$g(TRefElement);\n    function TRefElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TRefElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"tref\";\n        return _this;\n    }\n    _createClass__default[\"default\"](TRefElement, [\n        {\n            key: \"getText\",\n            value: function getText() {\n                var element = this.getHrefAttribute().getDefinition();\n                if (element) {\n                    var firstChild = element.children[0];\n                    if (firstChild) {\n                        return firstChild.getText();\n                    }\n                }\n                return \"\";\n            }\n        }\n    ]);\n    return TRefElement;\n}(TextElement);\nfunction _createSuper$f(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$f();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$f() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar AElement = /*#__PURE__*/ function(_TextElement) {\n    _inherits__default[\"default\"](AElement, _TextElement);\n    var _super = _createSuper$f(AElement);\n    function AElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, AElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"a\";\n        var childNodes = node.childNodes;\n        var firstChild = childNodes[0];\n        var hasText = childNodes.length > 0 && Array.from(childNodes).every(function(node) {\n            return node.nodeType === 3;\n        });\n        _this.hasText = hasText;\n        _this.text = hasText ? _this.getTextFromNode(firstChild) : \"\";\n        return _this;\n    }\n    _createClass__default[\"default\"](AElement, [\n        {\n            key: \"getText\",\n            value: function getText() {\n                return this.text;\n            }\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                if (this.hasText) {\n                    // render as text element\n                    _get__default[\"default\"](_getPrototypeOf__default[\"default\"](AElement.prototype), \"renderChildren\", this).call(this, ctx);\n                    var document1 = this.document, x = this.x, y = this.y;\n                    var mouse = document1.screen.mouse;\n                    var fontSize = new Property(document1, \"fontSize\", Font.parse(document1.ctx.font).fontSize); // Do not calc bounding box if mouse is not working.\n                    if (mouse.isWorking()) {\n                        mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels(\"y\"), x + this.measureText(ctx), y));\n                    }\n                } else if (this.children.length > 0) {\n                    // render as temporary group\n                    var g = new GElement(this.document, null);\n                    g.children = this.children;\n                    g.parent = this;\n                    g.render(ctx);\n                }\n            }\n        },\n        {\n            key: \"onClick\",\n            value: function onClick() {\n                var window1 = this.document.window;\n                if (window1) {\n                    window1.open(this.getHrefAttribute().getString());\n                }\n            }\n        },\n        {\n            key: \"onMouseMove\",\n            value: function onMouseMove() {\n                var ctx = this.document.ctx;\n                ctx.canvas.style.cursor = \"pointer\";\n            }\n        }\n    ]);\n    return AElement;\n}(TextElement);\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it.return != null) it.return();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _defineProperty__default[\"default\"](target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _createSuper$e(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$e();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$e() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TextPathElement = /*#__PURE__*/ function(_TextElement) {\n    _inherits__default[\"default\"](TextPathElement, _TextElement);\n    var _super = _createSuper$e(TextPathElement);\n    function TextPathElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TextPathElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"textPath\";\n        _this.textWidth = 0;\n        _this.textHeight = 0;\n        _this.pathLength = -1;\n        _this.glyphInfo = null;\n        _this.letterSpacingCache = [];\n        _this.measuresCache = new Map([\n            [\n                \"\",\n                0\n            ]\n        ]);\n        var pathElement = _this.getHrefAttribute().getDefinition();\n        _this.text = _this.getTextFromNode();\n        _this.dataArray = _this.parsePathData(pathElement);\n        return _this;\n    }\n    _createClass__default[\"default\"](TextPathElement, [\n        {\n            key: \"getText\",\n            value: function getText() {\n                return this.text;\n            }\n        },\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var dataArray = this.dataArray;\n                if (ctx) {\n                    ctx.beginPath();\n                }\n                dataArray.forEach(function(_ref) {\n                    var type = _ref.type, points = _ref.points;\n                    switch(type){\n                        case PathParser.LINE_TO:\n                            if (ctx) {\n                                ctx.lineTo(points[0], points[1]);\n                            }\n                            break;\n                        case PathParser.MOVE_TO:\n                            if (ctx) {\n                                ctx.moveTo(points[0], points[1]);\n                            }\n                            break;\n                        case PathParser.CURVE_TO:\n                            if (ctx) {\n                                ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);\n                            }\n                            break;\n                        case PathParser.QUAD_TO:\n                            if (ctx) {\n                                ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);\n                            }\n                            break;\n                        case PathParser.ARC:\n                            {\n                                var _points = _slicedToArray__default[\"default\"](points, 8), cx = _points[0], cy = _points[1], rx = _points[2], ry = _points[3], theta = _points[4], dTheta = _points[5], psi = _points[6], fs = _points[7];\n                                var r = rx > ry ? rx : ry;\n                                var scaleX = rx > ry ? 1 : rx / ry;\n                                var scaleY = rx > ry ? ry / rx : 1;\n                                if (ctx) {\n                                    ctx.translate(cx, cy);\n                                    ctx.rotate(psi);\n                                    ctx.scale(scaleX, scaleY);\n                                    ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));\n                                    ctx.scale(1 / scaleX, 1 / scaleY);\n                                    ctx.rotate(-psi);\n                                    ctx.translate(-cx, -cy);\n                                }\n                                break;\n                            }\n                        case PathParser.CLOSE_PATH:\n                            if (ctx) {\n                                ctx.closePath();\n                            }\n                            break;\n                    }\n                });\n            }\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                this.setTextData(ctx);\n                ctx.save();\n                var textDecoration = this.parent.getStyle(\"text-decoration\").getString();\n                var fontSize = this.getFontSize();\n                var glyphInfo = this.glyphInfo;\n                var fill = ctx.fillStyle;\n                if (textDecoration === \"underline\") {\n                    ctx.beginPath();\n                }\n                glyphInfo.forEach(function(glyph, i) {\n                    var p0 = glyph.p0, p1 = glyph.p1, rotation = glyph.rotation, partialText = glyph.text;\n                    ctx.save();\n                    ctx.translate(p0.x, p0.y);\n                    ctx.rotate(rotation);\n                    if (ctx.fillStyle) {\n                        ctx.fillText(partialText, 0, 0);\n                    }\n                    if (ctx.strokeStyle) {\n                        ctx.strokeText(partialText, 0, 0);\n                    }\n                    ctx.restore();\n                    if (textDecoration === \"underline\") {\n                        if (i === 0) {\n                            ctx.moveTo(p0.x, p0.y + fontSize / 8);\n                        }\n                        ctx.lineTo(p1.x, p1.y + fontSize / 5);\n                    } // // To assist with debugging visually, uncomment following\n                //\n                // ctx.beginPath();\n                // if (i % 2)\n                // \tctx.strokeStyle = 'red';\n                // else\n                // \tctx.strokeStyle = 'green';\n                // ctx.moveTo(p0.x, p0.y);\n                // ctx.lineTo(p1.x, p1.y);\n                // ctx.stroke();\n                // ctx.closePath();\n                });\n                if (textDecoration === \"underline\") {\n                    ctx.lineWidth = fontSize / 20;\n                    ctx.strokeStyle = fill;\n                    ctx.stroke();\n                    ctx.closePath();\n                }\n                ctx.restore();\n            }\n        },\n        {\n            key: \"getLetterSpacingAt\",\n            value: function getLetterSpacingAt() {\n                var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                return this.letterSpacingCache[idx] || 0;\n            }\n        },\n        {\n            key: \"findSegmentToFitChar\",\n            value: function findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {\n                var offset = inputOffset;\n                var glyphWidth = this.measureText(ctx, c);\n                if (c === \" \" && anchor === \"justify\" && textFullWidth < fullPathWidth) {\n                    glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n                }\n                if (charI > -1) {\n                    offset += this.getLetterSpacingAt(charI);\n                }\n                var splineStep = this.textHeight / 20;\n                var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);\n                var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);\n                var segment = {\n                    p0: p0,\n                    p1: p1\n                };\n                var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;\n                if (dy) {\n                    var dyX = Math.cos(Math.PI / 2 + rotation) * dy;\n                    var dyY = Math.cos(-rotation) * dy;\n                    segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {\n                        x: p0.x + dyX,\n                        y: p0.y + dyY\n                    });\n                    segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {\n                        x: p1.x + dyX,\n                        y: p1.y + dyY\n                    });\n                }\n                offset += glyphWidth;\n                return {\n                    offset: offset,\n                    segment: segment,\n                    rotation: rotation\n                };\n            }\n        },\n        {\n            key: \"measureText\",\n            value: function measureText(ctx, text) {\n                var measuresCache = this.measuresCache;\n                var targetText = text || this.getText();\n                if (measuresCache.has(targetText)) {\n                    return measuresCache.get(targetText);\n                }\n                var measure = this.measureTargetText(ctx, targetText);\n                measuresCache.set(targetText, measure);\n                return measure;\n            } // This method supposes what all custom fonts already loaded.\n        },\n        {\n            key: \"setTextData\",\n            value: function setTextData(ctx) {\n                var _this2 = this;\n                if (this.glyphInfo) {\n                    return;\n                }\n                var renderText = this.getText();\n                var chars = renderText.split(\"\");\n                var spacesNumber = renderText.split(\" \").length - 1;\n                var dx = this.parent.getAttribute(\"dx\").split().map(function(_) {\n                    return _.getPixels(\"x\");\n                });\n                var dy = this.parent.getAttribute(\"dy\").getPixels(\"y\");\n                var anchor = this.parent.getStyle(\"text-anchor\").getString(\"start\");\n                var thisSpacing = this.getStyle(\"letter-spacing\");\n                var parentSpacing = this.parent.getStyle(\"letter-spacing\");\n                var letterSpacing = 0;\n                if (!thisSpacing.hasValue() || thisSpacing.getValue() === \"inherit\") {\n                    letterSpacing = parentSpacing.getPixels();\n                } else if (thisSpacing.hasValue()) {\n                    if (thisSpacing.getValue() !== \"initial\" && thisSpacing.getValue() !== \"unset\") {\n                        letterSpacing = thisSpacing.getPixels();\n                    }\n                } // fill letter-spacing cache\n                var letterSpacingCache = [];\n                var textLen = renderText.length;\n                this.letterSpacingCache = letterSpacingCache;\n                for(var i = 0; i < textLen; i++){\n                    letterSpacingCache.push(typeof dx[i] !== \"undefined\" ? dx[i] : letterSpacing);\n                }\n                var dxSum = letterSpacingCache.reduce(function(acc, cur, i) {\n                    return i === 0 ? 0 : acc + cur || 0;\n                }, 0);\n                var textWidth = this.measureText(ctx);\n                var textFullWidth = Math.max(textWidth + dxSum, 0);\n                this.textWidth = textWidth;\n                this.textHeight = this.getFontSize();\n                this.glyphInfo = [];\n                var fullPathWidth = this.getPathLength();\n                var startOffset = this.getStyle(\"startOffset\").getNumber(0) * fullPathWidth;\n                var offset = 0;\n                if (anchor === \"middle\" || anchor === \"center\") {\n                    offset = -textFullWidth / 2;\n                }\n                if (anchor === \"end\" || anchor === \"right\") {\n                    offset = -textFullWidth;\n                }\n                offset += startOffset;\n                chars.forEach(function(char, i) {\n                    // Find such segment what distance between p0 and p1 is approx. width of glyph\n                    var _this2$findSegmentToF = _this2.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i), nextOffset = _this2$findSegmentToF.offset, segment = _this2$findSegmentToF.segment, rotation = _this2$findSegmentToF.rotation;\n                    offset = nextOffset;\n                    if (!segment.p0 || !segment.p1) {\n                        return;\n                    } // const width = this.getLineLength(\n                    // \tsegment.p0.x,\n                    // \tsegment.p0.y,\n                    // \tsegment.p1.x,\n                    // \tsegment.p1.y\n                    // );\n                    // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.\n                    // Can foresee having a rough pair table built in that the developer can override as needed.\n                    // Or use \"dx\" attribute of the <text> node as a naive replacement\n                    // const kern = 0;\n                    // placeholder for future implementation\n                    // const midpoint = this.getPointOnLine(\n                    // \tkern + width / 2.0,\n                    // \tsegment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y\n                    // );\n                    _this2.glyphInfo.push({\n                        // transposeX: midpoint.x,\n                        // transposeY: midpoint.y,\n                        text: chars[i],\n                        p0: segment.p0,\n                        p1: segment.p1,\n                        rotation: rotation\n                    });\n                });\n            }\n        },\n        {\n            key: \"parsePathData\",\n            value: function parsePathData(path) {\n                this.pathLength = -1; // reset path length\n                if (!path) {\n                    return [];\n                }\n                var pathCommands = [];\n                var pathParser = path.pathParser;\n                pathParser.reset(); // convert l, H, h, V, and v to L\n                while(!pathParser.isEnd()){\n                    var current = pathParser.current;\n                    var startX = current ? current.x : 0;\n                    var startY = current ? current.y : 0;\n                    var command = pathParser.next();\n                    var nextCommandType = command.type;\n                    var points = [];\n                    switch(command.type){\n                        case PathParser.MOVE_TO:\n                            this.pathM(pathParser, points);\n                            break;\n                        case PathParser.LINE_TO:\n                            nextCommandType = this.pathL(pathParser, points);\n                            break;\n                        case PathParser.HORIZ_LINE_TO:\n                            nextCommandType = this.pathH(pathParser, points);\n                            break;\n                        case PathParser.VERT_LINE_TO:\n                            nextCommandType = this.pathV(pathParser, points);\n                            break;\n                        case PathParser.CURVE_TO:\n                            this.pathC(pathParser, points);\n                            break;\n                        case PathParser.SMOOTH_CURVE_TO:\n                            nextCommandType = this.pathS(pathParser, points);\n                            break;\n                        case PathParser.QUAD_TO:\n                            this.pathQ(pathParser, points);\n                            break;\n                        case PathParser.SMOOTH_QUAD_TO:\n                            nextCommandType = this.pathT(pathParser, points);\n                            break;\n                        case PathParser.ARC:\n                            points = this.pathA(pathParser);\n                            break;\n                        case PathParser.CLOSE_PATH:\n                            PathElement.pathZ(pathParser);\n                            break;\n                    }\n                    if (command.type !== PathParser.CLOSE_PATH) {\n                        pathCommands.push({\n                            type: nextCommandType,\n                            points: points,\n                            start: {\n                                x: startX,\n                                y: startY\n                            },\n                            pathLength: this.calcLength(startX, startY, nextCommandType, points)\n                        });\n                    } else {\n                        pathCommands.push({\n                            type: PathParser.CLOSE_PATH,\n                            points: [],\n                            pathLength: 0\n                        });\n                    }\n                }\n                return pathCommands;\n            }\n        },\n        {\n            key: \"pathM\",\n            value: function pathM(pathParser, points) {\n                var _PathElement$pathM$po = PathElement.pathM(pathParser).point, x = _PathElement$pathM$po.x, y = _PathElement$pathM$po.y;\n                points.push(x, y);\n            }\n        },\n        {\n            key: \"pathL\",\n            value: function pathL(pathParser, points) {\n                var _PathElement$pathL$po = PathElement.pathL(pathParser).point, x = _PathElement$pathL$po.x, y = _PathElement$pathL$po.y;\n                points.push(x, y);\n                return PathParser.LINE_TO;\n            }\n        },\n        {\n            key: \"pathH\",\n            value: function pathH(pathParser, points) {\n                var _PathElement$pathH$po = PathElement.pathH(pathParser).point, x = _PathElement$pathH$po.x, y = _PathElement$pathH$po.y;\n                points.push(x, y);\n                return PathParser.LINE_TO;\n            }\n        },\n        {\n            key: \"pathV\",\n            value: function pathV(pathParser, points) {\n                var _PathElement$pathV$po = PathElement.pathV(pathParser).point, x = _PathElement$pathV$po.x, y = _PathElement$pathV$po.y;\n                points.push(x, y);\n                return PathParser.LINE_TO;\n            }\n        },\n        {\n            key: \"pathC\",\n            value: function pathC(pathParser, points) {\n                var _PathElement$pathC = PathElement.pathC(pathParser), point = _PathElement$pathC.point, controlPoint = _PathElement$pathC.controlPoint, currentPoint = _PathElement$pathC.currentPoint;\n                points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n            }\n        },\n        {\n            key: \"pathS\",\n            value: function pathS(pathParser, points) {\n                var _PathElement$pathS = PathElement.pathS(pathParser), point = _PathElement$pathS.point, controlPoint = _PathElement$pathS.controlPoint, currentPoint = _PathElement$pathS.currentPoint;\n                points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                return PathParser.CURVE_TO;\n            }\n        },\n        {\n            key: \"pathQ\",\n            value: function pathQ(pathParser, points) {\n                var _PathElement$pathQ = PathElement.pathQ(pathParser), controlPoint = _PathElement$pathQ.controlPoint, currentPoint = _PathElement$pathQ.currentPoint;\n                points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n            }\n        },\n        {\n            key: \"pathT\",\n            value: function pathT(pathParser, points) {\n                var _PathElement$pathT = PathElement.pathT(pathParser), controlPoint = _PathElement$pathT.controlPoint, currentPoint = _PathElement$pathT.currentPoint;\n                points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                return PathParser.QUAD_TO;\n            }\n        },\n        {\n            key: \"pathA\",\n            value: function pathA(pathParser) {\n                var _PathElement$pathA = PathElement.pathA(pathParser), rX = _PathElement$pathA.rX, rY = _PathElement$pathA.rY, sweepFlag = _PathElement$pathA.sweepFlag, xAxisRotation = _PathElement$pathA.xAxisRotation, centp = _PathElement$pathA.centp, a1 = _PathElement$pathA.a1, ad = _PathElement$pathA.ad;\n                if (sweepFlag === 0 && ad > 0) {\n                    ad -= 2 * Math.PI;\n                }\n                if (sweepFlag === 1 && ad < 0) {\n                    ad += 2 * Math.PI;\n                }\n                return [\n                    centp.x,\n                    centp.y,\n                    rX,\n                    rY,\n                    a1,\n                    ad,\n                    xAxisRotation,\n                    sweepFlag\n                ];\n            }\n        },\n        {\n            key: \"calcLength\",\n            value: function calcLength(x, y, commandType, points) {\n                var len = 0;\n                var p1 = null;\n                var p2 = null;\n                var t = 0;\n                switch(commandType){\n                    case PathParser.LINE_TO:\n                        return this.getLineLength(x, y, points[0], points[1]);\n                    case PathParser.CURVE_TO:\n                        // Approximates by breaking curve into 100 line segments\n                        len = 0.0;\n                        p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                        for(t = 0.01; t <= 1; t += 0.01){\n                            p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                        return len;\n                    case PathParser.QUAD_TO:\n                        // Approximates by breaking curve into 100 line segments\n                        len = 0.0;\n                        p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\n                        for(t = 0.01; t <= 1; t += 0.01){\n                            p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                        return len;\n                    case PathParser.ARC:\n                        {\n                            // Approximates by breaking curve into line segments\n                            len = 0.0;\n                            var start = points[4]; // 4 = theta\n                            var dTheta = points[5]; // 5 = dTheta\n                            var end = points[4] + dTheta;\n                            var inc = Math.PI / 180.0; // 1 degree resolution\n                            if (Math.abs(start - end) < inc) {\n                                inc = Math.abs(start - end);\n                            } // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi\n                            p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\n                            if (dTheta < 0) {\n                                // clockwise\n                                for(t = start - inc; t > end; t -= inc){\n                                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                                    p1 = p2;\n                                }\n                            } else {\n                                // counter-clockwise\n                                for(t = start + inc; t < end; t += inc){\n                                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                                    p1 = p2;\n                                }\n                            }\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            return len;\n                        }\n                }\n                return 0;\n            }\n        },\n        {\n            key: \"getPointOnLine\",\n            value: function getPointOnLine(dist, p1x, p1y, p2x, p2y) {\n                var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;\n                var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;\n                var m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);\n                var run = Math.sqrt(dist * dist / (1 + m * m));\n                if (p2x < p1x) {\n                    run *= -1;\n                }\n                var rise = m * run;\n                var pt = null;\n                if (p2x === p1x) {\n                    // vertical line\n                    pt = {\n                        x: fromX,\n                        y: fromY + rise\n                    };\n                } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {\n                    pt = {\n                        x: fromX + run,\n                        y: fromY + rise\n                    };\n                } else {\n                    var ix = 0;\n                    var iy = 0;\n                    var len = this.getLineLength(p1x, p1y, p2x, p2y);\n                    if (len < PSEUDO_ZERO) {\n                        return null;\n                    }\n                    var u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);\n                    u /= len * len;\n                    ix = p1x + u * (p2x - p1x);\n                    iy = p1y + u * (p2y - p1y);\n                    var pRise = this.getLineLength(fromX, fromY, ix, iy);\n                    var pRun = Math.sqrt(dist * dist - pRise * pRise);\n                    run = Math.sqrt(pRun * pRun / (1 + m * m));\n                    if (p2x < p1x) {\n                        run *= -1;\n                    }\n                    rise = m * run;\n                    pt = {\n                        x: ix + run,\n                        y: iy + rise\n                    };\n                }\n                return pt;\n            }\n        },\n        {\n            key: \"getPointOnPath\",\n            value: function getPointOnPath(distance) {\n                var fullLen = this.getPathLength();\n                var cumulativePathLength = 0;\n                var p = null;\n                if (distance < -0.00005 || distance - 0.00005 > fullLen) {\n                    return null;\n                }\n                var dataArray = this.dataArray;\n                var _iterator = _createForOfIteratorHelper(dataArray), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var command = _step.value;\n                        if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {\n                            cumulativePathLength += command.pathLength;\n                            continue;\n                        }\n                        var delta = distance - cumulativePathLength;\n                        var currentT = 0;\n                        switch(command.type){\n                            case PathParser.LINE_TO:\n                                p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);\n                                break;\n                            case PathParser.ARC:\n                                {\n                                    var start = command.points[4]; // 4 = theta\n                                    var dTheta = command.points[5]; // 5 = dTheta\n                                    var end = command.points[4] + dTheta;\n                                    currentT = start + delta / command.pathLength * dTheta;\n                                    if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                                        break;\n                                    }\n                                    p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);\n                                    break;\n                                }\n                            case PathParser.CURVE_TO:\n                                currentT = delta / command.pathLength;\n                                if (currentT > 1) {\n                                    currentT = 1;\n                                }\n                                p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);\n                                break;\n                            case PathParser.QUAD_TO:\n                                currentT = delta / command.pathLength;\n                                if (currentT > 1) {\n                                    currentT = 1;\n                                }\n                                p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);\n                                break;\n                            default:\n                        }\n                        if (p) {\n                            return p;\n                        }\n                        break;\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                return null;\n            }\n        },\n        {\n            key: \"getLineLength\",\n            value: function getLineLength(x1, y1, x2, y2) {\n                return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n            }\n        },\n        {\n            key: \"getPathLength\",\n            value: function getPathLength() {\n                if (this.pathLength === -1) {\n                    this.pathLength = this.dataArray.reduce(function(length, command) {\n                        return command.pathLength > 0 ? length + command.pathLength : length;\n                    }, 0);\n                }\n                return this.pathLength;\n            }\n        },\n        {\n            key: \"getPointOnCubicBezier\",\n            value: function getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n                var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);\n                var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);\n                return {\n                    x: x,\n                    y: y\n                };\n            }\n        },\n        {\n            key: \"getPointOnQuadraticBezier\",\n            value: function getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {\n                var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);\n                var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);\n                return {\n                    x: x,\n                    y: y\n                };\n            }\n        },\n        {\n            key: \"getPointOnEllipticalArc\",\n            value: function getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n                var cosPsi = Math.cos(psi);\n                var sinPsi = Math.sin(psi);\n                var pt = {\n                    x: rx * Math.cos(theta),\n                    y: ry * Math.sin(theta)\n                };\n                return {\n                    x: cx + (pt.x * cosPsi - pt.y * sinPsi),\n                    y: cy + (pt.x * sinPsi + pt.y * cosPsi)\n                };\n            } // TODO need some optimisations. possibly build cache only for curved segments?\n        },\n        {\n            key: \"buildEquidistantCache\",\n            value: function buildEquidistantCache(inputStep, inputPrecision) {\n                var fullLen = this.getPathLength();\n                var precision = inputPrecision || 0.25; // accuracy vs performance\n                var step = inputStep || fullLen / 100;\n                if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {\n                    // Prepare cache\n                    this.equidistantCache = {\n                        step: step,\n                        precision: precision,\n                        points: []\n                    }; // Calculate points\n                    var s = 0;\n                    for(var l = 0; l <= fullLen; l += precision){\n                        var p0 = this.getPointOnPath(l);\n                        var p1 = this.getPointOnPath(l + precision);\n                        if (!p0 || !p1) {\n                            continue;\n                        }\n                        s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                        if (s >= step) {\n                            this.equidistantCache.points.push({\n                                x: p0.x,\n                                y: p0.y,\n                                distance: l\n                            });\n                            s -= step;\n                        }\n                    }\n                }\n            }\n        },\n        {\n            key: \"getEquidistantPointOnPath\",\n            value: function getEquidistantPointOnPath(targetDistance, step, precision) {\n                this.buildEquidistantCache(step, precision);\n                if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {\n                    return null;\n                }\n                var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));\n                return this.equidistantCache.points[idx] || null;\n            }\n        }\n    ]);\n    return TextPathElement;\n}(TextElement);\nfunction _createSuper$d(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$d();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$d() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar dataUriRegex = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nvar ImageElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](ImageElement, _RenderedElement);\n    var _super = _createSuper$d(ImageElement);\n    function ImageElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, ImageElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"image\";\n        _this.loaded = false;\n        var href = _this.getHrefAttribute().getString();\n        if (!href) {\n            return _possibleConstructorReturn__default[\"default\"](_this);\n        }\n        var isSvg = href.endsWith(\".svg\") || /^\\s*data:image\\/svg\\+xml/i.test(href);\n        document1.images.push(_assertThisInitialized__default[\"default\"](_this));\n        if (!isSvg) {\n            void _this.loadImage(href);\n        } else {\n            void _this.loadSvg(href);\n        }\n        _this.isSvg = isSvg;\n        return _this;\n    }\n    _createClass__default[\"default\"](ImageElement, [\n        {\n            key: \"loadImage\",\n            value: function() {\n                var _loadImage = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee(href) {\n                    var image;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    _context.prev = 0;\n                                    _context.next = 3;\n                                    return this.document.createImage(href);\n                                case 3:\n                                    image = _context.sent;\n                                    this.image = image;\n                                    _context.next = 10;\n                                    break;\n                                case 7:\n                                    _context.prev = 7;\n                                    _context.t0 = _context[\"catch\"](0);\n                                    console.error('Error while loading image \"'.concat(href, '\":'), _context.t0);\n                                case 10:\n                                    this.loaded = true;\n                                case 11:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, this, [\n                        [\n                            0,\n                            7\n                        ]\n                    ]);\n                }));\n                function loadImage(_x) {\n                    return _loadImage.apply(this, arguments);\n                }\n                return loadImage;\n            }()\n        },\n        {\n            key: \"loadSvg\",\n            value: function() {\n                var _loadSvg = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee2(href) {\n                    var match, data, response, svg;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee2$(_context2) {\n                        while(1){\n                            switch(_context2.prev = _context2.next){\n                                case 0:\n                                    match = dataUriRegex.exec(href);\n                                    if (!match) {\n                                        _context2.next = 6;\n                                        break;\n                                    }\n                                    data = match[5];\n                                    if (match[4] === \"base64\") {\n                                        this.image = atob(data);\n                                    } else {\n                                        this.image = decodeURIComponent(data);\n                                    }\n                                    _context2.next = 19;\n                                    break;\n                                case 6:\n                                    _context2.prev = 6;\n                                    _context2.next = 9;\n                                    return this.document.fetch(href);\n                                case 9:\n                                    response = _context2.sent;\n                                    _context2.next = 12;\n                                    return response.text();\n                                case 12:\n                                    svg = _context2.sent;\n                                    this.image = svg;\n                                    _context2.next = 19;\n                                    break;\n                                case 16:\n                                    _context2.prev = 16;\n                                    _context2.t0 = _context2[\"catch\"](6);\n                                    console.error('Error while loading image \"'.concat(href, '\":'), _context2.t0);\n                                case 19:\n                                    this.loaded = true;\n                                case 20:\n                                case \"end\":\n                                    return _context2.stop();\n                            }\n                        }\n                    }, _callee2, this, [\n                        [\n                            6,\n                            16\n                        ]\n                    ]);\n                }));\n                function loadSvg(_x2) {\n                    return _loadSvg.apply(this, arguments);\n                }\n                return loadSvg;\n            }()\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                var document1 = this.document, image = this.image, loaded = this.loaded;\n                var x = this.getAttribute(\"x\").getPixels(\"x\");\n                var y = this.getAttribute(\"y\").getPixels(\"y\");\n                var width = this.getStyle(\"width\").getPixels(\"x\");\n                var height = this.getStyle(\"height\").getPixels(\"y\");\n                if (!loaded || !image || !width || !height) {\n                    return;\n                }\n                ctx.save();\n                ctx.translate(x, y);\n                if (this.isSvg) {\n                    var subDocument = document1.canvg.forkString(ctx, this.image, {\n                        ignoreMouse: true,\n                        ignoreAnimation: true,\n                        ignoreDimensions: true,\n                        ignoreClear: true,\n                        offsetX: 0,\n                        offsetY: 0,\n                        scaleWidth: width,\n                        scaleHeight: height\n                    });\n                    subDocument.document.documentElement.parent = this;\n                    void subDocument.render();\n                } else {\n                    var _image = this.image;\n                    document1.setViewBox({\n                        ctx: ctx,\n                        aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n                        width: width,\n                        desiredWidth: _image.width,\n                        height: height,\n                        desiredHeight: _image.height\n                    });\n                    if (this.loaded) {\n                        if (typeof _image.complete === \"undefined\" || _image.complete) {\n                            ctx.drawImage(_image, 0, 0);\n                        }\n                    }\n                }\n                ctx.restore();\n            }\n        },\n        {\n            key: \"getBoundingBox\",\n            value: function getBoundingBox() {\n                var x = this.getAttribute(\"x\").getPixels(\"x\");\n                var y = this.getAttribute(\"y\").getPixels(\"y\");\n                var width = this.getStyle(\"width\").getPixels(\"x\");\n                var height = this.getStyle(\"height\").getPixels(\"y\");\n                return new BoundingBox(x, y, x + width, y + height);\n            }\n        }\n    ]);\n    return ImageElement;\n}(RenderedElement);\nfunction _createSuper$c(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$c();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$c() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar SymbolElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](SymbolElement, _RenderedElement);\n    var _super = _createSuper$c(SymbolElement);\n    function SymbolElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, SymbolElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"symbol\";\n        return _this;\n    }\n    _createClass__default[\"default\"](SymbolElement, [\n        {\n            key: \"render\",\n            value: function render(_) {}\n        }\n    ]);\n    return SymbolElement;\n}(RenderedElement);\nvar SVGFontLoader = /*#__PURE__*/ function() {\n    function SVGFontLoader(document1) {\n        _classCallCheck__default[\"default\"](this, SVGFontLoader);\n        this.document = document1;\n        this.loaded = false;\n        document1.fonts.push(this);\n    }\n    _createClass__default[\"default\"](SVGFontLoader, [\n        {\n            key: \"load\",\n            value: function() {\n                var _load = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee(fontFamily, url) {\n                    var document1, svgDocument, fonts;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    _context.prev = 0;\n                                    document1 = this.document;\n                                    _context.next = 4;\n                                    return document1.canvg.parser.load(url);\n                                case 4:\n                                    svgDocument = _context.sent;\n                                    fonts = svgDocument.getElementsByTagName(\"font\");\n                                    Array.from(fonts).forEach(function(fontNode) {\n                                        var font = document1.createElement(fontNode);\n                                        document1.definitions[fontFamily] = font;\n                                    });\n                                    _context.next = 12;\n                                    break;\n                                case 9:\n                                    _context.prev = 9;\n                                    _context.t0 = _context[\"catch\"](0);\n                                    console.error('Error while loading font \"'.concat(url, '\":'), _context.t0);\n                                case 12:\n                                    this.loaded = true;\n                                case 13:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, this, [\n                        [\n                            0,\n                            9\n                        ]\n                    ]);\n                }));\n                function load(_x, _x2) {\n                    return _load.apply(this, arguments);\n                }\n                return load;\n            }()\n        }\n    ]);\n    return SVGFontLoader;\n}();\nfunction _createSuper$b(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$b();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$b() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar StyleElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](StyleElement, _Element);\n    var _super = _createSuper$b(StyleElement);\n    function StyleElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, StyleElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"style\";\n        var css = compressSpaces(Array.from(node.childNodes) // NEED TEST\n        .map(function(_) {\n            return _.textContent;\n        }).join(\"\").replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, \"\") // remove comments\n        .replace(/@import.*;/g, \"\") // remove imports\n        );\n        var cssDefs = css.split(\"}\");\n        cssDefs.forEach(function(_) {\n            var def = _.trim();\n            if (!def) {\n                return;\n            }\n            var cssParts = def.split(\"{\");\n            var cssClasses = cssParts[0].split(\",\");\n            var cssProps = cssParts[1].split(\";\");\n            cssClasses.forEach(function(_) {\n                var cssClass = _.trim();\n                if (!cssClass) {\n                    return;\n                }\n                var props = document1.styles[cssClass] || {};\n                cssProps.forEach(function(cssProp) {\n                    var prop = cssProp.indexOf(\":\");\n                    var name = cssProp.substr(0, prop).trim();\n                    var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();\n                    if (name && value) {\n                        props[name] = new Property(document1, name, value);\n                    }\n                });\n                document1.styles[cssClass] = props;\n                document1.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\n                if (cssClass === \"@font-face\") {\n                    //  && !nodeEnv\n                    var fontFamily = props[\"font-family\"].getString().replace(/\"|'/g, \"\");\n                    var srcs = props.src.getString().split(\",\");\n                    srcs.forEach(function(src) {\n                        if (src.indexOf('format(\"svg\")') > 0) {\n                            var url = parseExternalUrl(src);\n                            if (url) {\n                                void new SVGFontLoader(document1).load(fontFamily, url);\n                            }\n                        }\n                    });\n                }\n            });\n        });\n        return _this;\n    }\n    return StyleElement;\n}(Element);\nStyleElement.parseExternalUrl = parseExternalUrl;\nfunction _createSuper$a(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$a();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$a() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar UseElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](UseElement, _RenderedElement);\n    var _super = _createSuper$a(UseElement);\n    function UseElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, UseElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"use\";\n        return _this;\n    }\n    _createClass__default[\"default\"](UseElement, [\n        {\n            key: \"setContext\",\n            value: function setContext(ctx) {\n                _get__default[\"default\"](_getPrototypeOf__default[\"default\"](UseElement.prototype), \"setContext\", this).call(this, ctx);\n                var xAttr = this.getAttribute(\"x\");\n                var yAttr = this.getAttribute(\"y\");\n                if (xAttr.hasValue()) {\n                    ctx.translate(xAttr.getPixels(\"x\"), 0);\n                }\n                if (yAttr.hasValue()) {\n                    ctx.translate(0, yAttr.getPixels(\"y\"));\n                }\n            }\n        },\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var element = this.element;\n                if (element) {\n                    element.path(ctx);\n                }\n            }\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                var document1 = this.document, element = this.element;\n                if (element) {\n                    var tempSvg = element;\n                    if (element.type === \"symbol\") {\n                        // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\n                        tempSvg = new SVGElement(document1, null);\n                        tempSvg.attributes.viewBox = new Property(document1, \"viewBox\", element.getAttribute(\"viewBox\").getString());\n                        tempSvg.attributes.preserveAspectRatio = new Property(document1, \"preserveAspectRatio\", element.getAttribute(\"preserveAspectRatio\").getString());\n                        tempSvg.attributes.overflow = new Property(document1, \"overflow\", element.getAttribute(\"overflow\").getString());\n                        tempSvg.children = element.children; // element is still the parent of the children\n                        element.styles.opacity = new Property(document1, \"opacity\", this.calculateOpacity());\n                    }\n                    if (tempSvg.type === \"svg\") {\n                        var widthStyle = this.getStyle(\"width\", false, true);\n                        var heightStyle = this.getStyle(\"height\", false, true); // if symbol or svg, inherit width/height from me\n                        if (widthStyle.hasValue()) {\n                            tempSvg.attributes.width = new Property(document1, \"width\", widthStyle.getString());\n                        }\n                        if (heightStyle.hasValue()) {\n                            tempSvg.attributes.height = new Property(document1, \"height\", heightStyle.getString());\n                        }\n                    }\n                    var oldParent = tempSvg.parent;\n                    tempSvg.parent = this;\n                    tempSvg.render(ctx);\n                    tempSvg.parent = oldParent;\n                }\n            }\n        },\n        {\n            key: \"getBoundingBox\",\n            value: function getBoundingBox(ctx) {\n                var element = this.element;\n                if (element) {\n                    return element.getBoundingBox(ctx);\n                }\n                return null;\n            }\n        },\n        {\n            key: \"elementTransform\",\n            value: function elementTransform() {\n                var document1 = this.document, element = this.element;\n                return Transform.fromElement(document1, element);\n            }\n        },\n        {\n            key: \"element\",\n            get: function get() {\n                if (!this.cachedElement) {\n                    this.cachedElement = this.getHrefAttribute().getDefinition();\n                }\n                return this.cachedElement;\n            }\n        }\n    ]);\n    return UseElement;\n}(RenderedElement);\nfunction _createSuper$9(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$9();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$9() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction imGet(img, x, y, width, _height, rgba) {\n    return img[y * width * 4 + x * 4 + rgba];\n}\nfunction imSet(img, x, y, width, _height, rgba, val) {\n    img[y * width * 4 + x * 4 + rgba] = val;\n}\nfunction m(matrix, i, v) {\n    var mi = matrix[i];\n    return mi * v;\n}\nfunction c(a, m1, m2, m3) {\n    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;\n}\nvar FeColorMatrixElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FeColorMatrixElement, _Element);\n    var _super = _createSuper$9(FeColorMatrixElement);\n    function FeColorMatrixElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FeColorMatrixElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"feColorMatrix\";\n        var matrix = toNumbers(_this.getAttribute(\"values\").getString());\n        switch(_this.getAttribute(\"type\").getString(\"matrix\")){\n            // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement\n            case \"saturate\":\n                {\n                    var s = matrix[0];\n                    /* eslint-disable array-element-newline */ matrix = [\n                        0.213 + 0.787 * s,\n                        0.715 - 0.715 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 + 0.285 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 - 0.715 * s,\n                        0.072 + 0.928 * s,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"hueRotate\":\n                {\n                    var a = matrix[0] * Math.PI / 180.0;\n                    /* eslint-disable array-element-newline */ matrix = [\n                        c(a, 0.213, 0.787, -0.213),\n                        c(a, 0.715, -0.715, -0.715),\n                        c(a, 0.072, -0.072, 0.928),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, 0.143),\n                        c(a, 0.715, 0.285, 0.140),\n                        c(a, 0.072, -0.072, -0.283),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, -0.787),\n                        c(a, 0.715, -0.715, 0.715),\n                        c(a, 0.072, 0.928, 0.072),\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"luminanceToAlpha\":\n                /* eslint-disable array-element-newline */ matrix = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0.2125,\n                    0.7154,\n                    0.0721,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                break;\n        }\n        _this.matrix = matrix;\n        _this.includeOpacity = _this.getAttribute(\"includeOpacity\").hasValue();\n        return _this;\n    }\n    _createClass__default[\"default\"](FeColorMatrixElement, [\n        {\n            key: \"apply\",\n            value: function apply(ctx, _x, _y, width, height) {\n                // assuming x==0 && y==0 for now\n                var includeOpacity = this.includeOpacity, matrix = this.matrix;\n                var srcData = ctx.getImageData(0, 0, width, height);\n                for(var y = 0; y < height; y++){\n                    for(var x = 0; x < width; x++){\n                        var r = imGet(srcData.data, x, y, width, height, 0);\n                        var g = imGet(srcData.data, x, y, width, height, 1);\n                        var b = imGet(srcData.data, x, y, width, height, 2);\n                        var a = imGet(srcData.data, x, y, width, height, 3);\n                        var nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);\n                        var ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);\n                        var nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);\n                        var na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);\n                        if (includeOpacity) {\n                            nr = 0;\n                            ng = 0;\n                            nb = 0;\n                            na *= a / 255;\n                        }\n                        imSet(srcData.data, x, y, width, height, 0, nr);\n                        imSet(srcData.data, x, y, width, height, 1, ng);\n                        imSet(srcData.data, x, y, width, height, 2, nb);\n                        imSet(srcData.data, x, y, width, height, 3, na);\n                    }\n                }\n                ctx.clearRect(0, 0, width, height);\n                ctx.putImageData(srcData, 0, 0);\n            }\n        }\n    ]);\n    return FeColorMatrixElement;\n}(Element);\nfunction _createSuper$8(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$8();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$8() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar MaskElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](MaskElement, _Element);\n    var _super = _createSuper$8(MaskElement);\n    function MaskElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, MaskElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"mask\";\n        return _this;\n    }\n    _createClass__default[\"default\"](MaskElement, [\n        {\n            key: \"apply\",\n            value: function apply(ctx, element) {\n                var document1 = this.document; // render as temp svg\n                var x = this.getAttribute(\"x\").getPixels(\"x\");\n                var y = this.getAttribute(\"y\").getPixels(\"y\");\n                var width = this.getStyle(\"width\").getPixels(\"x\");\n                var height = this.getStyle(\"height\").getPixels(\"y\");\n                if (!width && !height) {\n                    var boundingBox = new BoundingBox();\n                    this.children.forEach(function(child) {\n                        boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n                    });\n                    x = Math.floor(boundingBox.x1);\n                    y = Math.floor(boundingBox.y1);\n                    width = Math.floor(boundingBox.width);\n                    height = Math.floor(boundingBox.height);\n                }\n                var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);\n                var maskCanvas = document1.createCanvas(x + width, y + height);\n                var maskCtx = maskCanvas.getContext(\"2d\");\n                document1.screen.setDefaults(maskCtx);\n                this.renderChildren(maskCtx); // convert mask to alpha with a fake node\n                // TODO: refactor out apply from feColorMatrix\n                new FeColorMatrixElement(document1, {\n                    nodeType: 1,\n                    childNodes: [],\n                    attributes: [\n                        {\n                            nodeName: \"type\",\n                            value: \"luminanceToAlpha\"\n                        },\n                        {\n                            nodeName: \"includeOpacity\",\n                            value: \"true\"\n                        }\n                    ]\n                }).apply(maskCtx, 0, 0, x + width, y + height);\n                var tmpCanvas = document1.createCanvas(x + width, y + height);\n                var tmpCtx = tmpCanvas.getContext(\"2d\");\n                document1.screen.setDefaults(tmpCtx);\n                element.render(tmpCtx);\n                tmpCtx.globalCompositeOperation = \"destination-in\";\n                tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, \"no-repeat\");\n                tmpCtx.fillRect(0, 0, x + width, y + height);\n                ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, \"no-repeat\");\n                ctx.fillRect(0, 0, x + width, y + height); // reassign mask\n                this.restoreStyles(element, ignoredStyles);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(_) {}\n        }\n    ]);\n    return MaskElement;\n}(Element);\nMaskElement.ignoreStyles = [\n    \"mask\",\n    \"transform\",\n    \"clip-path\"\n];\nfunction _createSuper$7(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$7();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$7() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar noop = function noop() {};\nvar ClipPathElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](ClipPathElement, _Element);\n    var _super = _createSuper$7(ClipPathElement);\n    function ClipPathElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, ClipPathElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"clipPath\";\n        return _this;\n    }\n    _createClass__default[\"default\"](ClipPathElement, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var document1 = this.document;\n                var contextProto = Reflect.getPrototypeOf(ctx);\n                var beginPath = ctx.beginPath, closePath = ctx.closePath;\n                if (contextProto) {\n                    contextProto.beginPath = noop;\n                    contextProto.closePath = noop;\n                }\n                Reflect.apply(beginPath, ctx, []);\n                this.children.forEach(function(child) {\n                    if (typeof child.path === \"undefined\") {\n                        return;\n                    }\n                    var transform = typeof child.elementTransform !== \"undefined\" ? child.elementTransform() : null; // handle <use />\n                    if (!transform) {\n                        transform = Transform.fromElement(document1, child);\n                    }\n                    if (transform) {\n                        transform.apply(ctx);\n                    }\n                    child.path(ctx);\n                    if (contextProto) {\n                        contextProto.closePath = closePath;\n                    }\n                    if (transform) {\n                        transform.unapply(ctx);\n                    }\n                });\n                Reflect.apply(closePath, ctx, []);\n                ctx.clip();\n                if (contextProto) {\n                    contextProto.beginPath = beginPath;\n                    contextProto.closePath = closePath;\n                }\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(_) {}\n        }\n    ]);\n    return ClipPathElement;\n}(Element);\nfunction _createSuper$6(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$6();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$6() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FilterElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FilterElement, _Element);\n    var _super = _createSuper$6(FilterElement);\n    function FilterElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FilterElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"filter\";\n        return _this;\n    }\n    _createClass__default[\"default\"](FilterElement, [\n        {\n            key: \"apply\",\n            value: function apply(ctx, element) {\n                // render as temp svg\n                var document1 = this.document, children = this.children;\n                var boundingBox = element.getBoundingBox(ctx);\n                if (!boundingBox) {\n                    return;\n                }\n                var px = 0;\n                var py = 0;\n                children.forEach(function(child) {\n                    var efd = child.extraFilterDistance || 0;\n                    px = Math.max(px, efd);\n                    py = Math.max(py, efd);\n                });\n                var width = Math.floor(boundingBox.width);\n                var height = Math.floor(boundingBox.height);\n                var tmpCanvasWidth = width + 2 * px;\n                var tmpCanvasHeight = height + 2 * py;\n                if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {\n                    return;\n                }\n                var x = Math.floor(boundingBox.x);\n                var y = Math.floor(boundingBox.y);\n                var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);\n                var tmpCanvas = document1.createCanvas(tmpCanvasWidth, tmpCanvasHeight);\n                var tmpCtx = tmpCanvas.getContext(\"2d\");\n                document1.screen.setDefaults(tmpCtx);\n                tmpCtx.translate(-x + px, -y + py);\n                element.render(tmpCtx); // apply filters\n                children.forEach(function(child) {\n                    if (typeof child.apply === \"function\") {\n                        child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);\n                    }\n                }); // render on me\n                ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);\n                this.restoreStyles(element, ignoredStyles);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(_) {}\n        }\n    ]);\n    return FilterElement;\n}(Element);\nFilterElement.ignoreStyles = [\n    \"filter\",\n    \"transform\",\n    \"clip-path\"\n];\nfunction _createSuper$5(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$5();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$5() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FeDropShadowElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FeDropShadowElement, _Element);\n    var _super = _createSuper$5(FeDropShadowElement);\n    function FeDropShadowElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FeDropShadowElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"feDropShadow\";\n        _this.addStylesFromStyleDefinition();\n        return _this;\n    }\n    _createClass__default[\"default\"](FeDropShadowElement, [\n        {\n            key: \"apply\",\n            value: function apply(_, _x, _y, _width, _height) {}\n        }\n    ]);\n    return FeDropShadowElement;\n}(Element);\nfunction _createSuper$4(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$4();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$4() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FeMorphologyElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FeMorphologyElement, _Element);\n    var _super = _createSuper$4(FeMorphologyElement);\n    function FeMorphologyElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FeMorphologyElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"feMorphology\";\n        return _this;\n    }\n    _createClass__default[\"default\"](FeMorphologyElement, [\n        {\n            key: \"apply\",\n            value: function apply(_, _x, _y, _width, _height) {}\n        }\n    ]);\n    return FeMorphologyElement;\n}(Element);\nfunction _createSuper$3(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$3();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$3() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FeCompositeElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FeCompositeElement, _Element);\n    var _super = _createSuper$3(FeCompositeElement);\n    function FeCompositeElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FeCompositeElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"feComposite\";\n        return _this;\n    }\n    _createClass__default[\"default\"](FeCompositeElement, [\n        {\n            key: \"apply\",\n            value: function apply(_, _x, _y, _width, _height) {}\n        }\n    ]);\n    return FeCompositeElement;\n}(Element);\nfunction _createSuper$2(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$2();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$2() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FeGaussianBlurElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FeGaussianBlurElement, _Element);\n    var _super = _createSuper$2(FeGaussianBlurElement);\n    function FeGaussianBlurElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FeGaussianBlurElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"feGaussianBlur\";\n        _this.blurRadius = Math.floor(_this.getAttribute(\"stdDeviation\").getNumber());\n        _this.extraFilterDistance = _this.blurRadius;\n        return _this;\n    }\n    _createClass__default[\"default\"](FeGaussianBlurElement, [\n        {\n            key: \"apply\",\n            value: function apply(ctx, x, y, width, height) {\n                var document1 = this.document, blurRadius = this.blurRadius;\n                var body = document1.window ? document1.window.document.body : null;\n                var canvas = ctx.canvas; // StackBlur requires canvas be on document\n                canvas.id = document1.getUniqueId();\n                if (body) {\n                    canvas.style.display = \"none\";\n                    body.appendChild(canvas);\n                }\n                stackblurCanvas.canvasRGBA(canvas, x, y, width, height, blurRadius);\n                if (body) {\n                    body.removeChild(canvas);\n                }\n            }\n        }\n    ]);\n    return FeGaussianBlurElement;\n}(Element);\nfunction _createSuper$1(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$1() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TitleElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](TitleElement, _Element);\n    var _super = _createSuper$1(TitleElement);\n    function TitleElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TitleElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"title\";\n        return _this;\n    }\n    return TitleElement;\n}(Element);\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar DescElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](DescElement, _Element);\n    var _super = _createSuper(DescElement);\n    function DescElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, DescElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"desc\";\n        return _this;\n    }\n    return DescElement;\n}(Element);\nvar elements = {\n    \"svg\": SVGElement,\n    \"rect\": RectElement,\n    \"circle\": CircleElement,\n    \"ellipse\": EllipseElement,\n    \"line\": LineElement,\n    \"polyline\": PolylineElement,\n    \"polygon\": PolygonElement,\n    \"path\": PathElement,\n    \"pattern\": PatternElement,\n    \"marker\": MarkerElement,\n    \"defs\": DefsElement,\n    \"linearGradient\": LinearGradientElement,\n    \"radialGradient\": RadialGradientElement,\n    \"stop\": StopElement,\n    \"animate\": AnimateElement,\n    \"animateColor\": AnimateColorElement,\n    \"animateTransform\": AnimateTransformElement,\n    \"font\": FontElement,\n    \"font-face\": FontFaceElement,\n    \"missing-glyph\": MissingGlyphElement,\n    \"glyph\": GlyphElement,\n    \"text\": TextElement,\n    \"tspan\": TSpanElement,\n    \"tref\": TRefElement,\n    \"a\": AElement,\n    \"textPath\": TextPathElement,\n    \"image\": ImageElement,\n    \"g\": GElement,\n    \"symbol\": SymbolElement,\n    \"style\": StyleElement,\n    \"use\": UseElement,\n    \"mask\": MaskElement,\n    \"clipPath\": ClipPathElement,\n    \"filter\": FilterElement,\n    \"feDropShadow\": FeDropShadowElement,\n    \"feMorphology\": FeMorphologyElement,\n    \"feComposite\": FeCompositeElement,\n    \"feColorMatrix\": FeColorMatrixElement,\n    \"feGaussianBlur\": FeGaussianBlurElement,\n    \"title\": TitleElement,\n    \"desc\": DescElement\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty__default[\"default\"](target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction createCanvas(width, height) {\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nfunction createImage(_x) {\n    return _createImage.apply(this, arguments);\n}\nfunction _createImage() {\n    _createImage = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee(src) {\n        var anonymousCrossOrigin, image, _args = arguments;\n        return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n            while(1){\n                switch(_context.prev = _context.next){\n                    case 0:\n                        anonymousCrossOrigin = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;\n                        image = document.createElement(\"img\");\n                        if (anonymousCrossOrigin) {\n                            image.crossOrigin = \"Anonymous\";\n                        }\n                        return _context.abrupt(\"return\", new Promise(function(resolve, reject) {\n                            image.onload = function() {\n                                resolve(image);\n                            };\n                            image.onerror = function(_event, _source, _lineno, _colno, error) {\n                                reject(error);\n                            };\n                            image.src = src;\n                        }));\n                    case 4:\n                    case \"end\":\n                        return _context.stop();\n                }\n            }\n        }, _callee);\n    }));\n    return _createImage.apply(this, arguments);\n}\nvar Document = /*#__PURE__*/ function() {\n    function Document(canvg) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$rootEmSize = _ref.rootEmSize, rootEmSize = _ref$rootEmSize === void 0 ? 12 : _ref$rootEmSize, _ref$emSize = _ref.emSize, emSize = _ref$emSize === void 0 ? 12 : _ref$emSize, _ref$createCanvas = _ref.createCanvas, createCanvas = _ref$createCanvas === void 0 ? Document.createCanvas : _ref$createCanvas, _ref$createImage = _ref.createImage, createImage = _ref$createImage === void 0 ? Document.createImage : _ref$createImage, anonymousCrossOrigin = _ref.anonymousCrossOrigin;\n        _classCallCheck__default[\"default\"](this, Document);\n        this.canvg = canvg;\n        this.definitions = Object.create(null);\n        this.styles = Object.create(null);\n        this.stylesSpecificity = Object.create(null);\n        this.images = [];\n        this.fonts = [];\n        this.emSizeStack = [];\n        this.uniqueId = 0;\n        this.screen = canvg.screen;\n        this.rootEmSize = rootEmSize;\n        this.emSize = emSize;\n        this.createCanvas = createCanvas;\n        this.createImage = this.bindCreateImage(createImage, anonymousCrossOrigin);\n        this.screen.wait(this.isImagesLoaded.bind(this));\n        this.screen.wait(this.isFontsLoaded.bind(this));\n    }\n    _createClass__default[\"default\"](Document, [\n        {\n            key: \"bindCreateImage\",\n            value: function bindCreateImage(createImage, anonymousCrossOrigin) {\n                if (typeof anonymousCrossOrigin === \"boolean\") {\n                    return function(source, forceAnonymousCrossOrigin) {\n                        return createImage(source, typeof forceAnonymousCrossOrigin === \"boolean\" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);\n                    };\n                }\n                return createImage;\n            }\n        },\n        {\n            key: \"popEmSize\",\n            value: function popEmSize() {\n                var emSizeStack = this.emSizeStack;\n                emSizeStack.pop();\n            }\n        },\n        {\n            key: \"getUniqueId\",\n            value: function getUniqueId() {\n                return \"canvg\".concat(++this.uniqueId);\n            }\n        },\n        {\n            key: \"isImagesLoaded\",\n            value: function isImagesLoaded() {\n                return this.images.every(function(_) {\n                    return _.loaded;\n                });\n            }\n        },\n        {\n            key: \"isFontsLoaded\",\n            value: function isFontsLoaded() {\n                return this.fonts.every(function(_) {\n                    return _.loaded;\n                });\n            }\n        },\n        {\n            key: \"createDocumentElement\",\n            value: function createDocumentElement(document1) {\n                var documentElement = this.createElement(document1.documentElement);\n                documentElement.root = true;\n                documentElement.addStylesFromStyleDefinition();\n                this.documentElement = documentElement;\n                return documentElement;\n            }\n        },\n        {\n            key: \"createElement\",\n            value: function createElement(node) {\n                var elementType = node.nodeName.replace(/^[^:]+:/, \"\");\n                var ElementType = Document.elementTypes[elementType];\n                if (typeof ElementType !== \"undefined\") {\n                    return new ElementType(this, node);\n                }\n                return new UnknownElement(this, node);\n            }\n        },\n        {\n            key: \"createTextNode\",\n            value: function createTextNode(node) {\n                return new TextNode(this, node);\n            }\n        },\n        {\n            key: \"setViewBox\",\n            value: function setViewBox(config) {\n                this.screen.setViewBox(_objectSpread$1({\n                    document: this\n                }, config));\n            }\n        },\n        {\n            key: \"window\",\n            get: function get() {\n                return this.screen.window;\n            }\n        },\n        {\n            key: \"fetch\",\n            get: function get() {\n                return this.screen.fetch;\n            }\n        },\n        {\n            key: \"ctx\",\n            get: function get() {\n                return this.screen.ctx;\n            }\n        },\n        {\n            key: \"emSize\",\n            get: function get() {\n                var emSizeStack = this.emSizeStack;\n                return emSizeStack[emSizeStack.length - 1];\n            },\n            set: function set(value) {\n                var emSizeStack = this.emSizeStack;\n                emSizeStack.push(value);\n            }\n        }\n    ]);\n    return Document;\n}();\nDocument.createCanvas = createCanvas;\nDocument.createImage = createImage;\nDocument.elementTypes = elements;\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty__default[\"default\"](target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * SVG renderer on canvas.\r\n */ var Canvg = /*#__PURE__*/ function() {\n    /**\r\n   * Main constructor.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG Document.\r\n   * @param options - Rendering options.\r\n   */ function Canvg(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        _classCallCheck__default[\"default\"](this, Canvg);\n        this.parser = new Parser(options);\n        this.screen = new Screen(ctx, options);\n        this.options = options;\n        var document1 = new Document(this, options);\n        var documentElement = document1.createDocumentElement(svg);\n        this.document = document1;\n        this.documentElement = documentElement;\n    }\n    /**\r\n   * Create Canvg instance from SVG source string or URL.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ _createClass__default[\"default\"](Canvg, [\n        {\n            key: \"fork\",\n            /**\r\n     * Create new Canvg instance with inherited options.\r\n     * @param ctx - Rendering context.\r\n     * @param svg - SVG source string or URL.\r\n     * @param options - Rendering options.\r\n     * @returns Canvg instance.\r\n     */ value: function fork(ctx, svg) {\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n            }\n        },\n        {\n            key: \"forkString\",\n            value: function forkString(ctx, svg) {\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n            }\n        },\n        {\n            key: \"ready\",\n            value: function ready() {\n                return this.screen.ready();\n            }\n        },\n        {\n            key: \"isReady\",\n            value: function isReady() {\n                return this.screen.isReady();\n            }\n        },\n        {\n            key: \"render\",\n            value: function() {\n                var _render = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee() {\n                    var options, _args = arguments;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                                    this.start(_objectSpread({\n                                        enableRedraw: true,\n                                        ignoreAnimation: true,\n                                        ignoreMouse: true\n                                    }, options));\n                                    _context.next = 4;\n                                    return this.ready();\n                                case 4:\n                                    this.stop();\n                                case 5:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, this);\n                }));\n                function render() {\n                    return _render.apply(this, arguments);\n                }\n                return render;\n            }()\n        },\n        {\n            key: \"start\",\n            value: function start() {\n                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                var documentElement = this.documentElement, screen = this.screen, baseOptions = this.options;\n                screen.start(documentElement, _objectSpread(_objectSpread({\n                    enableRedraw: true\n                }, baseOptions), options));\n            }\n        },\n        {\n            key: \"stop\",\n            value: function stop() {\n                this.screen.stop();\n            }\n        },\n        {\n            key: \"resize\",\n            value: function resize(width) {\n                var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n                var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                this.documentElement.resize(width, height, preserveAspectRatio);\n            }\n        }\n    ], [\n        {\n            key: \"from\",\n            value: function() {\n                var _from = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee2(ctx, svg) {\n                    var options, parser, svgDocument, _args2 = arguments;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee2$(_context2) {\n                        while(1){\n                            switch(_context2.prev = _context2.next){\n                                case 0:\n                                    options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n                                    parser = new Parser(options);\n                                    _context2.next = 4;\n                                    return parser.parse(svg);\n                                case 4:\n                                    svgDocument = _context2.sent;\n                                    return _context2.abrupt(\"return\", new Canvg(ctx, svgDocument, options));\n                                case 6:\n                                case \"end\":\n                                    return _context2.stop();\n                            }\n                        }\n                    }, _callee2);\n                }));\n                function from(_x, _x2) {\n                    return _from.apply(this, arguments);\n                }\n                return from;\n            }()\n        },\n        {\n            key: \"fromString\",\n            value: function fromString(ctx, svg) {\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var parser = new Parser(options);\n                var svgDocument = parser.parseFromString(svg);\n                return new Canvg(ctx, svgDocument, options);\n            }\n        }\n    ]);\n    return Canvg;\n}();\nexports.AElement = AElement;\nexports.AnimateColorElement = AnimateColorElement;\nexports.AnimateElement = AnimateElement;\nexports.AnimateTransformElement = AnimateTransformElement;\nexports.BoundingBox = BoundingBox;\nexports.CB1 = CB1;\nexports.CB2 = CB2;\nexports.CB3 = CB3;\nexports.CB4 = CB4;\nexports.Canvg = Canvg;\nexports.CircleElement = CircleElement;\nexports.ClipPathElement = ClipPathElement;\nexports.DefsElement = DefsElement;\nexports.DescElement = DescElement;\nexports.Document = Document;\nexports.Element = Element;\nexports.EllipseElement = EllipseElement;\nexports.FeColorMatrixElement = FeColorMatrixElement;\nexports.FeCompositeElement = FeCompositeElement;\nexports.FeDropShadowElement = FeDropShadowElement;\nexports.FeGaussianBlurElement = FeGaussianBlurElement;\nexports.FeMorphologyElement = FeMorphologyElement;\nexports.FilterElement = FilterElement;\nexports.Font = Font;\nexports.FontElement = FontElement;\nexports.FontFaceElement = FontFaceElement;\nexports.GElement = GElement;\nexports.GlyphElement = GlyphElement;\nexports.GradientElement = GradientElement;\nexports.ImageElement = ImageElement;\nexports.LineElement = LineElement;\nexports.LinearGradientElement = LinearGradientElement;\nexports.MarkerElement = MarkerElement;\nexports.MaskElement = MaskElement;\nexports.Matrix = Matrix;\nexports.MissingGlyphElement = MissingGlyphElement;\nexports.Mouse = Mouse;\nexports.PSEUDO_ZERO = PSEUDO_ZERO;\nexports.Parser = Parser;\nexports.PathElement = PathElement;\nexports.PathParser = PathParser;\nexports.PatternElement = PatternElement;\nexports.Point = Point;\nexports.PolygonElement = PolygonElement;\nexports.PolylineElement = PolylineElement;\nexports.Property = Property;\nexports.QB1 = QB1;\nexports.QB2 = QB2;\nexports.QB3 = QB3;\nexports.RadialGradientElement = RadialGradientElement;\nexports.RectElement = RectElement;\nexports.RenderedElement = RenderedElement;\nexports.Rotate = Rotate;\nexports.SVGElement = SVGElement;\nexports.SVGFontLoader = SVGFontLoader;\nexports.Scale = Scale;\nexports.Screen = Screen;\nexports.Skew = Skew;\nexports.SkewX = SkewX;\nexports.SkewY = SkewY;\nexports.StopElement = StopElement;\nexports.StyleElement = StyleElement;\nexports.SymbolElement = SymbolElement;\nexports.TRefElement = TRefElement;\nexports.TSpanElement = TSpanElement;\nexports.TextElement = TextElement;\nexports.TextPathElement = TextPathElement;\nexports.TitleElement = TitleElement;\nexports.Transform = Transform;\nexports.Translate = Translate;\nexports.UnknownElement = UnknownElement;\nexports.UseElement = UseElement;\nexports.ViewPort = ViewPort;\nexports.compressSpaces = compressSpaces;\nexports[\"default\"] = Canvg;\nexports.getSelectorSpecificity = getSelectorSpecificity;\nexports.normalizeAttributeName = normalizeAttributeName;\nexports.normalizeColor = normalizeColor;\nexports.parseExternalUrl = parseExternalUrl;\nexports.presets = index;\nexports.toNumbers = toNumbers;\nexports.trimLeft = trimLeft;\nexports.trimRight = trimRight;\nexports.vectorMagnitude = vectorMagnitude;\nexports.vectorsAngle = vectorsAngle;\nexports.vectorsRatio = vectorsRatio; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2pzIiwic291cmNlcyI6W10sInNvdXJjZXNDb250ZW50IjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3REMsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixJQUFJQyxzQkFBc0JELG1CQUFPQSxDQUFDO0FBQ2xDLElBQUlFLG9CQUFvQkYsbUJBQU9BLENBQUM7QUFDaENBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1IsSUFBSUcsaUJBQWlCSCxtQkFBT0EsQ0FBQztBQUM3QixJQUFJSSxrQkFBa0JKLG1CQUFPQSxDQUFDO0FBQzlCLElBQUlLLGtCQUFrQkwsbUJBQU9BLENBQUM7QUFDOUIsSUFBSU0sZUFBZU4sbUJBQU9BLENBQUM7QUFDM0JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1IsSUFBSU8sd0JBQXdCUCxtQkFBT0EsQ0FBQztBQUNwQ0EsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixJQUFJUSxXQUFXUixtQkFBT0EsQ0FBQztBQUN2QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixJQUFJUyxZQUFZVCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJVSw2QkFBNkJWLG1CQUFPQSxDQUFDO0FBQ3pDLElBQUlXLGtCQUFrQlgsbUJBQU9BLENBQUM7QUFDOUJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FB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QWEsR0FBR2dlO0FBQ2hCaGUsYUFBYSxHQUFHcWU7QUFDaEJyZSxtQkFBbUIsR0FBRzQ4QjtBQUN0QjU4QixvQkFBb0IsR0FBR3FyQztBQUN2QnJyQyxxQkFBcUIsR0FBRzhxQztBQUN4QjlxQyxtQkFBbUIsR0FBRzZoQztBQUN0QjdoQyxvQkFBb0IsR0FBR20xQjtBQUN2Qm4xQixtQkFBbUIsR0FBR214QjtBQUN0Qm54Qix1QkFBdUIsR0FBR3VqQztBQUMxQnZqQyxvQkFBb0IsR0FBRzR3QztBQUN2QjV3QyxpQkFBaUIsR0FBRzBlO0FBQ3BCMWUsaUJBQWlCLEdBQUd5YTtBQUNwQnphLHNCQUFzQixHQUFHcWpCO0FBQ3pCcmpCLGtCQUFrQixHQUFHbXNDO0FBQ3JCbnNDLGdCQUFnQixHQUFHcU47QUFDbkJyTixzQkFBc0IsR0FBRzJFO0FBQ3pCM0Usa0JBQWtCLEdBQUdnekM7QUFDckJoekMsOEJBQThCLEdBQUdpSDtBQUNqQ2pILDhCQUE4QixHQUFHc0Y7QUFDakN0RixzQkFBc0IsR0FBRzZGO0FBQ3pCN0Ysd0JBQXdCLEdBQUcwRjtBQUMzQjFGLGVBQWUsR0FBR3dFO0FBQ2xCeEUsaUJBQWlCLEdBQUdnRjtBQUNwQmhGLGdCQUFnQixHQUFHOEU7QUFDbkI5RSxpQkFBaUIsR0FBRytFO0FBQ3BCL0UsdUJBQXVCLEdBQUdxSTtBQUMxQnJJLG9CQUFvQixHQUFHMkk7QUFDdkIzSSxvQkFBb0IsR0FBR3lJLGNBQ3ZCLDRvVkFBNG9WIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGlvZmxvdy8uL25vZGVfbW9kdWxlcy9jYW52Zy9saWIvaW5kZXguY2pzP2VlMmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qcycpO1xudmFyIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvcicpO1xudmFyIF9hc3luY1RvR2VuZXJhdG9yID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtZmxvYXQuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN0YXJ0cy13aXRoLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcycpO1xudmFyIF9zbGljZWRUb0FycmF5ID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5Jyk7XG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eScpO1xudmFyIF9jbGFzc0NhbGxDaGVjayA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTtcbnZhciBfY3JlYXRlQ2xhc3MgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZXZlcnkuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuZW5kcy13aXRoLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzJyk7XG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgncmFmJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzJyk7XG52YXIgUkdCQ29sb3IgPSByZXF1aXJlKCdyZ2Jjb2xvcicpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcycpO1xudmFyIF9pbmhlcml0cyA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMnKTtcbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybicpO1xudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mcm9tLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZi5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNvbWUuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMnKTtcbnZhciBfdG9Db25zdW1hYmxlQXJyYXkgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5Jyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmV2ZXJzZS5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qcycpO1xudmFyIF9nZXQgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldCcpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGwuanMnKTtcbnZhciBzdmdQYXRoZGF0YSA9IHJlcXVpcmUoJ3N2Zy1wYXRoZGF0YScpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMnKTtcbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5tYXAuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmFwcGx5LmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mLmpzJyk7XG52YXIgc3RhY2tibHVyQ2FudmFzID0gcmVxdWlyZSgnc3RhY2tibHVyLWNhbnZhcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIF9yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9yZWdlbmVyYXRvclJ1bnRpbWUpO1xudmFyIF9hc3luY1RvR2VuZXJhdG9yX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfYXN5bmNUb0dlbmVyYXRvcik7XG52YXIgX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9zbGljZWRUb0FycmF5KTtcbnZhciBfZGVmaW5lUHJvcGVydHlfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9kZWZpbmVQcm9wZXJ0eSk7XG52YXIgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfY2xhc3NDYWxsQ2hlY2spO1xudmFyIF9jcmVhdGVDbGFzc19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koX2NyZWF0ZUNsYXNzKTtcbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KHJlcXVlc3RBbmltYXRpb25GcmFtZSk7XG52YXIgUkdCQ29sb3JfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KFJHQkNvbG9yKTtcbnZhciBfaW5oZXJpdHNfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9pbmhlcml0cyk7XG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKTtcbnZhciBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9nZXRQcm90b3R5cGVPZik7XG52YXIgX3RvQ29uc3VtYWJsZUFycmF5X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfdG9Db25zdW1hYmxlQXJyYXkpO1xudmFyIF9nZXRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9nZXQpO1xudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQpO1xuXG4vKipcclxuICogT3B0aW9ucyBwcmVzZXQgZm9yIGBPZmZzY3JlZW5DYW52YXNgLlxyXG4gKiBAcGFyYW0gY29uZmlnIC0gUHJlc2V0IHJlcXVpcmVtZW50cy5cclxuICogQHBhcmFtIGNvbmZpZy5ET01QYXJzZXIgLSBYTUwvSFRNTCBwYXJzZXIgZnJvbSBzdHJpbmcgaW50byBET00gRG9jdW1lbnQuXHJcbiAqIEByZXR1cm5zIFByZXNldCBvYmplY3QuXHJcbiAqL1xuZnVuY3Rpb24gb2Zmc2NyZWVuKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBET01QYXJzZXJGYWxsYmFjayA9IF9yZWYuRE9NUGFyc2VyO1xuXG4gIHZhciBwcmVzZXQgPSB7XG4gICAgd2luZG93OiBudWxsLFxuICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICBpZ25vcmVNb3VzZTogdHJ1ZSxcbiAgICBET01QYXJzZXI6IERPTVBhcnNlckZhbGxiYWNrLFxuICAgIGNyZWF0ZUNhbnZhczogZnVuY3Rpb24gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgY3JlYXRlSW1hZ2U6IGZ1bmN0aW9uIGNyZWF0ZUltYWdlKHVybCkge1xuICAgICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yX19kZWZhdWx0W1wiZGVmYXVsdFwiXSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlLCBibG9iLCBpbWc7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgYmxvYiA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpbWcgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgaW1nKTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgfSkpKCk7XG4gICAgfVxuICB9O1xuXG4gIGlmICh0eXBlb2YgRE9NUGFyc2VyICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgRE9NUGFyc2VyRmFsbGJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShwcmVzZXQsICdET01QYXJzZXInKTtcbiAgfVxuXG4gIHJldHVybiBwcmVzZXQ7XG59XG5cbi8qKlxyXG4gKiBPcHRpb25zIHByZXNldCBmb3IgYG5vZGUtY2FudmFzYC5cclxuICogQHBhcmFtIGNvbmZpZyAtIFByZXNldCByZXF1aXJlbWVudHMuXHJcbiAqIEBwYXJhbSBjb25maWcuRE9NUGFyc2VyIC0gWE1ML0hUTUwgcGFyc2VyIGZyb20gc3RyaW5nIGludG8gRE9NIERvY3VtZW50LlxyXG4gKiBAcGFyYW0gY29uZmlnLmNhbnZhcyAtIGBub2RlLWNhbnZhc2AgZXhwb3J0cy5cclxuICogQHBhcmFtIGNvbmZpZy5mZXRjaCAtIFdIQVRXRy1jb21wYXRpYmxlIGBmZXRjaGAgZnVuY3Rpb24uXHJcbiAqIEByZXR1cm5zIFByZXNldCBvYmplY3QuXHJcbiAqL1xuZnVuY3Rpb24gbm9kZShfcmVmKSB7XG4gIHZhciBET01QYXJzZXIgPSBfcmVmLkRPTVBhcnNlcixcbiAgICAgIGNhbnZhcyA9IF9yZWYuY2FudmFzLFxuICAgICAgZmV0Y2ggPSBfcmVmLmZldGNoO1xuICByZXR1cm4ge1xuICAgIHdpbmRvdzogbnVsbCxcbiAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgRE9NUGFyc2VyOiBET01QYXJzZXIsXG4gICAgZmV0Y2g6IGZldGNoLFxuICAgIGNyZWF0ZUNhbnZhczogY2FudmFzLmNyZWF0ZUNhbnZhcyxcbiAgICBjcmVhdGVJbWFnZTogY2FudmFzLmxvYWRJbWFnZVxuICB9O1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0b2Zmc2NyZWVuOiBvZmZzY3JlZW4sXG5cdG5vZGU6IG5vZGVcbn0pO1xuXG4vKipcclxuICogSFRNTC1zYWZlIGNvbXByZXNzIHdoaXRlLXNwYWNlcy5cclxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byBjb21wcmVzcy5cclxuICogQHJldHVybnMgU3RyaW5nLlxyXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzU3BhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyg/IVxcdTMwMDApXFxzKy9nbSwgJyAnKTtcbn1cbi8qKlxyXG4gKiBIVE1MLXNhZmUgbGVmdCB0cmltLlxyXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIHRyaW0uXHJcbiAqIEByZXR1cm5zIFN0cmluZy5cclxuICovXG5cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxuIFxcdF0rLywgJycpO1xufVxuLyoqXHJcbiAqIEhUTUwtc2FmZSByaWdodCB0cmltLlxyXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIHRyaW0uXHJcbiAqIEByZXR1cm5zIFN0cmluZy5cclxuICovXG5cbmZ1bmN0aW9uIHRyaW1SaWdodChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxuIFxcdF0rJC8sICcnKTtcbn1cbi8qKlxyXG4gKiBTdHJpbmcgdG8gbnVtYmVycyBhcnJheS5cclxuICogQHBhcmFtIHN0ciAtIE51bWJlcnMgc3RyaW5nLlxyXG4gKiBAcmV0dXJucyBOdW1iZXJzIGFycmF5LlxyXG4gKi9cblxuZnVuY3Rpb24gdG9OdW1iZXJzKHN0cikge1xuICB2YXIgbWF0Y2hlcyA9IChzdHIgfHwgJycpLm1hdGNoKC8tPyhcXGQrKD86XFwuXFxkKig/OltlRV1bKy1dP1xcZCspPyk/fFxcLlxcZCspKD89XFxEfCQpL2dtKSB8fCBbXTtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKHBhcnNlRmxvYXQpO1xufSAvLyBNaWNyb3NvZnQgRWRnZSBmaXhcblxudmFyIGFsbFVwcGVyY2FzZSA9IC9eW0EtWi1dKyQvO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhdHRyaWJ1dGUgbmFtZS5cclxuICogQHBhcmFtIG5hbWUgLSBBdHRyaWJ1dGUgbmFtZS5cclxuICogQHJldHVybnMgTm9ybWFsaXplZCBhdHRyaWJ1dGUgbmFtZS5cclxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUobmFtZSkge1xuICBpZiAoYWxsVXBwZXJjYXNlLnRlc3QobmFtZSkpIHtcbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59XG4vKipcclxuICogUGFyc2UgZXh0ZXJuYWwgVVJMLlxyXG4gKiBAcGFyYW0gdXJsIC0gQ1NTIHVybCBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIFBhcnNlZCBVUkwuXHJcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUV4dGVybmFsVXJsKHVybCkge1xuICAvLyAgICAgICAgICAgICAgICAgICAgICBzaW5nbGUgcXVvdGVzIFsyXVxuICAvLyAgICAgICAgICAgICAgICAgICAgICB2ICAgICAgICAgZG91YmxlIHF1b3RlcyBbM11cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgIHYgICAgICAgICBubyBxdW90ZXMgWzRdXG4gIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgdlxuICB2YXIgdXJsTWF0Y2ggPSAvdXJsXFwoKCcoW14nXSspJ3xcIihbXlwiXSspXCJ8KFteJ1wiKV0rKSlcXCkvLmV4ZWModXJsKSB8fCBbXTtcbiAgcmV0dXJuIHVybE1hdGNoWzJdIHx8IHVybE1hdGNoWzNdIHx8IHVybE1hdGNoWzRdO1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybSBmbG9hdHMgdG8gaW50ZWdlcnMgaW4gcmdiIGNvbG9ycy5cclxuICogQHBhcmFtIGNvbG9yIC0gQ29sb3IgdG8gbm9ybWFsaXplLlxyXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIGNvbG9yLlxyXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3IoY29sb3IpIHtcbiAgaWYgKCFjb2xvci5zdGFydHNXaXRoKCdyZ2InKSkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIHZhciByZ2JQYXJ0cyA9IDM7XG4gIHZhciBub3JtYWxpemVkQ29sb3IgPSBjb2xvci5yZXBsYWNlKC9cXGQrKFxcLlxcZCspPy9nLCBmdW5jdGlvbiAobnVtLCBpc0Zsb2F0KSB7XG4gICAgcmV0dXJuIHJnYlBhcnRzLS0gJiYgaXNGbG9hdCA/IFN0cmluZyhNYXRoLnJvdW5kKHBhcnNlRmxvYXQobnVtKSkpIDogbnVtO1xuICB9KTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWRDb2xvcjtcbn1cblxuLy8gc2xpZ2h0bHkgbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2VlZ2Fuc3RyZWV0L3NwZWNpZmljaXR5L2Jsb2IvbWFzdGVyL3NwZWNpZmljaXR5LmpzXG52YXIgYXR0cmlidXRlUmVnZXggPSAvKFxcW1teXFxdXStcXF0pL2c7XG52YXIgaWRSZWdleCA9IC8oI1teXFxzKz5+Lls6XSspL2c7XG52YXIgY2xhc3NSZWdleCA9IC8oXFwuW15cXHMrPn4uWzpdKykvZztcbnZhciBwc2V1ZG9FbGVtZW50UmVnZXggPSAvKDo6W15cXHMrPn4uWzpdK3w6Zmlyc3QtbGluZXw6Zmlyc3QtbGV0dGVyfDpiZWZvcmV8OmFmdGVyKS9naTtcbnZhciBwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4ID0gLyg6W1xcdy1dK1xcKFteKV0qXFwpKS9naTtcbnZhciBwc2V1ZG9DbGFzc1JlZ2V4ID0gLyg6W15cXHMrPn4uWzpdKykvZztcbnZhciBlbGVtZW50UmVnZXggPSAvKFteXFxzKz5+Lls6XSspL2c7XG5cbmZ1bmN0aW9uIGZpbmRTZWxlY3Rvck1hdGNoKHNlbGVjdG9yLCByZWdleCkge1xuICB2YXIgbWF0Y2hlcyA9IHJlZ2V4LmV4ZWMoc2VsZWN0b3IpO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbc2VsZWN0b3IsIDBdO1xuICB9XG5cbiAgcmV0dXJuIFtzZWxlY3Rvci5yZXBsYWNlKHJlZ2V4LCAnICcpLCBtYXRjaGVzLmxlbmd0aF07XG59XG4vKipcclxuICogTWVhc3VyZSBzZWxlY3RvciBzcGVjaWZpY2l0eS5cclxuICogQHBhcmFtIHNlbGVjdG9yIC0gU2VsZWN0b3IgdG8gbWVhc3VyZS5cclxuICogQHJldHVybnMgU3BlY2lmaWNpdHkuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoc2VsZWN0b3IpIHtcbiAgdmFyIHNwZWNpZmljaXR5ID0gWzAsIDAsIDBdO1xuICB2YXIgY3VycmVudFNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvOm5vdFxcKChbXildKilcXCkvZywgJyAgICAgJDEgJykucmVwbGFjZSgve1tcXHNcXFNdKi9nbSwgJyAnKTtcbiAgdmFyIGRlbHRhID0gMDtcblxuICB2YXIgX2ZpbmRTZWxlY3Rvck1hdGNoID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBhdHRyaWJ1dGVSZWdleCk7XG5cbiAgdmFyIF9maW5kU2VsZWN0b3JNYXRjaDIgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2ZpbmRTZWxlY3Rvck1hdGNoLCAyKTtcblxuICBjdXJyZW50U2VsZWN0b3IgPSBfZmluZFNlbGVjdG9yTWF0Y2gyWzBdO1xuICBkZWx0YSA9IF9maW5kU2VsZWN0b3JNYXRjaDJbMV07XG4gIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuXG4gIHZhciBfZmluZFNlbGVjdG9yTWF0Y2gzID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBpZFJlZ2V4KTtcblxuICB2YXIgX2ZpbmRTZWxlY3Rvck1hdGNoNCA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfZmluZFNlbGVjdG9yTWF0Y2gzLCAyKTtcblxuICBjdXJyZW50U2VsZWN0b3IgPSBfZmluZFNlbGVjdG9yTWF0Y2g0WzBdO1xuICBkZWx0YSA9IF9maW5kU2VsZWN0b3JNYXRjaDRbMV07XG4gIHNwZWNpZmljaXR5WzBdICs9IGRlbHRhO1xuXG4gIHZhciBfZmluZFNlbGVjdG9yTWF0Y2g1ID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBjbGFzc1JlZ2V4KTtcblxuICB2YXIgX2ZpbmRTZWxlY3Rvck1hdGNoNiA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfZmluZFNlbGVjdG9yTWF0Y2g1LCAyKTtcblxuICBjdXJyZW50U2VsZWN0b3IgPSBfZmluZFNlbGVjdG9yTWF0Y2g2WzBdO1xuICBkZWx0YSA9IF9maW5kU2VsZWN0b3JNYXRjaDZbMV07XG4gIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuXG4gIHZhciBfZmluZFNlbGVjdG9yTWF0Y2g3ID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBwc2V1ZG9FbGVtZW50UmVnZXgpO1xuXG4gIHZhciBfZmluZFNlbGVjdG9yTWF0Y2g4ID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9maW5kU2VsZWN0b3JNYXRjaDcsIDIpO1xuXG4gIGN1cnJlbnRTZWxlY3RvciA9IF9maW5kU2VsZWN0b3JNYXRjaDhbMF07XG4gIGRlbHRhID0gX2ZpbmRTZWxlY3Rvck1hdGNoOFsxXTtcbiAgc3BlY2lmaWNpdHlbMl0gKz0gZGVsdGE7XG5cbiAgdmFyIF9maW5kU2VsZWN0b3JNYXRjaDkgPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIHBzZXVkb0NsYXNzV2l0aEJyYWNrZXRzUmVnZXgpO1xuXG4gIHZhciBfZmluZFNlbGVjdG9yTWF0Y2gxMCA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfZmluZFNlbGVjdG9yTWF0Y2g5LCAyKTtcblxuICBjdXJyZW50U2VsZWN0b3IgPSBfZmluZFNlbGVjdG9yTWF0Y2gxMFswXTtcbiAgZGVsdGEgPSBfZmluZFNlbGVjdG9yTWF0Y2gxMFsxXTtcbiAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG5cbiAgdmFyIF9maW5kU2VsZWN0b3JNYXRjaDExID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBwc2V1ZG9DbGFzc1JlZ2V4KTtcblxuICB2YXIgX2ZpbmRTZWxlY3Rvck1hdGNoMTIgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2ZpbmRTZWxlY3Rvck1hdGNoMTEsIDIpO1xuXG4gIGN1cnJlbnRTZWxlY3RvciA9IF9maW5kU2VsZWN0b3JNYXRjaDEyWzBdO1xuICBkZWx0YSA9IF9maW5kU2VsZWN0b3JNYXRjaDEyWzFdO1xuICBzcGVjaWZpY2l0eVsxXSArPSBkZWx0YTtcbiAgY3VycmVudFNlbGVjdG9yID0gY3VycmVudFNlbGVjdG9yLnJlcGxhY2UoL1sqXFxzKz5+XS9nLCAnICcpLnJlcGxhY2UoL1sjLl0vZywgJyAnKTtcblxuICB2YXIgX2ZpbmRTZWxlY3Rvck1hdGNoMTMgPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGVsZW1lbnRSZWdleCk7XG5cbiAgdmFyIF9maW5kU2VsZWN0b3JNYXRjaDE0ID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9maW5kU2VsZWN0b3JNYXRjaDEzLCAyKTtcblxuICBjdXJyZW50U2VsZWN0b3IgPSBfZmluZFNlbGVjdG9yTWF0Y2gxNFswXTtcbiAgZGVsdGEgPSBfZmluZFNlbGVjdG9yTWF0Y2gxNFsxXTtcbiAgLy8gbGd0bSBbanMvdXNlbGVzcy1hc3NpZ25tZW50LXRvLWxvY2FsXVxuICBzcGVjaWZpY2l0eVsyXSArPSBkZWx0YTtcbiAgcmV0dXJuIHNwZWNpZmljaXR5LmpvaW4oJycpO1xufVxuXG52YXIgUFNFVURPX1pFUk8gPSAuMDAwMDAwMDE7XG4vKipcclxuICogVmVjdG9yIG1hZ25pdHVkZS5cclxuICogQHBhcmFtIHZcclxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cclxuICovXG5cbmZ1bmN0aW9uIHZlY3Rvck1hZ25pdHVkZSh2KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codlswXSwgMikgKyBNYXRoLnBvdyh2WzFdLCAyKSk7XG59XG4vKipcclxuICogUmF0aW8gYmV0d2VlbiB0d28gdmVjdG9ycy5cclxuICogQHBhcmFtIHVcclxuICogQHBhcmFtIHZcclxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cclxuICovXG5cbmZ1bmN0aW9uIHZlY3RvcnNSYXRpbyh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodmVjdG9yTWFnbml0dWRlKHUpICogdmVjdG9yTWFnbml0dWRlKHYpKTtcbn1cbi8qKlxyXG4gKiBBbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzLlxyXG4gKiBAcGFyYW0gdVxyXG4gKiBAcGFyYW0gdlxyXG4gKiBAcmV0dXJucyBOdW1iZXIgcmVzdWx0LlxyXG4gKi9cblxuZnVuY3Rpb24gdmVjdG9yc0FuZ2xlKHUsIHYpIHtcbiAgcmV0dXJuICh1WzBdICogdlsxXSA8IHVbMV0gKiB2WzBdID8gLTEgOiAxKSAqIE1hdGguYWNvcyh2ZWN0b3JzUmF0aW8odSwgdikpO1xufVxuZnVuY3Rpb24gQ0IxKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIENCMih0KSB7XG4gIHJldHVybiAzICogdCAqIHQgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gQ0IzKHQpIHtcbiAgcmV0dXJuIDMgKiB0ICogKDEgLSB0KSAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBDQjQodCkge1xuICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gUUIxKHQpIHtcbiAgcmV0dXJuIHQgKiB0O1xufVxuZnVuY3Rpb24gUUIyKHQpIHtcbiAgcmV0dXJuIDIgKiB0ICogKDEgLSB0KTtcbn1cbmZ1bmN0aW9uIFFCMyh0KSB7XG4gIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcbn1cblxudmFyIFByb3BlcnR5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBQcm9wZXJ0eSk7XG5cbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5pc05vcm1hbGl6ZWRDb2xvciA9IGZhbHNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShQcm9wZXJ0eSwgW3tcbiAgICBrZXk6IFwic3BsaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXQoKSB7XG4gICAgICB2YXIgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnICc7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgIG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICByZXR1cm4gY29tcHJlc3NTcGFjZXModGhpcy5nZXRTdHJpbmcoKSkudHJpbSgpLnNwbGl0KHNlcGFyYXRvcikubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5KGRvY3VtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzVmFsdWUoemVyb0lzVmFsdWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICcnICYmICh6ZXJvSXNWYWx1ZSB8fCB2YWx1ZSAhPT0gMCkgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdHJpbmcocmVnZXhwKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG5cbiAgICAgIGlmICghcmVzdWx0IHx8ICFyZWdleHApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2V4cC50ZXN0KHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNVcmxEZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVXJsRGVmaW5pdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU3RyaW5nKC9edXJsXFwoLyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUGl4ZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGl4ZWxzKCkge1xuICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuXG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSBhc1N0cmluZy5lbmRzV2l0aCgncHgnKTpcbiAgICAgICAgY2FzZSAvXlswLTldKyQvLnRlc3QoYXNTdHJpbmcpOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKGRlZikge1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TnVtYmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bWJlcihkZWYpIHtcbiAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZGVmKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAgIGlmICh0aGlzLmlzU3RyaW5nKC8lJC8pKSB7XG4gICAgICAgIG4gLz0gMTAwLjA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RyaW5nKGRlZikge1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMudmFsdWUgPT09ICd1bmRlZmluZWQnID8gJycgOiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTdHJpbmcoZGVmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29sb3IoZGVmKSB7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmdldFN0cmluZyhkZWYpO1xuXG4gICAgICBpZiAodGhpcy5pc05vcm1hbGl6ZWRDb2xvcikge1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNOb3JtYWxpemVkQ29sb3IgPSB0cnVlO1xuICAgICAgY29sb3IgPSBub3JtYWxpemVDb2xvcihjb2xvcik7XG4gICAgICB0aGlzLnZhbHVlID0gY29sb3I7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERwaVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREcGkoKSB7XG4gICAgICByZXR1cm4gOTYuMDsgLy8gVE9ETzogY29tcHV0ZT9cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LnJvb3RFbVNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZW1TaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVbml0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVbml0cygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0cmluZygpLnJlcGxhY2UoL1swLTkuLV0vZywgJycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQaXhlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGl4ZWxzKGF4aXNPcklzRm9udFNpemUpIHtcbiAgICAgIHZhciBwcm9jZXNzUGVyY2VudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3JlZiA9IHR5cGVvZiBheGlzT3JJc0ZvbnRTaXplID09PSAnYm9vbGVhbicgPyBbdW5kZWZpbmVkLCBheGlzT3JJc0ZvbnRTaXplXSA6IFtheGlzT3JJc0ZvbnRTaXplXSxcbiAgICAgICAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfcmVmLCAyKSxcbiAgICAgICAgICBheGlzID0gX3JlZjJbMF0sXG4gICAgICAgICAgaXNGb250U2l6ZSA9IF9yZWYyWzFdO1xuXG4gICAgICB2YXIgdmlld1BvcnQgPSB0aGlzLmRvY3VtZW50LnNjcmVlbi52aWV3UG9ydDtcblxuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdm1pbiQvKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogTWF0aC5taW4odmlld1BvcnQuY29tcHV0ZVNpemUoJ3gnKSwgdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKSk7XG5cbiAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92bWF4JC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwLjAgKiBNYXRoLm1heCh2aWV3UG9ydC5jb21wdXRlU2l6ZSgneCcpLCB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneScpKTtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3Z3JC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwLjAgKiB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneCcpO1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdmgkLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAuMCAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd5Jyk7XG5cbiAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9yZW0kLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldFJlbSgpO1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZW0kLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldEVtKCk7XG5cbiAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9leCQvKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RW0oKSAvIDIuMDtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3B4JC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpO1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcHQkLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpICogKDEuMCAvIDcyLjApO1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcGMkLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAxNTtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2NtJC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKSAvIDIuNTQ7XG5cbiAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9tbSQvKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyNS40O1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvaW4kLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpO1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvJSQvKSAmJiBpc0ZvbnRTaXplOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRFbSgpO1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvJSQvKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKGF4aXMpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmdldE51bWJlcigpO1xuXG4gICAgICAgICAgICBpZiAocHJvY2Vzc1BlcmNlbnQgJiYgbiA8IDEuMCkge1xuICAgICAgICAgICAgICByZXR1cm4gbiAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKGF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1pbGxpc2Vjb25kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNaWxsaXNlY29uZHMoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNTdHJpbmcoL21zJC8pKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIDEwMDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJhZGlhbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFkaWFucygpIHtcbiAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9kZWckLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDE4MC4wKTtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2dyYWQkLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDIwMC4wKTtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3JhZCQvKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgIHZhciBhc1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7XG4gICAgICB2YXIgbmFtZSA9IC8jKFteKSdcIl0rKS8uZXhlYyhhc1N0cmluZyk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgbmFtZSA9IGFzU3RyaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5kZWZpbml0aW9uc1tuYW1lXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmlsbFN0eWxlRGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWxsU3R5bGVEZWZpbml0aW9uKGVsZW1lbnQsIG9wYWNpdHkpIHtcbiAgICAgIHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oKTtcblxuICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIGdyYWRpZW50XG5cblxuICAgICAgaWYgKHR5cGVvZiBkZWYuY3JlYXRlR3JhZGllbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGRlZi5jcmVhdGVHcmFkaWVudCh0aGlzLmRvY3VtZW50LmN0eCwgZWxlbWVudCwgb3BhY2l0eSk7XG4gICAgICB9IC8vIHBhdHRlcm5cblxuXG4gICAgICBpZiAodHlwZW9mIGRlZi5jcmVhdGVQYXR0ZXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChkZWYuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB2YXIgcGF0dGVyblRyYW5zZm9ybSA9IGRlZi5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nKTtcbiAgICAgICAgICBkZWYgPSBkZWYuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICAgIGlmIChwYXR0ZXJuVHJhbnNmb3JtLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGRlZi5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nLCB0cnVlKS5zZXRWYWx1ZShwYXR0ZXJuVHJhbnNmb3JtLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmLmNyZWF0ZVBhdHRlcm4odGhpcy5kb2N1bWVudC5jdHgsIGVsZW1lbnQsIG9wYWNpdHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGV4dEJhc2VsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHRCYXNlbGluZSgpIHtcbiAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvcGVydHkudGV4dEJhc2VsaW5lTWFwcGluZ1t0aGlzLmdldFN0cmluZygpXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkT3BhY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0Q29sb3IoKTtcbiAgICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgY29tbWFzID0gMDsgLy8gU2ltdWxhdGUgb2xkIFJHQkNvbG9yIHZlcnNpb24sIHdoaWNoIGNhbid0IHBhcnNlIHJnYmEuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlW2ldID09PSAnLCcpIHtcbiAgICAgICAgICBjb21tYXMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tYXMgPT09IDMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3BhY2l0eS5oYXNWYWx1ZSgpICYmIHRoaXMuaXNTdHJpbmcoKSAmJiBjb21tYXMgIT09IDMpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbmV3IFJHQkNvbG9yX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGNvbG9yLm9rKSB7XG4gICAgICAgICAgY29sb3IuYWxwaGEgPSBvcGFjaXR5LmdldE51bWJlcigpO1xuICAgICAgICAgIHZhbHVlID0gY29sb3IudG9SR0JBKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCB0aGlzLm5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJlbXB0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbXB0eShkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ0VNUFRZJywgJycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQcm9wZXJ0eTtcbn0oKTtcblByb3BlcnR5LnRleHRCYXNlbGluZU1hcHBpbmcgPSB7XG4gICdiYXNlbGluZSc6ICdhbHBoYWJldGljJyxcbiAgJ2JlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICd0ZXh0LWJlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICdtaWRkbGUnOiAnbWlkZGxlJyxcbiAgJ2NlbnRyYWwnOiAnbWlkZGxlJyxcbiAgJ2FmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgJ3RleHQtYWZ0ZXItZWRnZSc6ICdib3R0b20nLFxuICAnaWRlb2dyYXBoaWMnOiAnaWRlb2dyYXBoaWMnLFxuICAnYWxwaGFiZXRpYyc6ICdhbHBoYWJldGljJyxcbiAgJ2hhbmdpbmcnOiAnaGFuZ2luZycsXG4gICdtYXRoZW1hdGljYWwnOiAnYWxwaGFiZXRpYydcbn07XG5cbnZhciBWaWV3UG9ydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpZXdQb3J0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVmlld1BvcnQpO1xuXG4gICAgdGhpcy52aWV3UG9ydHMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVmlld1BvcnQsIFt7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy52aWV3UG9ydHMgPSBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q3VycmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMudmlld1BvcnRzLnB1c2goe1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQ3VycmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDdXJyZW50KCkge1xuICAgICAgdGhpcy52aWV3UG9ydHMucG9wKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEN1cnJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VycmVudCgpIHtcbiAgICAgIHZhciB2aWV3UG9ydHMgPSB0aGlzLnZpZXdQb3J0cztcbiAgICAgIHJldHVybiB2aWV3UG9ydHNbdmlld1BvcnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wdXRlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlU2l6ZShkKSB7XG4gICAgICBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCA9PT0gJ3gnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCA9PT0gJ3knKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLndpZHRoLCAyKSArIE1hdGgucG93KHRoaXMuaGVpZ2h0LCAyKSkgLyBNYXRoLnNxcnQoMik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50KCkud2lkdGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudCgpLmhlaWdodDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmlld1BvcnQ7XG59KCk7XG5cbnZhciBQb2ludCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFBvaW50KTtcblxuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUG9pbnQsIFt7XG4gICAga2V5OiBcImFuZ2xlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5nbGVUbyhwb2ludCkge1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIocG9pbnQueSAtIHRoaXMueSwgcG9pbnQueCAtIHRoaXMueCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5VHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgeSA9IHRoaXMueTtcbiAgICAgIHZhciB4cCA9IHggKiB0cmFuc2Zvcm1bMF0gKyB5ICogdHJhbnNmb3JtWzJdICsgdHJhbnNmb3JtWzRdO1xuICAgICAgdmFyIHlwID0geCAqIHRyYW5zZm9ybVsxXSArIHkgKiB0cmFuc2Zvcm1bM10gKyB0cmFuc2Zvcm1bNV07XG4gICAgICB0aGlzLnggPSB4cDtcbiAgICAgIHRoaXMueSA9IHlwO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKHBvaW50KSB7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgICB2YXIgX3RvTnVtYmVycyA9IHRvTnVtYmVycyhwb2ludCksXG4gICAgICAgICAgX3RvTnVtYmVyczIgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3RvTnVtYmVycywgMiksXG4gICAgICAgICAgX3RvTnVtYmVyczIkID0gX3RvTnVtYmVyczJbMF0sXG4gICAgICAgICAgeCA9IF90b051bWJlcnMyJCA9PT0gdm9pZCAwID8gZGVmYXVsdFZhbHVlIDogX3RvTnVtYmVyczIkLFxuICAgICAgICAgIF90b051bWJlcnMyJDIgPSBfdG9OdW1iZXJzMlsxXSxcbiAgICAgICAgICB5ID0gX3RvTnVtYmVyczIkMiA9PT0gdm9pZCAwID8gZGVmYXVsdFZhbHVlIDogX3RvTnVtYmVyczIkMjtcblxuICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVNjYWxlKHNjYWxlKSB7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuXG4gICAgICB2YXIgX3RvTnVtYmVyczMgPSB0b051bWJlcnMoc2NhbGUpLFxuICAgICAgICAgIF90b051bWJlcnM0ID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF90b051bWJlcnMzLCAyKSxcbiAgICAgICAgICBfdG9OdW1iZXJzNCQgPSBfdG9OdW1iZXJzNFswXSxcbiAgICAgICAgICB4ID0gX3RvTnVtYmVyczQkID09PSB2b2lkIDAgPyBkZWZhdWx0VmFsdWUgOiBfdG9OdW1iZXJzNCQsXG4gICAgICAgICAgX3RvTnVtYmVyczQkMiA9IF90b051bWJlcnM0WzFdLFxuICAgICAgICAgIHkgPSBfdG9OdW1iZXJzNCQyID09PSB2b2lkIDAgPyB4IDogX3RvTnVtYmVyczQkMjtcblxuICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdG9OdW1iZXJzKHBhdGgpO1xuICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICB2YXIgcGF0aFBvaW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIHBhdGhQb2ludHMucHVzaChuZXcgUG9pbnQocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoUG9pbnRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb2ludDtcbn0oKTtcblxudmFyIE1vdXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTW91c2Uoc2NyZWVuKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBNb3VzZSk7XG5cbiAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICB0aGlzLndvcmtpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG5cbiAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuXG4gICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oTW91c2UsIFt7XG4gICAga2V5OiBcImlzV29ya2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1dvcmtpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy53b3JraW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIGlmICh0aGlzLndvcmtpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2NyZWVuID0gdGhpcy5zY3JlZW4sXG4gICAgICAgICAgb25DbGljayA9IHRoaXMub25DbGljayxcbiAgICAgICAgICBvbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmU7XG4gICAgICB2YXIgY2FudmFzID0gc2NyZWVuLmN0eC5jYW52YXM7XG4gICAgICBjYW52YXMub25jbGljayA9IG9uQ2xpY2s7XG4gICAgICBjYW52YXMub25tb3VzZW1vdmUgPSBvbk1vdXNlTW92ZTtcbiAgICAgIHRoaXMud29ya2luZyA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIGlmICghdGhpcy53b3JraW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuc2NyZWVuLmN0eC5jYW52YXM7XG4gICAgICB0aGlzLndvcmtpbmcgPSBmYWxzZTtcbiAgICAgIGNhbnZhcy5vbmNsaWNrID0gbnVsbDtcbiAgICAgIGNhbnZhcy5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc0V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNFdmVudHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy53b3JraW5nICYmIHRoaXMuZXZlbnRzLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJ1bkV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW5FdmVudHMoKSB7XG4gICAgICBpZiAoIXRoaXMud29ya2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMuc2NyZWVuLFxuICAgICAgICAgIGV2ZW50cyA9IHRoaXMuZXZlbnRzLFxuICAgICAgICAgIGV2ZW50RWxlbWVudHMgPSB0aGlzLmV2ZW50RWxlbWVudHM7XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jdHguY2FudmFzLnN0eWxlO1xuXG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmLCBpKSB7XG4gICAgICAgIHZhciBydW4gPSBfcmVmLnJ1bjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBldmVudEVsZW1lbnRzW2ldO1xuXG4gICAgICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgICAgcnVuKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIGRvbmUgcnVubmluZywgY2xlYXJcblxuICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1BhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tQYXRoKGVsZW1lbnQsIGN0eCkge1xuICAgICAgaWYgKCF0aGlzLndvcmtpbmcgfHwgIWN0eCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBldmVudHMgPSB0aGlzLmV2ZW50cyxcbiAgICAgICAgICBldmVudEVsZW1lbnRzID0gdGhpcy5ldmVudEVsZW1lbnRzO1xuICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyLCBpKSB7XG4gICAgICAgIHZhciB4ID0gX3JlZjIueCxcbiAgICAgICAgICAgIHkgPSBfcmVmMi55O1xuXG4gICAgICAgIGlmICghZXZlbnRFbGVtZW50c1tpXSAmJiBjdHguaXNQb2ludEluUGF0aCAmJiBjdHguaXNQb2ludEluUGF0aCh4LCB5KSkge1xuICAgICAgICAgIGV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0JvdW5kaW5nQm94KGVsZW1lbnQsIGJvdW5kaW5nQm94KSB7XG4gICAgICBpZiAoIXRoaXMud29ya2luZyB8fCAhYm91bmRpbmdCb3gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHMsXG4gICAgICAgICAgZXZlbnRFbGVtZW50cyA9IHRoaXMuZXZlbnRFbGVtZW50cztcbiAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMywgaSkge1xuICAgICAgICB2YXIgeCA9IF9yZWYzLngsXG4gICAgICAgICAgICB5ID0gX3JlZjMueTtcblxuICAgICAgICBpZiAoIWV2ZW50RWxlbWVudHNbaV0gJiYgYm91bmRpbmdCb3guaXNQb2ludEluQm94KHgsIHkpKSB7XG4gICAgICAgICAgZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBYWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBYWSh4LCB5KSB7XG4gICAgICB2YXIgX3RoaXMkc2NyZWVuID0gdGhpcy5zY3JlZW4sXG4gICAgICAgICAgd2luZG93ID0gX3RoaXMkc2NyZWVuLndpbmRvdyxcbiAgICAgICAgICBjdHggPSBfdGhpcyRzY3JlZW4uY3R4O1xuICAgICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgdmFyIGVsZW1lbnQgPSBjdHguY2FudmFzO1xuXG4gICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICBwb2ludC54IC09IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgcG9pbnQueSAtPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAod2luZG93LnNjcm9sbFgpIHtcbiAgICAgICAgcG9pbnQueCArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpbmRvdy5zY3JvbGxZKSB7XG4gICAgICAgIHBvaW50LnkgKz0gd2luZG93LnNjcm9sbFk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMkbWFwWFkgPSB0aGlzLm1hcFhZKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpLFxuICAgICAgICAgIHggPSBfdGhpcyRtYXBYWS54LFxuICAgICAgICAgIHkgPSBfdGhpcyRtYXBYWS55O1xuXG4gICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ29uY2xpY2snLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBydW46IGZ1bmN0aW9uIHJ1bihldmVudFRhcmdldCkge1xuICAgICAgICAgIGlmIChldmVudFRhcmdldC5vbkNsaWNrKSB7XG4gICAgICAgICAgICBldmVudFRhcmdldC5vbkNsaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZU1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyRtYXBYWTIgPSB0aGlzLm1hcFhZKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpLFxuICAgICAgICAgIHggPSBfdGhpcyRtYXBYWTIueCxcbiAgICAgICAgICB5ID0gX3RoaXMkbWFwWFkyLnk7XG5cbiAgICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnb25tb3VzZW1vdmUnLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBydW46IGZ1bmN0aW9uIHJ1bihldmVudFRhcmdldCkge1xuICAgICAgICAgIGlmIChldmVudFRhcmdldC5vbk1vdXNlTW92ZSkge1xuICAgICAgICAgICAgZXZlbnRUYXJnZXQub25Nb3VzZU1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNb3VzZTtcbn0oKTtcblxudmFyIGRlZmF1bHRXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IG51bGw7XG52YXIgZGVmYXVsdEZldGNoJDEgPSB0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnID8gZmV0Y2guYmluZCh1bmRlZmluZWQpIC8vIGBmZXRjaGAgZGVwZW5kcyBvbiBjb250ZXh0OiBgc29tZU9iamVjdC5mZXRjaCguLi4pYCB3aWxsIHRocm93IGVycm9yLlxuOiBudWxsO1xuXG52YXIgU2NyZWVuID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NyZWVuKGN0eCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgX3JlZiRmZXRjaCA9IF9yZWYuZmV0Y2gsXG4gICAgICAgIGZldGNoID0gX3JlZiRmZXRjaCA9PT0gdm9pZCAwID8gZGVmYXVsdEZldGNoJDEgOiBfcmVmJGZldGNoLFxuICAgICAgICBfcmVmJHdpbmRvdyA9IF9yZWYud2luZG93LFxuICAgICAgICB3aW5kb3cgPSBfcmVmJHdpbmRvdyA9PT0gdm9pZCAwID8gZGVmYXVsdFdpbmRvdyA6IF9yZWYkd2luZG93O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBTY3JlZW4pO1xuXG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5GUkFNRVJBVEUgPSAzMDtcbiAgICB0aGlzLk1BWF9WSVJUVUFMX1BJWEVMUyA9IDMwMDAwO1xuICAgIHRoaXMuQ0xJRU5UX1dJRFRIID0gODAwO1xuICAgIHRoaXMuQ0xJRU5UX0hFSUdIVCA9IDYwMDtcbiAgICB0aGlzLnZpZXdQb3J0ID0gbmV3IFZpZXdQb3J0KCk7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZSh0aGlzKTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICB0aGlzLndhaXRzID0gW107XG4gICAgdGhpcy5mcmFtZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmlzUmVhZHlMb2NrID0gZmFsc2U7XG4gICAgdGhpcy5pc0ZpcnN0UmVuZGVyID0gdHJ1ZTtcbiAgICB0aGlzLmludGVydmFsSWQgPSBudWxsO1xuICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oU2NyZWVuLCBbe1xuICAgIGtleTogXCJ3YWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhaXQoY2hlY2tlcikge1xuICAgICAgdGhpcy53YWl0cy5wdXNoKGNoZWNrZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWFkeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgICAgaWYgKCF0aGlzLnJlYWR5UHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJlYWR5UHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNSZWFkeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1JlYWR5KCkge1xuICAgICAgaWYgKHRoaXMuaXNSZWFkeUxvY2spIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1JlYWR5TG9jayA9IHRoaXMud2FpdHMuZXZlcnkoZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIF8oKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNSZWFkeUxvY2spIHtcbiAgICAgICAgdGhpcy53YWl0cyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVSZWFkeSkge1xuICAgICAgICAgIHRoaXMucmVzb2x2ZVJlYWR5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1JlYWR5TG9jayA9IGlzUmVhZHlMb2NrO1xuICAgICAgcmV0dXJuIGlzUmVhZHlMb2NrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXREZWZhdWx0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREZWZhdWx0cyhjdHgpIHtcbiAgICAgIC8vIGluaXRpYWwgdmFsdWVzIGFuZCBkZWZhdWx0c1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICBjdHgubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgICAgY3R4Lm1pdGVyTGltaXQgPSA0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWaWV3Qm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZpZXdCb3goX3JlZjIpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IF9yZWYyLmRvY3VtZW50LFxuICAgICAgICAgIGN0eCA9IF9yZWYyLmN0eCxcbiAgICAgICAgICBhc3BlY3RSYXRpbyA9IF9yZWYyLmFzcGVjdFJhdGlvLFxuICAgICAgICAgIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgICAgZGVzaXJlZFdpZHRoID0gX3JlZjIuZGVzaXJlZFdpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodCxcbiAgICAgICAgICBkZXNpcmVkSGVpZ2h0ID0gX3JlZjIuZGVzaXJlZEhlaWdodCxcbiAgICAgICAgICBfcmVmMiRtaW5YID0gX3JlZjIubWluWCxcbiAgICAgICAgICBtaW5YID0gX3JlZjIkbWluWCA9PT0gdm9pZCAwID8gMCA6IF9yZWYyJG1pblgsXG4gICAgICAgICAgX3JlZjIkbWluWSA9IF9yZWYyLm1pblksXG4gICAgICAgICAgbWluWSA9IF9yZWYyJG1pblkgPT09IHZvaWQgMCA/IDAgOiBfcmVmMiRtaW5ZLFxuICAgICAgICAgIHJlZlggPSBfcmVmMi5yZWZYLFxuICAgICAgICAgIHJlZlkgPSBfcmVmMi5yZWZZLFxuICAgICAgICAgIF9yZWYyJGNsaXAgPSBfcmVmMi5jbGlwLFxuICAgICAgICAgIGNsaXAgPSBfcmVmMiRjbGlwID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJGNsaXAsXG4gICAgICAgICAgX3JlZjIkY2xpcFggPSBfcmVmMi5jbGlwWCxcbiAgICAgICAgICBjbGlwWCA9IF9yZWYyJGNsaXBYID09PSB2b2lkIDAgPyAwIDogX3JlZjIkY2xpcFgsXG4gICAgICAgICAgX3JlZjIkY2xpcFkgPSBfcmVmMi5jbGlwWSxcbiAgICAgICAgICBjbGlwWSA9IF9yZWYyJGNsaXBZID09PSB2b2lkIDAgPyAwIDogX3JlZjIkY2xpcFk7XG4gICAgICAvLyBhc3BlY3QgcmF0aW8gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZVxuICAgICAgdmFyIGNsZWFuQXNwZWN0UmF0aW8gPSBjb21wcmVzc1NwYWNlcyhhc3BlY3RSYXRpbykucmVwbGFjZSgvXmRlZmVyXFxzLywgJycpOyAvLyBpZ25vcmUgZGVmZXJcblxuICAgICAgdmFyIF9jbGVhbkFzcGVjdFJhdGlvJHNwbCA9IGNsZWFuQXNwZWN0UmF0aW8uc3BsaXQoJyAnKSxcbiAgICAgICAgICBfY2xlYW5Bc3BlY3RSYXRpbyRzcGwyID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9jbGVhbkFzcGVjdFJhdGlvJHNwbCwgMiksXG4gICAgICAgICAgYXNwZWN0UmF0aW9BbGlnbiA9IF9jbGVhbkFzcGVjdFJhdGlvJHNwbDJbMF0sXG4gICAgICAgICAgYXNwZWN0UmF0aW9NZWV0T3JTbGljZSA9IF9jbGVhbkFzcGVjdFJhdGlvJHNwbDJbMV07XG5cbiAgICAgIHZhciBhbGlnbiA9IGFzcGVjdFJhdGlvQWxpZ24gfHwgJ3hNaWRZTWlkJztcbiAgICAgIHZhciBtZWV0T3JTbGljZSA9IGFzcGVjdFJhdGlvTWVldE9yU2xpY2UgfHwgJ21lZXQnOyAvLyBjYWxjdWxhdGUgc2NhbGVcblxuICAgICAgdmFyIHNjYWxlWCA9IHdpZHRoIC8gZGVzaXJlZFdpZHRoO1xuICAgICAgdmFyIHNjYWxlWSA9IGhlaWdodCAvIGRlc2lyZWRIZWlnaHQ7XG4gICAgICB2YXIgc2NhbGVNaW4gPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XG4gICAgICB2YXIgc2NhbGVNYXggPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgICB2YXIgZmluYWxEZXNpcmVkV2lkdGggPSBkZXNpcmVkV2lkdGg7XG4gICAgICB2YXIgZmluYWxEZXNpcmVkSGVpZ2h0ID0gZGVzaXJlZEhlaWdodDtcblxuICAgICAgaWYgKG1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgZmluYWxEZXNpcmVkV2lkdGggKj0gc2NhbGVNaW47XG4gICAgICAgIGZpbmFsRGVzaXJlZEhlaWdodCAqPSBzY2FsZU1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZXRPclNsaWNlID09PSAnc2xpY2UnKSB7XG4gICAgICAgIGZpbmFsRGVzaXJlZFdpZHRoICo9IHNjYWxlTWF4O1xuICAgICAgICBmaW5hbERlc2lyZWRIZWlnaHQgKj0gc2NhbGVNYXg7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWZYUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3JlZlgnLCByZWZYKTtcbiAgICAgIHZhciByZWZZUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3JlZlknLCByZWZZKTtcbiAgICAgIHZhciBoYXNSZWZzID0gcmVmWFByb3AuaGFzVmFsdWUoKSAmJiByZWZZUHJvcC5oYXNWYWx1ZSgpO1xuXG4gICAgICBpZiAoaGFzUmVmcykge1xuICAgICAgICBjdHgudHJhbnNsYXRlKC1zY2FsZU1pbiAqIHJlZlhQcm9wLmdldFBpeGVscygneCcpLCAtc2NhbGVNaW4gKiByZWZZUHJvcC5nZXRQaXhlbHMoJ3knKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgIHZhciBzY2FsZWRDbGlwWCA9IHNjYWxlTWluICogY2xpcFg7XG4gICAgICAgIHZhciBzY2FsZWRDbGlwWSA9IHNjYWxlTWluICogY2xpcFk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhzY2FsZWRDbGlwWCwgc2NhbGVkQ2xpcFkpO1xuICAgICAgICBjdHgubGluZVRvKHdpZHRoLCBzY2FsZWRDbGlwWSk7XG4gICAgICAgIGN0eC5saW5lVG8od2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8oc2NhbGVkQ2xpcFgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNSZWZzKSB7XG4gICAgICAgIHZhciBpc01lZXRNaW5ZID0gbWVldE9yU2xpY2UgPT09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PT0gc2NhbGVZO1xuICAgICAgICB2YXIgaXNTbGljZU1heFkgPSBtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PT0gc2NhbGVZO1xuICAgICAgICB2YXIgaXNNZWV0TWluWCA9IG1lZXRPclNsaWNlID09PSAnbWVldCcgJiYgc2NhbGVNaW4gPT09IHNjYWxlWDtcbiAgICAgICAgdmFyIGlzU2xpY2VNYXhYID0gbWVldE9yU2xpY2UgPT09ICdzbGljZScgJiYgc2NhbGVNYXggPT09IHNjYWxlWDtcblxuICAgICAgICBpZiAoYWxpZ24uc3RhcnRzV2l0aCgneE1pZCcpICYmIChpc01lZXRNaW5ZIHx8IGlzU2xpY2VNYXhZKSkge1xuICAgICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGggLyAyLjAgLSBmaW5hbERlc2lyZWRXaWR0aCAvIDIuMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxpZ24uZW5kc1dpdGgoJ1lNaWQnKSAmJiAoaXNNZWV0TWluWCB8fCBpc1NsaWNlTWF4WCkpIHtcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGhlaWdodCAvIDIuMCAtIGZpbmFsRGVzaXJlZEhlaWdodCAvIDIuMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxpZ24uc3RhcnRzV2l0aCgneE1heCcpICYmIChpc01lZXRNaW5ZIHx8IGlzU2xpY2VNYXhZKSkge1xuICAgICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGggLSBmaW5hbERlc2lyZWRXaWR0aCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxpZ24uZW5kc1dpdGgoJ1lNYXgnKSAmJiAoaXNNZWV0TWluWCB8fCBpc1NsaWNlTWF4WCkpIHtcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGhlaWdodCAtIGZpbmFsRGVzaXJlZEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc2NhbGVcblxuXG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSBhbGlnbiA9PT0gJ25vbmUnOlxuICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBtZWV0T3JTbGljZSA9PT0gJ21lZXQnOlxuICAgICAgICAgIGN0eC5zY2FsZShzY2FsZU1pbiwgc2NhbGVNaW4pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgbWVldE9yU2xpY2UgPT09ICdzbGljZSc6XG4gICAgICAgICAgY3R4LnNjYWxlKHNjYWxlTWF4LCBzY2FsZU1heCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIHRyYW5zbGF0ZVxuXG5cbiAgICAgIGN0eC50cmFuc2xhdGUoLW1pblgsIC1taW5ZKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoZWxlbWVudCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgICBfcmVmMyRlbmFibGVSZWRyYXcgPSBfcmVmMy5lbmFibGVSZWRyYXcsXG4gICAgICAgICAgZW5hYmxlUmVkcmF3ID0gX3JlZjMkZW5hYmxlUmVkcmF3ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGVuYWJsZVJlZHJhdyxcbiAgICAgICAgICBfcmVmMyRpZ25vcmVNb3VzZSA9IF9yZWYzLmlnbm9yZU1vdXNlLFxuICAgICAgICAgIGlnbm9yZU1vdXNlID0gX3JlZjMkaWdub3JlTW91c2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjMkaWdub3JlTW91c2UsXG4gICAgICAgICAgX3JlZjMkaWdub3JlQW5pbWF0aW9uID0gX3JlZjMuaWdub3JlQW5pbWF0aW9uLFxuICAgICAgICAgIGlnbm9yZUFuaW1hdGlvbiA9IF9yZWYzJGlnbm9yZUFuaW1hdGlvbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRpZ25vcmVBbmltYXRpb24sXG4gICAgICAgICAgX3JlZjMkaWdub3JlRGltZW5zaW9uID0gX3JlZjMuaWdub3JlRGltZW5zaW9ucyxcbiAgICAgICAgICBpZ25vcmVEaW1lbnNpb25zID0gX3JlZjMkaWdub3JlRGltZW5zaW9uID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGlnbm9yZURpbWVuc2lvbixcbiAgICAgICAgICBfcmVmMyRpZ25vcmVDbGVhciA9IF9yZWYzLmlnbm9yZUNsZWFyLFxuICAgICAgICAgIGlnbm9yZUNsZWFyID0gX3JlZjMkaWdub3JlQ2xlYXIgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjMkaWdub3JlQ2xlYXIsXG4gICAgICAgICAgZm9yY2VSZWRyYXcgPSBfcmVmMy5mb3JjZVJlZHJhdyxcbiAgICAgICAgICBzY2FsZVdpZHRoID0gX3JlZjMuc2NhbGVXaWR0aCxcbiAgICAgICAgICBzY2FsZUhlaWdodCA9IF9yZWYzLnNjYWxlSGVpZ2h0LFxuICAgICAgICAgIG9mZnNldFggPSBfcmVmMy5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFkgPSBfcmVmMy5vZmZzZXRZO1xuXG4gICAgICB2YXIgRlJBTUVSQVRFID0gdGhpcy5GUkFNRVJBVEUsXG4gICAgICAgICAgbW91c2UgPSB0aGlzLm1vdXNlO1xuICAgICAgdmFyIGZyYW1lRHVyYXRpb24gPSAxMDAwIC8gRlJBTUVSQVRFO1xuICAgICAgdGhpcy5mcmFtZUR1cmF0aW9uID0gZnJhbWVEdXJhdGlvbjtcbiAgICAgIHRoaXMucmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgX3RoaXMucmVzb2x2ZVJlYWR5ID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoZWxlbWVudCwgaWdub3JlRGltZW5zaW9ucywgaWdub3JlQ2xlYXIsIHNjYWxlV2lkdGgsIHNjYWxlSGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbmFibGVSZWRyYXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIHZhciB0aGVuID0gbm93O1xuICAgICAgdmFyIGRlbHRhID0gMDtcblxuICAgICAgdmFyIHRpY2sgPSBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBkZWx0YSA9IG5vdyAtIHRoZW47XG5cbiAgICAgICAgaWYgKGRlbHRhID49IGZyYW1lRHVyYXRpb24pIHtcbiAgICAgICAgICB0aGVuID0gbm93IC0gZGVsdGEgJSBmcmFtZUR1cmF0aW9uO1xuXG4gICAgICAgICAgaWYgKF90aGlzLnNob3VsZFVwZGF0ZShpZ25vcmVBbmltYXRpb24sIGZvcmNlUmVkcmF3KSkge1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG5cbiAgICAgICAgICAgIG1vdXNlLnJ1bkV2ZW50cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmludGVydmFsSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRpY2spO1xuICAgICAgfTtcblxuICAgICAgaWYgKCFpZ25vcmVNb3VzZSkge1xuICAgICAgICBtb3VzZS5zdGFydCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmludGVydmFsSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRpY2spO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY2FuY2VsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubW91c2Uuc3RvcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaG91bGRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdWxkVXBkYXRlKGlnbm9yZUFuaW1hdGlvbiwgZm9yY2VSZWRyYXcpIHtcbiAgICAgIC8vIG5lZWQgdXBkYXRlIGZyb20gYW5pbWF0aW9ucz9cbiAgICAgIGlmICghaWdub3JlQW5pbWF0aW9uKSB7XG4gICAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gdGhpcy5mcmFtZUR1cmF0aW9uO1xuICAgICAgICB2YXIgc2hvdWxkVXBkYXRlID0gdGhpcy5hbmltYXRpb25zLnJlZHVjZShmdW5jdGlvbiAoc2hvdWxkVXBkYXRlLCBhbmltYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnVwZGF0ZShmcmFtZUR1cmF0aW9uKSB8fCBzaG91bGRVcGRhdGU7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbmVlZCB1cGRhdGUgZnJvbSByZWRyYXc/XG5cblxuICAgICAgaWYgKHR5cGVvZiBmb3JjZVJlZHJhdyA9PT0gJ2Z1bmN0aW9uJyAmJiBmb3JjZVJlZHJhdygpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNSZWFkeUxvY2sgJiYgdGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIG5lZWQgdXBkYXRlIGZyb20gbW91c2UgZXZlbnRzP1xuXG5cbiAgICAgIGlmICh0aGlzLm1vdXNlLmhhc0V2ZW50cygpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoZWxlbWVudCwgaWdub3JlRGltZW5zaW9ucywgaWdub3JlQ2xlYXIsIHNjYWxlV2lkdGgsIHNjYWxlSGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICB2YXIgQ0xJRU5UX1dJRFRIID0gdGhpcy5DTElFTlRfV0lEVEgsXG4gICAgICAgICAgQ0xJRU5UX0hFSUdIVCA9IHRoaXMuQ0xJRU5UX0hFSUdIVCxcbiAgICAgICAgICB2aWV3UG9ydCA9IHRoaXMudmlld1BvcnQsXG4gICAgICAgICAgY3R4ID0gdGhpcy5jdHgsXG4gICAgICAgICAgaXNGaXJzdFJlbmRlciA9IHRoaXMuaXNGaXJzdFJlbmRlcjtcbiAgICAgIHZhciBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgICAgdmlld1BvcnQuY2xlYXIoKTtcblxuICAgICAgaWYgKGNhbnZhcy53aWR0aCAmJiBjYW52YXMuaGVpZ2h0KSB7XG4gICAgICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoQ0xJRU5UX1dJRFRILCBDTElFTlRfSEVJR0hUKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd3aWR0aCcpO1xuICAgICAgdmFyIGhlaWdodFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG5cbiAgICAgIGlmICghaWdub3JlRGltZW5zaW9ucyAmJiAoaXNGaXJzdFJlbmRlciB8fCB0eXBlb2Ygc2NhbGVXaWR0aCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHNjYWxlSGVpZ2h0ICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgLy8gc2V0IGNhbnZhcyBzaXplXG4gICAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aFN0eWxlLmdldFBpeGVscygneCcpO1xuXG4gICAgICAgICAgaWYgKGNhbnZhcy5zdHlsZSkge1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoY2FudmFzLndpZHRoLCBcInB4XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodFN0eWxlLmdldFBpeGVscygneScpO1xuXG4gICAgICAgICAgaWYgKGNhbnZhcy5zdHlsZSkge1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGNhbnZhcy5oZWlnaHQsIFwicHhcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjV2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGggfHwgY2FudmFzLndpZHRoO1xuICAgICAgdmFyIGNIZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0IHx8IGNhbnZhcy5oZWlnaHQ7XG5cbiAgICAgIGlmIChpZ25vcmVEaW1lbnNpb25zICYmIHdpZHRoU3R5bGUuaGFzVmFsdWUoKSAmJiBoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNXaWR0aCA9IHdpZHRoU3R5bGUuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNIZWlnaHQgPSBoZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIH1cblxuICAgICAgdmlld1BvcnQuc2V0Q3VycmVudChjV2lkdGgsIGNIZWlnaHQpO1xuXG4gICAgICBpZiAodHlwZW9mIG9mZnNldFggPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4JywgdHJ1ZSkuc2V0VmFsdWUob2Zmc2V0WCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0WSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3knLCB0cnVlKS5zZXRWYWx1ZShvZmZzZXRZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzY2FsZVdpZHRoID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc2NhbGVIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciB2aWV3Qm94ID0gdG9OdW1iZXJzKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB2YXIgeFJhdGlvID0gMDtcbiAgICAgICAgdmFyIHlSYXRpbyA9IDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2FsZVdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhciBfd2lkdGhTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3dpZHRoJyk7XG5cbiAgICAgICAgICBpZiAoX3dpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgeFJhdGlvID0gX3dpZHRoU3R5bGUuZ2V0UGl4ZWxzKCd4JykgLyBzY2FsZVdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHZpZXdCb3hbMl0pKSB7XG4gICAgICAgICAgICB4UmF0aW8gPSB2aWV3Qm94WzJdIC8gc2NhbGVXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNjYWxlSGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhciBfaGVpZ2h0U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdoZWlnaHQnKTtcblxuICAgICAgICAgIGlmIChfaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgeVJhdGlvID0gX2hlaWdodFN0eWxlLmdldFBpeGVscygneScpIC8gc2NhbGVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIGlmICghaXNOYU4odmlld0JveFszXSkpIHtcbiAgICAgICAgICAgIHlSYXRpbyA9IHZpZXdCb3hbM10gLyBzY2FsZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXhSYXRpbykge1xuICAgICAgICAgIHhSYXRpbyA9IHlSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgheVJhdGlvKSB7XG4gICAgICAgICAgeVJhdGlvID0geFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSkuc2V0VmFsdWUoc2NhbGVXaWR0aCk7XG4gICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0cnVlKS5zZXRWYWx1ZShzY2FsZUhlaWdodCk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1TdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIHRydWUsIHRydWUpO1xuICAgICAgICB0cmFuc2Zvcm1TdHlsZS5zZXRWYWx1ZShcIlwiLmNvbmNhdCh0cmFuc2Zvcm1TdHlsZS5nZXRTdHJpbmcoKSwgXCIgc2NhbGUoXCIpLmNvbmNhdCgxLjAgLyB4UmF0aW8sIFwiLCBcIikuY29uY2F0KDEuMCAvIHlSYXRpbywgXCIpXCIpKTtcbiAgICAgIH0gLy8gY2xlYXIgYW5kIHJlbmRlclxuXG5cbiAgICAgIGlmICghaWdub3JlQ2xlYXIpIHtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjV2lkdGgsIGNIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnJlbmRlcihjdHgpO1xuXG4gICAgICBpZiAoaXNGaXJzdFJlbmRlcikge1xuICAgICAgICB0aGlzLmlzRmlyc3RSZW5kZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2NyZWVuO1xufSgpO1xuU2NyZWVuLmRlZmF1bHRXaW5kb3cgPSBkZWZhdWx0V2luZG93O1xuU2NyZWVuLmRlZmF1bHRGZXRjaCA9IGRlZmF1bHRGZXRjaCQxO1xuXG52YXIgZGVmYXVsdEZldGNoID0gU2NyZWVuLmRlZmF1bHRGZXRjaDtcbnZhciBEZWZhdWx0RE9NUGFyc2VyID0gdHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgPyBET01QYXJzZXIgOiBudWxsO1xuXG52YXIgUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgX3JlZiRmZXRjaCA9IF9yZWYuZmV0Y2gsXG4gICAgICAgIGZldGNoID0gX3JlZiRmZXRjaCA9PT0gdm9pZCAwID8gZGVmYXVsdEZldGNoIDogX3JlZiRmZXRjaCxcbiAgICAgICAgX3JlZiRET01QYXJzZXIgPSBfcmVmLkRPTVBhcnNlcixcbiAgICAgICAgRE9NUGFyc2VyID0gX3JlZiRET01QYXJzZXIgPT09IHZvaWQgMCA/IERlZmF1bHRET01QYXJzZXIgOiBfcmVmJERPTVBhcnNlcjtcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgUGFyc2VyKTtcblxuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgICB0aGlzLkRPTVBhcnNlciA9IERPTVBhcnNlcjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUGFyc2VyLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3BhcnNlID0gX2FzeW5jVG9HZW5lcmF0b3JfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlc291cmNlKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghcmVzb3VyY2Uuc3RhcnRzV2l0aCgnPCcpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5wYXJzZUZyb21TdHJpbmcocmVzb3VyY2UpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0aGlzLmxvYWQocmVzb3VyY2UpKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlKF94KSB7XG4gICAgICAgIHJldHVybiBfcGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlRnJvbVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUZyb21TdHJpbmcoeG1sKSB7XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IHRoaXMuRE9NUGFyc2VyKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrRG9jdW1lbnQocGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsICdpbWFnZS9zdmcreG1sJykpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrRG9jdW1lbnQocGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsICd0ZXh0L3htbCcpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tEb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0RvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgICB2YXIgcGFyc2VyRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKVswXTtcblxuICAgICAgaWYgKHBhcnNlckVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwYXJzZXJFcnJvci50ZXh0Q29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xvYWQgPSBfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHVybCkge1xuICAgICAgICB2YXIgcmVzcG9uc2UsIHhtbDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaCh1cmwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB4bWwgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB0aGlzLnBhcnNlRnJvbVN0cmluZyh4bWwpKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbG9hZChfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9sb2FkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2FkO1xuICAgIH0oKVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhcnNlcjtcbn0oKTtcblxudmFyIFRyYW5zbGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyYW5zbGF0ZShfLCBwb2ludCkge1xuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVHJhbnNsYXRlKTtcblxuICAgIHRoaXMudHlwZSA9ICd0cmFuc2xhdGUnO1xuICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgIHRoaXMucG9pbnQgPSBQb2ludC5wYXJzZShwb2ludCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFRyYW5zbGF0ZSwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoY3R4KSB7XG4gICAgICB2YXIgX3RoaXMkcG9pbnQgPSB0aGlzLnBvaW50LFxuICAgICAgICAgIHggPSBfdGhpcyRwb2ludC54LFxuICAgICAgICAgIHkgPSBfdGhpcyRwb2ludC55O1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4IHx8IDAuMCwgeSB8fCAwLjApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYXBwbHkoY3R4KSB7XG4gICAgICB2YXIgX3RoaXMkcG9pbnQyID0gdGhpcy5wb2ludCxcbiAgICAgICAgICB4ID0gX3RoaXMkcG9pbnQyLngsXG4gICAgICAgICAgeSA9IF90aGlzJHBvaW50Mi55O1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtMS4wICogeCB8fCAwLjAsIC0xLjAgKiB5IHx8IDAuMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5VG9Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciBfdGhpcyRwb2ludDMgPSB0aGlzLnBvaW50LFxuICAgICAgICAgIHggPSBfdGhpcyRwb2ludDMueCxcbiAgICAgICAgICB5ID0gX3RoaXMkcG9pbnQzLnk7XG4gICAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgeCB8fCAwLjAsIHkgfHwgMC4wXSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyYW5zbGF0ZTtcbn0oKTtcblxudmFyIFJvdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvdGF0ZShkb2N1bWVudCwgcm90YXRlLCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFJvdGF0ZSk7XG5cbiAgICB0aGlzLnR5cGUgPSAncm90YXRlJztcbiAgICB0aGlzLmFuZ2xlID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblggPSBudWxsO1xuICAgIHRoaXMub3JpZ2luWSA9IG51bGw7XG4gICAgdGhpcy5jeCA9IDA7XG4gICAgdGhpcy5jeSA9IDA7XG4gICAgdmFyIG51bWJlcnMgPSB0b051bWJlcnMocm90YXRlKTtcbiAgICB0aGlzLmFuZ2xlID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnYW5nbGUnLCBudW1iZXJzWzBdKTtcbiAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICAgIHRoaXMuY3ggPSBudW1iZXJzWzFdIHx8IDA7XG4gICAgdGhpcy5jeSA9IG51bWJlcnNbMl0gfHwgMDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUm90YXRlLCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShjdHgpIHtcbiAgICAgIHZhciBjeCA9IHRoaXMuY3gsXG4gICAgICAgICAgY3kgPSB0aGlzLmN5LFxuICAgICAgICAgIG9yaWdpblggPSB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgb3JpZ2luWSA9IHRoaXMub3JpZ2luWSxcbiAgICAgICAgICBhbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgICB2YXIgdHggPSBjeCArIG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgdHkgPSBjeSArIG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICBjdHgucm90YXRlKGFuZ2xlLmdldFJhZGlhbnMoKSk7XG4gICAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5hcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmFwcGx5KGN0eCkge1xuICAgICAgdmFyIGN4ID0gdGhpcy5jeCxcbiAgICAgICAgICBjeSA9IHRoaXMuY3ksXG4gICAgICAgICAgb3JpZ2luWCA9IHRoaXMub3JpZ2luWCxcbiAgICAgICAgICBvcmlnaW5ZID0gdGhpcy5vcmlnaW5ZLFxuICAgICAgICAgIGFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgICAgIHZhciB0eCA9IGN4ICsgb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciB0eSA9IGN5ICsgb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgIGN0eC5yb3RhdGUoLTEuMCAqIGFuZ2xlLmdldFJhZGlhbnMoKSk7XG4gICAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlUb1BvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgICAgdmFyIGN4ID0gdGhpcy5jeCxcbiAgICAgICAgICBjeSA9IHRoaXMuY3ksXG4gICAgICAgICAgYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgICAgdmFyIHJhZCA9IGFuZ2xlLmdldFJhZGlhbnMoKTtcbiAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCBjeCB8fCAwLjAsIGN5IHx8IDAuMCAvLyB0aGlzLnAueVxuICAgICAgXSk7XG4gICAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbTWF0aC5jb3MocmFkKSwgTWF0aC5zaW4ocmFkKSwgLU1hdGguc2luKHJhZCksIE1hdGguY29zKHJhZCksIDAsIDBdKTtcbiAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCAtY3ggfHwgMC4wLCAtY3kgfHwgMC4wIC8vIC10aGlzLnAueVxuICAgICAgXSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJvdGF0ZTtcbn0oKTtcblxudmFyIFNjYWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NhbGUoXywgc2NhbGUsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgU2NhbGUpO1xuXG4gICAgdGhpcy50eXBlID0gJ3NjYWxlJztcbiAgICB0aGlzLnNjYWxlID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblggPSBudWxsO1xuICAgIHRoaXMub3JpZ2luWSA9IG51bGw7XG4gICAgdmFyIHNjYWxlU2l6ZSA9IFBvaW50LnBhcnNlU2NhbGUoc2NhbGUpOyAvLyBXb3JrYXJvdW5kIGZvciBub2RlLWNhbnZhc1xuXG4gICAgaWYgKHNjYWxlU2l6ZS54ID09PSAwIHx8IHNjYWxlU2l6ZS55ID09PSAwKSB7XG4gICAgICBzY2FsZVNpemUueCA9IFBTRVVET19aRVJPO1xuICAgICAgc2NhbGVTaXplLnkgPSBQU0VVRE9fWkVSTztcbiAgICB9XG5cbiAgICB0aGlzLnNjYWxlID0gc2NhbGVTaXplO1xuICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICB0aGlzLm9yaWdpblkgPSB0cmFuc2Zvcm1PcmlnaW5bMV07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFNjYWxlLCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShjdHgpIHtcbiAgICAgIHZhciBfdGhpcyRzY2FsZSA9IHRoaXMuc2NhbGUsXG4gICAgICAgICAgeCA9IF90aGlzJHNjYWxlLngsXG4gICAgICAgICAgeSA9IF90aGlzJHNjYWxlLnksXG4gICAgICAgICAgb3JpZ2luWCA9IHRoaXMub3JpZ2luWCxcbiAgICAgICAgICBvcmlnaW5ZID0gdGhpcy5vcmlnaW5ZO1xuICAgICAgdmFyIHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICBjdHguc2NhbGUoeCwgeSB8fCB4KTtcbiAgICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYXBwbHkoY3R4KSB7XG4gICAgICB2YXIgX3RoaXMkc2NhbGUyID0gdGhpcy5zY2FsZSxcbiAgICAgICAgICB4ID0gX3RoaXMkc2NhbGUyLngsXG4gICAgICAgICAgeSA9IF90aGlzJHNjYWxlMi55LFxuICAgICAgICAgIG9yaWdpblggPSB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgb3JpZ2luWSA9IHRoaXMub3JpZ2luWTtcbiAgICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgY3R4LnNjYWxlKDEuMCAvIHgsIDEuMCAvIHkgfHwgeCk7XG4gICAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlUb1BvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgICAgdmFyIF90aGlzJHNjYWxlMyA9IHRoaXMuc2NhbGUsXG4gICAgICAgICAgeCA9IF90aGlzJHNjYWxlMy54LFxuICAgICAgICAgIHkgPSBfdGhpcyRzY2FsZTMueTtcbiAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFt4IHx8IDAuMCwgMCwgMCwgeSB8fCAwLjAsIDAsIDBdKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2NhbGU7XG59KCk7XG5cbnZhciBNYXRyaXggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXRyaXgoXywgbWF0cml4LCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIE1hdHJpeCk7XG5cbiAgICB0aGlzLnR5cGUgPSAnbWF0cml4JztcbiAgICB0aGlzLm1hdHJpeCA9IFtdO1xuICAgIHRoaXMub3JpZ2luWCA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5ZID0gbnVsbDtcbiAgICB0aGlzLm1hdHJpeCA9IHRvTnVtYmVycyhtYXRyaXgpO1xuICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICB0aGlzLm9yaWdpblkgPSB0cmFuc2Zvcm1PcmlnaW5bMV07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKE1hdHJpeCwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoY3R4KSB7XG4gICAgICB2YXIgb3JpZ2luWCA9IHRoaXMub3JpZ2luWCxcbiAgICAgICAgICBvcmlnaW5ZID0gdGhpcy5vcmlnaW5ZLFxuICAgICAgICAgIG1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgICAgdmFyIHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICBjdHgudHJhbnNmb3JtKG1hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0pO1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5hcHBseShjdHgpIHtcbiAgICAgIHZhciBvcmlnaW5YID0gdGhpcy5vcmlnaW5YLFxuICAgICAgICAgIG9yaWdpblkgPSB0aGlzLm9yaWdpblksXG4gICAgICAgICAgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gICAgICB2YXIgYSA9IG1hdHJpeFswXTtcbiAgICAgIHZhciBiID0gbWF0cml4WzJdO1xuICAgICAgdmFyIGMgPSBtYXRyaXhbNF07XG4gICAgICB2YXIgZCA9IG1hdHJpeFsxXTtcbiAgICAgIHZhciBlID0gbWF0cml4WzNdO1xuICAgICAgdmFyIGYgPSBtYXRyaXhbNV07XG4gICAgICB2YXIgZyA9IDAuMDtcbiAgICAgIHZhciBoID0gMC4wO1xuICAgICAgdmFyIGkgPSAxLjA7XG4gICAgICB2YXIgZGV0ID0gMSAvIChhICogKGUgKiBpIC0gZiAqIGgpIC0gYiAqIChkICogaSAtIGYgKiBnKSArIGMgKiAoZCAqIGggLSBlICogZykpO1xuICAgICAgdmFyIHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICBjdHgudHJhbnNmb3JtKGRldCAqIChlICogaSAtIGYgKiBoKSwgZGV0ICogKGYgKiBnIC0gZCAqIGkpLCBkZXQgKiAoYyAqIGggLSBiICogaSksIGRldCAqIChhICogaSAtIGMgKiBnKSwgZGV0ICogKGIgKiBmIC0gYyAqIGUpLCBkZXQgKiAoYyAqIGQgLSBhICogZikpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5VG9Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKHRoaXMubWF0cml4KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWF0cml4O1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkTShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRNKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRNKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFNrZXcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9NYXRyaXgpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTa2V3LCBfTWF0cml4KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJE0oU2tldyk7XG5cbiAgZnVuY3Rpb24gU2tldyhkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBTa2V3KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgX3RoaXMudHlwZSA9ICdza2V3JztcbiAgICBfdGhpcy5hbmdsZSA9IG51bGw7XG4gICAgX3RoaXMuYW5nbGUgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdhbmdsZScsIHNrZXcpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBTa2V3O1xufShNYXRyaXgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkTChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRMKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRMKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFNrZXdYID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2tldykge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFNrZXdYLCBfU2tldyk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRMKFNrZXdYKTtcblxuICBmdW5jdGlvbiBTa2V3WChkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBTa2V3WCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIF90aGlzLnR5cGUgPSAnc2tld1gnO1xuICAgIF90aGlzLm1hdHJpeCA9IFsxLCAwLCBNYXRoLnRhbihfdGhpcy5hbmdsZS5nZXRSYWRpYW5zKCkpLCAxLCAwLCAwXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gU2tld1g7XG59KFNrZXcpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkSyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRLKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRLKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFNrZXdZID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2tldykge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFNrZXdZLCBfU2tldyk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRLKFNrZXdZKTtcblxuICBmdW5jdGlvbiBTa2V3WShkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBTa2V3WSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIF90aGlzLnR5cGUgPSAnc2tld1knO1xuICAgIF90aGlzLm1hdHJpeCA9IFsxLCBNYXRoLnRhbihfdGhpcy5hbmdsZS5nZXRSYWRpYW5zKCkpLCAwLCAxLCAwLCAwXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gU2tld1k7XG59KFNrZXcpO1xuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybXModHJhbnNmb3JtKSB7XG4gIHJldHVybiBjb21wcmVzc1NwYWNlcyh0cmFuc2Zvcm0pLnRyaW0oKS5yZXBsYWNlKC9cXCkoW2EtekEtWl0pL2csICcpICQxJykucmVwbGFjZSgvXFwpKFxccz8sXFxzPykvZywgJykgJykuc3BsaXQoL1xccyg/PVthLXpdKS8pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgdmFyIF90cmFuc2Zvcm0kc3BsaXQgPSB0cmFuc2Zvcm0uc3BsaXQoJygnKSxcbiAgICAgIF90cmFuc2Zvcm0kc3BsaXQyID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF90cmFuc2Zvcm0kc3BsaXQsIDIpLFxuICAgICAgdHlwZSA9IF90cmFuc2Zvcm0kc3BsaXQyWzBdLFxuICAgICAgdmFsdWUgPSBfdHJhbnNmb3JtJHNwbGl0MlsxXTtcblxuICByZXR1cm4gW3R5cGUudHJpbSgpLCB2YWx1ZS50cmltKCkucmVwbGFjZSgnKScsICcnKV07XG59XG5cbnZhciBUcmFuc2Zvcm0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2Zvcm0oZG9jdW1lbnQsIHRyYW5zZm9ybSwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVHJhbnNmb3JtKTtcblxuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBbXTtcbiAgICB2YXIgZGF0YSA9IHBhcnNlVHJhbnNmb3Jtcyh0cmFuc2Zvcm0pO1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNmb3JtKSB7XG4gICAgICBpZiAodHJhbnNmb3JtID09PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3BhcnNlVHJhbnNmb3JtID0gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKSxcbiAgICAgICAgICBfcGFyc2VUcmFuc2Zvcm0yID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9wYXJzZVRyYW5zZm9ybSwgMiksXG4gICAgICAgICAgdHlwZSA9IF9wYXJzZVRyYW5zZm9ybTJbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0yWzFdO1xuXG4gICAgICB2YXIgVHJhbnNmb3JtVHlwZSA9IFRyYW5zZm9ybS50cmFuc2Zvcm1UeXBlc1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBUcmFuc2Zvcm1UeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfdGhpcy50cmFuc2Zvcm1zLnB1c2gobmV3IFRyYW5zZm9ybVR5cGUoX3RoaXMuZG9jdW1lbnQsIHZhbHVlLCB0cmFuc2Zvcm1PcmlnaW4pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVHJhbnNmb3JtLCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShjdHgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gdGhpcy50cmFuc2Zvcm1zO1xuICAgICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRyYW5zZm9ybXNbaV0uYXBwbHkoY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5hcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmFwcGx5KGN0eCkge1xuICAgICAgdmFyIHRyYW5zZm9ybXMgPSB0aGlzLnRyYW5zZm9ybXM7XG4gICAgICB2YXIgbGVuID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0cmFuc2Zvcm1zW2ldLnVuYXBwbHkoY3R4KTtcbiAgICAgIH1cbiAgICB9IC8vIFRPRE86IGFwcGx5VG9Qb2ludCB1bnVzZWQgLi4uIHJlbW92ZT9cblxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5VG9Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gdGhpcy50cmFuc2Zvcm1zO1xuICAgICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRyYW5zZm9ybXNbaV0uYXBwbHlUb1BvaW50KHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRWxlbWVudChkb2N1bWVudCwgZWxlbWVudCkge1xuICAgICAgdmFyIHRyYW5zZm9ybVN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgndHJhbnNmb3JtJywgZmFsc2UsIHRydWUpO1xuXG4gICAgICB2YXIgX2VsZW1lbnQkZ2V0U3R5bGUkc3BsID0gZWxlbWVudC5nZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIGZhbHNlLCB0cnVlKS5zcGxpdCgpLFxuICAgICAgICAgIF9lbGVtZW50JGdldFN0eWxlJHNwbDIgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2VsZW1lbnQkZ2V0U3R5bGUkc3BsLCAyKSxcbiAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHkgPSBfZWxlbWVudCRnZXRTdHlsZSRzcGwyWzBdLFxuICAgICAgICAgIF9lbGVtZW50JGdldFN0eWxlJHNwbDMgPSBfZWxlbWVudCRnZXRTdHlsZSRzcGwyWzFdLFxuICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbllQcm9wZXJ0eSA9IF9lbGVtZW50JGdldFN0eWxlJHNwbDMgPT09IHZvaWQgMCA/IHRyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eSA6IF9lbGVtZW50JGdldFN0eWxlJHNwbDM7XG5cbiAgICAgIHZhciB0cmFuc2Zvcm1PcmlnaW4gPSBbdHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5LCB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHldO1xuXG4gICAgICBpZiAodHJhbnNmb3JtU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShkb2N1bWVudCwgdHJhbnNmb3JtU3R5bGUuZ2V0U3RyaW5nKCksIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2Zvcm07XG59KCk7XG5UcmFuc2Zvcm0udHJhbnNmb3JtVHlwZXMgPSB7XG4gIHRyYW5zbGF0ZTogVHJhbnNsYXRlLFxuICByb3RhdGU6IFJvdGF0ZSxcbiAgc2NhbGU6IFNjYWxlLFxuICBtYXRyaXg6IE1hdHJpeCxcbiAgc2tld1g6IFNrZXdYLFxuICBza2V3WTogU2tld1lcbn07XG5cbnZhciBFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRWxlbWVudChkb2N1bWVudCwgbm9kZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgY2FwdHVyZVRleHROb2RlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEVsZW1lbnQpO1xuXG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gY2FwdHVyZVRleHROb2RlcztcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3R5bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFuaW1hdGlvbkZyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuYW5pbWF0aW9uRnJvemVuVmFsdWUgPSAnJztcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIC8vIEVMRU1FTlRfTk9ERVxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYWRkIGF0dHJpYnV0ZXNcblxuXG4gICAgQXJyYXkuZnJvbShub2RlLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIG5vZGVOYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubm9kZU5hbWUpO1xuICAgICAgX3RoaXMuYXR0cmlidXRlc1tub2RlTmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5vZGVOYW1lLCBhdHRyaWJ1dGUudmFsdWUpO1xuICAgIH0pO1xuICAgIHRoaXMuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpOyAvLyBhZGQgaW5saW5lIHN0eWxlc1xuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZhciBzdHlsZXMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKS5nZXRTdHJpbmcoKS5zcGxpdCgnOycpLm1hcChmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gXy50cmltKCk7XG4gICAgICB9KTtcbiAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdHlsZSRzcGxpdCRtYXAgPSBzdHlsZS5zcGxpdCgnOicpLm1hcChmdW5jdGlvbiAoXykge1xuICAgICAgICAgIHJldHVybiBfLnRyaW0oKTtcbiAgICAgICAgfSksXG4gICAgICAgICAgICBfc3R5bGUkc3BsaXQkbWFwMiA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfc3R5bGUkc3BsaXQkbWFwLCAyKSxcbiAgICAgICAgICAgIG5hbWUgPSBfc3R5bGUkc3BsaXQkbWFwMlswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX3N0eWxlJHNwbGl0JG1hcDJbMV07XG5cbiAgICAgICAgX3RoaXMuc3R5bGVzW25hbWVdID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZGVmaW5pdGlvbnMgPSBkb2N1bWVudC5kZWZpbml0aW9ucztcbiAgICB2YXIgaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTsgLy8gYWRkIGlkXG5cbiAgICBpZiAoaWQuaGFzVmFsdWUoKSkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uc1tpZC5nZXRTdHJpbmcoKV0pIHtcbiAgICAgICAgZGVmaW5pdGlvbnNbaWQuZ2V0U3RyaW5nKCldID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGROb2RlKSB7XG4gICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIF90aGlzLmFkZENoaWxkKGNoaWxkTm9kZSk7IC8vIEVMRU1FTlRfTk9ERVxuXG4gICAgICB9IGVsc2UgaWYgKGNhcHR1cmVUZXh0Tm9kZXMgJiYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMyB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDQpKSB7XG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkTm9kZSk7XG5cbiAgICAgICAgaWYgKHRleHROb2RlLmdldFRleHQoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgX3RoaXMuYWRkQ2hpbGQodGV4dE5vZGUpOyAvLyBURVhUX05PREVcblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEVsZW1lbnQsIFt7XG4gICAga2V5OiBcImdldEF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgdmFyIGNyZWF0ZUlmTm90RXhpc3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBhdHRyID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAoIWF0dHIgJiYgY3JlYXRlSWZOb3RFeGlzdHMpIHtcbiAgICAgICAgdmFyIF9hdHRyID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIG5hbWUsICcnKTtcblxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBfYXR0cjtcbiAgICAgICAgcmV0dXJuIF9hdHRyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXR0ciB8fCBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SHJlZkF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIcmVmQXR0cmlidXRlKCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoa2V5ID09PSAnaHJlZicgfHwga2V5LmVuZHNXaXRoKCc6aHJlZicpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3R5bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3R5bGUobmFtZSkge1xuICAgICAgdmFyIGNyZWF0ZUlmTm90RXhpc3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBza2lwQW5jZXN0b3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGVzW25hbWVdO1xuXG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgICBpZiAoYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSB2b2lkIDAgJiYgYXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gYXR0cjsgLy8gbW92ZSB1cCB0byBtZSB0byBjYWNoZVxuXG4gICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNraXBBbmNlc3RvcnMpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgcGFyZW50U3R5bGUgPSBwYXJlbnQuZ2V0U3R5bGUobmFtZSk7XG5cbiAgICAgICAgICBpZiAocGFyZW50U3R5bGUgIT09IG51bGwgJiYgcGFyZW50U3R5bGUgIT09IHZvaWQgMCAmJiBwYXJlbnRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50U3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjcmVhdGVJZk5vdEV4aXN0cykge1xuICAgICAgICB2YXIgX3N0eWxlID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIG5hbWUsICcnKTtcblxuICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IF9zdHlsZTtcbiAgICAgICAgcmV0dXJuIF9zdHlsZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0eWxlIHx8IFByb3BlcnR5LmVtcHR5KHRoaXMuZG9jdW1lbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKGN0eCkge1xuICAgICAgLy8gZG9uJ3QgcmVuZGVyIGRpc3BsYXk9bm9uZVxuICAgICAgLy8gZG9uJ3QgcmVuZGVyIHZpc2liaWxpdHk9aGlkZGVuXG4gICAgICBpZiAodGhpcy5nZXRTdHlsZSgnZGlzcGxheScpLmdldFN0cmluZygpID09PSAnbm9uZScgfHwgdGhpcy5nZXRTdHlsZSgndmlzaWJpbGl0eScpLmdldFN0cmluZygpID09PSAnaGlkZGVuJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGlmICh0aGlzLmdldFN0eWxlKCdtYXNrJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAvLyBtYXNrXG4gICAgICAgIHZhciBtYXNrID0gdGhpcy5nZXRTdHlsZSgnbWFzaycpLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7XG4gICAgICAgICAgbWFzay5hcHBseShjdHgsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0U3R5bGUoJ2ZpbHRlcicpLmdldFZhbHVlKCdub25lJykgIT09ICdub25lJykge1xuICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuZ2V0U3R5bGUoJ2ZpbHRlcicpLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoY3R4KTtcbiAgICAgICAgICBmaWx0ZXIuYXBwbHkoY3R4LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0KGN0eCk7XG4gICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oY3R4KTtcbiAgICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb250ZXh0KF8pIHsvLyBOTyBSRU5ERVJcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlFZmZlY3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5RWZmZWN0cyhjdHgpIHtcbiAgICAgIC8vIHRyYW5zZm9ybVxuICAgICAgdmFyIHRyYW5zZm9ybSA9IFRyYW5zZm9ybS5mcm9tRWxlbWVudCh0aGlzLmRvY3VtZW50LCB0aGlzKTtcblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcbiAgICAgIH0gLy8gY2xpcFxuXG5cbiAgICAgIHZhciBjbGlwUGF0aFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2NsaXAtcGF0aCcsIGZhbHNlLCB0cnVlKTtcblxuICAgICAgaWYgKGNsaXBQYXRoU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmFyIGNsaXAgPSBjbGlwUGF0aFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgICBjbGlwLmFwcGx5KGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQ29udGV4dChfKSB7Ly8gTk8gUkVOREVSXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckNoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5yZW5kZXIoY3R4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDaGlsZChjaGlsZE5vZGUpIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkTm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgPyBjaGlsZE5vZGUgOiB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY2hpbGROb2RlKTtcbiAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG5cbiAgICAgIGlmICghRWxlbWVudC5pZ25vcmVDaGlsZFR5cGVzLmluY2x1ZGVzKGNoaWxkLnR5cGUpKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoZXNTZWxlY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgIHZhciBfbm9kZSRnZXRBdHRyaWJ1dGU7XG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuXG4gICAgICBpZiAodHlwZW9mIG5vZGUubWF0Y2hlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbm9kZS5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlQ2xhc3NlcyA9IChfbm9kZSRnZXRBdHRyaWJ1dGUgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX25vZGUkZ2V0QXR0cmlidXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRnZXRBdHRyaWJ1dGUuY2FsbChub2RlLCAnY2xhc3MnKTtcblxuICAgICAgaWYgKCFzdHlsZUNsYXNzZXMgfHwgc3R5bGVDbGFzc2VzID09PSAnJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZUNsYXNzZXMuc3BsaXQoJyAnKS5zb21lKGZ1bmN0aW9uIChzdHlsZUNsYXNzKSB7XG4gICAgICAgIHJldHVybiBcIi5cIi5jb25jYXQoc3R5bGVDbGFzcykgPT09IHNlbGVjdG9yO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyRkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQsXG4gICAgICAgICAgc3R5bGVzID0gX3RoaXMkZG9jdW1lbnQuc3R5bGVzLFxuICAgICAgICAgIHN0eWxlc1NwZWNpZmljaXR5ID0gX3RoaXMkZG9jdW1lbnQuc3R5bGVzU3BlY2lmaWNpdHk7XG5cbiAgICAgIGZvciAodmFyIHNlbGVjdG9yIGluIHN0eWxlcykge1xuICAgICAgICBpZiAoIXNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0AnKSAmJiB0aGlzLm1hdGNoZXNTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbc2VsZWN0b3JdO1xuICAgICAgICAgIHZhciBzcGVjaWZpY2l0eSA9IHN0eWxlc1NwZWNpZmljaXR5W3NlbGVjdG9yXTtcblxuICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdTcGVjaWZpY2l0eSA9IHRoaXMuc3R5bGVzU3BlY2lmaWNpdHlbbmFtZV07XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleGlzdGluZ1NwZWNpZmljaXR5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nU3BlY2lmaWNpdHkgPSAnMDAwJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChzcGVjaWZpY2l0eSA+PSBleGlzdGluZ1NwZWNpZmljaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5W25hbWVdID0gc3BlY2lmaWNpdHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlU3R5bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVN0eWxlcyhlbGVtZW50LCBpZ25vcmVTdHlsZXMpIHtcbiAgICAgIHZhciB0b1Jlc3RvcmUgPSBpZ25vcmVTdHlsZXMucmVkdWNlKGZ1bmN0aW9uICh0b1Jlc3RvcmUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHN0eWxlUHJvcCA9IGVsZW1lbnQuZ2V0U3R5bGUobmFtZSk7XG5cbiAgICAgICAgaWYgKCFzdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHJldHVybiB0b1Jlc3RvcmU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICAgIHN0eWxlUHJvcC5zZXRWYWx1ZSgnJyk7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0b1Jlc3RvcmUpLCBbW25hbWUsIHZhbHVlXV0pO1xuICAgICAgfSwgW10pO1xuICAgICAgcmV0dXJuIHRvUmVzdG9yZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzdG9yZVN0eWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9yZWYsIDIpLFxuICAgICAgICAgICAgbmFtZSA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfcmVmMlsxXTtcblxuICAgICAgICBlbGVtZW50LmdldFN0eWxlKG5hbWUsIHRydWUpLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ZpcnN0Q2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXJzdENoaWxkKCkge1xuICAgICAgdmFyIF90aGlzJHBhcmVudDtcblxuICAgICAgcmV0dXJuICgoX3RoaXMkcGFyZW50ID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF90aGlzJHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcykpID09PSAwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbGVtZW50O1xufSgpO1xuRWxlbWVudC5pZ25vcmVDaGlsZFR5cGVzID0gWyd0aXRsZSddO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkSihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRKKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRKKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFVua25vd25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFVua25vd25FbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRKKFVua25vd25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBVbmtub3duRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVW5rbm93bkVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gVW5rbm93bkVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiB3cmFwRm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gIHZhciB0cmltbWVkID0gZm9udEZhbWlseS50cmltKCk7XG4gIHJldHVybiAvXignfFwiKS8udGVzdCh0cmltbWVkKSA/IHRyaW1tZWQgOiBcIlxcXCJcIi5jb25jYXQodHJpbW1lZCwgXCJcXFwiXCIpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgPyBmb250RmFtaWx5IDogZm9udEZhbWlseS50cmltKCkuc3BsaXQoJywnKS5tYXAod3JhcEZvbnRGYW1pbHkpLmpvaW4oJywnKTtcbn1cbi8qKlxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC1zdHlsZVxyXG4gKiBAcGFyYW0gZm9udFN0eWxlXHJcbiAqIEByZXR1cm5zIENTUyBmb250IHN0eWxlLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlRm9udFN0eWxlKGZvbnRTdHlsZSkge1xuICBpZiAoIWZvbnRTdHlsZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0YXJnZXRGb250U3R5bGUgPSBmb250U3R5bGUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoICh0YXJnZXRGb250U3R5bGUpIHtcbiAgICBjYXNlICdub3JtYWwnOlxuICAgIGNhc2UgJ2l0YWxpYyc6XG4gICAgY2FzZSAnb2JsaXF1ZSc6XG4gICAgY2FzZSAnaW5oZXJpdCc6XG4gICAgY2FzZSAnaW5pdGlhbCc6XG4gICAgY2FzZSAndW5zZXQnOlxuICAgICAgcmV0dXJuIHRhcmdldEZvbnRTdHlsZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoL15vYmxpcXVlXFxzKygtfClcXGQrZGVnJC8udGVzdCh0YXJnZXRGb250U3R5bGUpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRGb250U3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXdlaWdodFxyXG4gKiBAcGFyYW0gZm9udFdlaWdodFxyXG4gKiBAcmV0dXJucyBDU1MgZm9udCB3ZWlnaHQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHByZXBhcmVGb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgaWYgKCFmb250V2VpZ2h0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIHRhcmdldEZvbnRXZWlnaHQgPSBmb250V2VpZ2h0LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAodGFyZ2V0Rm9udFdlaWdodCkge1xuICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgY2FzZSAnYm9sZCc6XG4gICAgY2FzZSAnbGlnaHRlcic6XG4gICAgY2FzZSAnYm9sZGVyJzpcbiAgICBjYXNlICdpbmhlcml0JzpcbiAgICBjYXNlICdpbml0aWFsJzpcbiAgICBjYXNlICd1bnNldCc6XG4gICAgICByZXR1cm4gdGFyZ2V0Rm9udFdlaWdodDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoL15bXFxkLl0rJC8udGVzdCh0YXJnZXRGb250V2VpZ2h0KSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFdlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbnZhciBGb250ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9udChmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCkge1xuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgRm9udCk7XG5cbiAgICB2YXIgaW5oZXJpdEZvbnQgPSBpbmhlcml0ID8gdHlwZW9mIGluaGVyaXQgPT09ICdzdHJpbmcnID8gRm9udC5wYXJzZShpbmhlcml0KSA6IGluaGVyaXQgOiB7fTtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5IHx8IGluaGVyaXRGb250LmZvbnRGYW1pbHk7XG4gICAgdGhpcy5mb250U2l6ZSA9IGZvbnRTaXplIHx8IGluaGVyaXRGb250LmZvbnRTaXplO1xuICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlIHx8IGluaGVyaXRGb250LmZvbnRTdHlsZTtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0IHx8IGluaGVyaXRGb250LmZvbnRXZWlnaHQ7XG4gICAgdGhpcy5mb250VmFyaWFudCA9IGZvbnRWYXJpYW50IHx8IGluaGVyaXRGb250LmZvbnRWYXJpYW50O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGb250LCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBbcHJlcGFyZUZvbnRTdHlsZSh0aGlzLmZvbnRTdHlsZSksIHRoaXMuZm9udFZhcmlhbnQsIHByZXBhcmVGb250V2VpZ2h0KHRoaXMuZm9udFdlaWdodCksIHRoaXMuZm9udFNpemUsIC8vIFdyYXAgZm9udEZhbWlseSBvbmx5IG9uIG5vZGVqcyBhbmQgb25seSBmb3IgY2FudmFzLmN0eFxuICAgICAgcHJlcGFyZUZvbnRGYW1pbHkodGhpcy5mb250RmFtaWx5KV0uam9pbignICcpLnRyaW0oKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgIHZhciBmb250ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnJztcbiAgICAgIHZhciBpbmhlcml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgZm9udFN0eWxlID0gJyc7XG4gICAgICB2YXIgZm9udFZhcmlhbnQgPSAnJztcbiAgICAgIHZhciBmb250V2VpZ2h0ID0gJyc7XG4gICAgICB2YXIgZm9udFNpemUgPSAnJztcbiAgICAgIHZhciBmb250RmFtaWx5ID0gJyc7XG4gICAgICB2YXIgcGFydHMgPSBjb21wcmVzc1NwYWNlcyhmb250KS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgIHZhciBzZXQgPSB7XG4gICAgICAgIGZvbnRTaXplOiBmYWxzZSxcbiAgICAgICAgZm9udFN0eWxlOiBmYWxzZSxcbiAgICAgICAgZm9udFdlaWdodDogZmFsc2UsXG4gICAgICAgIGZvbnRWYXJpYW50OiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgY2FzZSAhc2V0LmZvbnRTdHlsZSAmJiBGb250LnN0eWxlcy5pbmNsdWRlcyhwYXJ0KTpcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgZm9udFN0eWxlID0gcGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgIXNldC5mb250VmFyaWFudCAmJiBGb250LnZhcmlhbnRzLmluY2x1ZGVzKHBhcnQpOlxuICAgICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgICBmb250VmFyaWFudCA9IHBhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAhc2V0LmZvbnRXZWlnaHQgJiYgRm9udC53ZWlnaHRzLmluY2x1ZGVzKHBhcnQpOlxuICAgICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgICBmb250V2VpZ2h0ID0gcGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgICBzZXQuZm9udFZhcmlhbnQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0LmZvbnRXZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICFzZXQuZm9udFNpemU6XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgIHZhciBfcGFydCRzcGxpdCA9IHBhcnQuc3BsaXQoJy8nKTtcblxuICAgICAgICAgICAgICB2YXIgX3BhcnQkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9wYXJ0JHNwbGl0LCAxKTtcblxuICAgICAgICAgICAgICBmb250U2l6ZSA9IF9wYXJ0JHNwbGl0MlswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0LmZvbnRTdHlsZSA9IHRydWU7XG4gICAgICAgICAgICBzZXQuZm9udFZhcmlhbnQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0LmZvbnRXZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0LmZvbnRTaXplID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgZm9udEZhbWlseSArPSBwYXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBGb250KGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBpbmhlcml0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9udDtcbn0oKTtcbkZvbnQuc3R5bGVzID0gJ25vcm1hbHxpdGFsaWN8b2JsaXF1ZXxpbmhlcml0JztcbkZvbnQudmFyaWFudHMgPSAnbm9ybWFsfHNtYWxsLWNhcHN8aW5oZXJpdCc7XG5Gb250LndlaWdodHMgPSAnbm9ybWFsfGJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8MTAwfDIwMHwzMDB8NDAwfDUwMHw2MDB8NzAwfDgwMHw5MDB8aW5oZXJpdCc7XG5cbnZhciBCb3VuZGluZ0JveCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJvdW5kaW5nQm94KCkge1xuICAgIHZhciB4MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogTnVtYmVyLk5hTjtcbiAgICB2YXIgeTEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE51bWJlci5OYU47XG4gICAgdmFyIHgyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBOdW1iZXIuTmFOO1xuICAgIHZhciB5MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogTnVtYmVyLk5hTjtcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgQm91bmRpbmdCb3gpO1xuXG4gICAgdGhpcy54MSA9IHgxO1xuICAgIHRoaXMueTEgPSB5MTtcbiAgICB0aGlzLngyID0geDI7XG4gICAgdGhpcy55MiA9IHkyO1xuICAgIHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcbiAgICB0aGlzLmFkZFBvaW50KHgyLCB5Mik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEJvdW5kaW5nQm94LCBbe1xuICAgIGtleTogXCJhZGRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQb2ludCh4LCB5KSB7XG4gICAgICBpZiAodHlwZW9mIHggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLngyKSkge1xuICAgICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPCB0aGlzLngxKSB7XG4gICAgICAgICAgdGhpcy54MSA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA+IHRoaXMueDIpIHtcbiAgICAgICAgICB0aGlzLngyID0geDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLnkyKSkge1xuICAgICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICAgIHRoaXMueTIgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPCB0aGlzLnkxKSB7XG4gICAgICAgICAgdGhpcy55MSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeSA+IHRoaXMueTIpIHtcbiAgICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFgoeCkge1xuICAgICAgdGhpcy5hZGRQb2ludCh4LCBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRZKHkpIHtcbiAgICAgIHRoaXMuYWRkUG9pbnQobnVsbCwgeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEJvdW5kaW5nQm94KGJvdW5kaW5nQm94KSB7XG4gICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHgxID0gYm91bmRpbmdCb3gueDEsXG4gICAgICAgICAgeTEgPSBib3VuZGluZ0JveC55MSxcbiAgICAgICAgICB4MiA9IGJvdW5kaW5nQm94LngyLFxuICAgICAgICAgIHkyID0gYm91bmRpbmdCb3gueTI7XG4gICAgICB0aGlzLmFkZFBvaW50KHgxLCB5MSk7XG4gICAgICB0aGlzLmFkZFBvaW50KHgyLCB5Mik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1bUN1YmljXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1bUN1YmljKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMSAtIHQsIDMpICogcDAgKyAzICogTWF0aC5wb3coMSAtIHQsIDIpICogdCAqIHAxICsgMyAqICgxIC0gdCkgKiBNYXRoLnBvdyh0LCAyKSAqIHAyICsgTWF0aC5wb3codCwgMykgKiBwMztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmV6aWVyQ3VydmVBZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmV6aWVyQ3VydmVBZGQoZm9yWCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgICAgIHZhciBiID0gNiAqIHAwIC0gMTIgKiBwMSArIDYgKiBwMjtcbiAgICAgIHZhciBhID0gLTMgKiBwMCArIDkgKiBwMSAtIDkgKiBwMiArIDMgKiBwMztcbiAgICAgIHZhciBjID0gMyAqIHAxIC0gMyAqIHAwO1xuXG4gICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICBpZiAoYiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gLWMgLyBiO1xuXG4gICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFgodGhpcy5zdW1DdWJpYyh0LCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZFkodGhpcy5zdW1DdWJpYyh0LCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGIyYWMgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBjICogYTtcblxuICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG5cbiAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModDEsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModDEsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG5cbiAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModDIsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModDIsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGZyb20gaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG5cbiAgfSwge1xuICAgIGtleTogXCJhZGRCZXppZXJDdXJ2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRCZXppZXJDdXJ2ZShwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgICAgdGhpcy5hZGRQb2ludChwMHgsIHAweSk7XG4gICAgICB0aGlzLmFkZFBvaW50KHAzeCwgcDN5KTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVBZGQodHJ1ZSwgcDB4LCBwMXgsIHAyeCwgcDN4KTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVBZGQoZmFsc2UsIHAweSwgcDF5LCBwMnksIHAzeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFF1YWRyYXRpY0N1cnZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFF1YWRyYXRpY0N1cnZlKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICAgIHZhciBjcDF4ID0gcDB4ICsgMiAvIDMgKiAocDF4IC0gcDB4KTsgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcblxuICAgICAgdmFyIGNwMXkgPSBwMHkgKyAyIC8gMyAqIChwMXkgLSBwMHkpOyAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxuXG4gICAgICB2YXIgY3AyeCA9IGNwMXggKyAxIC8gMyAqIChwMnggLSBwMHgpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuXG4gICAgICB2YXIgY3AyeSA9IGNwMXkgKyAxIC8gMyAqIChwMnkgLSBwMHkpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuXG4gICAgICB0aGlzLmFkZEJlemllckN1cnZlKHAweCwgcDB5LCBjcDF4LCBjcDJ4LCBjcDF5LCBjcDJ5LCBwMngsIHAyeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUG9pbnRJbkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BvaW50SW5Cb3goeCwgeSkge1xuICAgICAgdmFyIHgxID0gdGhpcy54MSxcbiAgICAgICAgICB5MSA9IHRoaXMueTEsXG4gICAgICAgICAgeDIgPSB0aGlzLngyLFxuICAgICAgICAgIHkyID0gdGhpcy55MjtcbiAgICAgIHJldHVybiB4MSA8PSB4ICYmIHggPD0geDIgJiYgeTEgPD0geSAmJiB5IDw9IHkyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy54MTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMueTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy54MiAtIHRoaXMueDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCb3VuZGluZ0JveDtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJEkoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkSSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkSSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBQYXRoUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU1ZHUGF0aERhdGEpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShQYXRoUGFyc2VyLCBfU1ZHUGF0aERhdGEpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkSShQYXRoUGFyc2VyKTtcblxuICBmdW5jdGlvbiBQYXRoUGFyc2VyKHBhdGgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFBhdGhQYXJzZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXRoIC8vIEZpeCBzcGFjZXMgYWZ0ZXIgc2lnbnMuXG4gICAgLnJlcGxhY2UoLyhbK1xcLS5dKVxccysvZ20sICckMScpIC8vIFJlbW92ZSBpbnZhbGlkIHBhcnQuXG4gICAgLnJlcGxhY2UoL1teTW1aekxsSGhWdkNjU3NRcVR0QWFlXFxkXFxzLiwrLV0uKi9nLCAnJykpO1xuICAgIF90aGlzLmNvbnRyb2wgPSBudWxsO1xuICAgIF90aGlzLnN0YXJ0ID0gbnVsbDtcbiAgICBfdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICBfdGhpcy5jb21tYW5kID0gbnVsbDtcbiAgICBfdGhpcy5jb21tYW5kcyA9IF90aGlzLmNvbW1hbmRzO1xuICAgIF90aGlzLmkgPSAtMTtcbiAgICBfdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgIF90aGlzLnBvaW50cyA9IFtdO1xuICAgIF90aGlzLmFuZ2xlcyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUGF0aFBhcnNlciwgW3tcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLmkgPSAtMTtcbiAgICAgIHRoaXMuY29tbWFuZCA9IG51bGw7XG4gICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9IG51bGw7XG4gICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgdGhpcy5jb250cm9sID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgIHRoaXMuYW5nbGVzID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW5kKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLmksXG4gICAgICAgICAgY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuICAgICAgcmV0dXJuIGkgPj0gY29tbWFuZHMubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzWysrdGhpcy5pXTtcbiAgICAgIHRoaXMucHJldmlvdXNDb21tYW5kID0gdGhpcy5jb21tYW5kO1xuICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcbiAgICAgIHJldHVybiBjb21tYW5kO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludCgpIHtcbiAgICAgIHZhciB4UHJvcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3gnO1xuICAgICAgdmFyIHlQcm9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneSc7XG4gICAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQodGhpcy5jb21tYW5kW3hQcm9wXSwgdGhpcy5jb21tYW5kW3lQcm9wXSk7XG4gICAgICByZXR1cm4gdGhpcy5tYWtlQWJzb2x1dGUocG9pbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBc0NvbnRyb2xQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBc0NvbnRyb2xQb2ludCh4UHJvcCwgeVByb3ApIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMuZ2V0UG9pbnQoeFByb3AsIHlQcm9wKTtcbiAgICAgIHRoaXMuY29udHJvbCA9IHBvaW50O1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBc0N1cnJlbnRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBc0N1cnJlbnRQb2ludCh4UHJvcCwgeVByb3ApIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMuZ2V0UG9pbnQoeFByb3AsIHlQcm9wKTtcbiAgICAgIHRoaXMuY3VycmVudCA9IHBvaW50O1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZWZsZWN0ZWRDb250cm9sUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCkge1xuICAgICAgdmFyIHByZXZpb3VzQ29tbWFuZCA9IHRoaXMucHJldmlvdXNDb21tYW5kLnR5cGU7XG5cbiAgICAgIGlmIChwcmV2aW91c0NvbW1hbmQgIT09IHN2Z1BhdGhkYXRhLlNWR1BhdGhEYXRhLkNVUlZFX1RPICYmIHByZXZpb3VzQ29tbWFuZCAhPT0gc3ZnUGF0aGRhdGEuU1ZHUGF0aERhdGEuU01PT1RIX0NVUlZFX1RPICYmIHByZXZpb3VzQ29tbWFuZCAhPT0gc3ZnUGF0aGRhdGEuU1ZHUGF0aERhdGEuUVVBRF9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IHN2Z1BhdGhkYXRhLlNWR1BhdGhEYXRhLlNNT09USF9RVUFEX1RPKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgICB9IC8vIHJlZmxlY3QgcG9pbnRcblxuXG4gICAgICB2YXIgX3RoaXMkY3VycmVudCA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgICBjeCA9IF90aGlzJGN1cnJlbnQueCxcbiAgICAgICAgICBjeSA9IF90aGlzJGN1cnJlbnQueSxcbiAgICAgICAgICBfdGhpcyRjb250cm9sID0gdGhpcy5jb250cm9sLFxuICAgICAgICAgIG94ID0gX3RoaXMkY29udHJvbC54LFxuICAgICAgICAgIG95ID0gX3RoaXMkY29udHJvbC55O1xuICAgICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KDIgKiBjeCAtIG94LCAyICogY3kgLSBveSk7XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VBYnNvbHV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlQWJzb2x1dGUocG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLmNvbW1hbmQucmVsYXRpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzJGN1cnJlbnQyID0gdGhpcy5jdXJyZW50LFxuICAgICAgICAgICAgeCA9IF90aGlzJGN1cnJlbnQyLngsXG4gICAgICAgICAgICB5ID0gX3RoaXMkY3VycmVudDIueTtcbiAgICAgICAgcG9pbnQueCArPSB4O1xuICAgICAgICBwb2ludC55ICs9IHk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTWFya2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1hcmtlcihwb2ludCwgZnJvbSwgcHJpb3JUbykge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgICAgICAgIGFuZ2xlcyA9IHRoaXMuYW5nbGVzOyAvLyBpZiB0aGUgbGFzdCBhbmdsZSBpc24ndCBmaWxsZWQgaW4gYmVjYXVzZSB3ZSBkaWRuJ3QgaGF2ZSB0aGlzIHBvaW50IHlldCAuLi5cblxuICAgICAgaWYgKHByaW9yVG8gJiYgYW5nbGVzLmxlbmd0aCA+IDAgJiYgIWFuZ2xlc1thbmdsZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgYW5nbGVzW2FuZ2xlcy5sZW5ndGggLSAxXSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0uYW5nbGVUbyhwcmlvclRvKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRNYXJrZXJBbmdsZShwb2ludCwgZnJvbSA/IGZyb20uYW5nbGVUbyhwb2ludCkgOiBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTWFya2VyQW5nbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTWFya2VyQW5nbGUocG9pbnQsIGFuZ2xlKSB7XG4gICAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHRoaXMuYW5nbGVzLnB1c2goYW5nbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXJrZXJQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya2VyUG9pbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9pbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXJrZXJBbmdsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya2VyQW5nbGVzKCkge1xuICAgICAgdmFyIGFuZ2xlcyA9IHRoaXMuYW5nbGVzO1xuICAgICAgdmFyIGxlbiA9IGFuZ2xlcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFhbmdsZXNbaV0pIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgaWYgKGFuZ2xlc1tqXSkge1xuICAgICAgICAgICAgICBhbmdsZXNbaV0gPSBhbmdsZXNbal07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYW5nbGVzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXRoUGFyc2VyO1xufShzdmdQYXRoZGF0YS5TVkdQYXRoRGF0YSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRIKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEgoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEgoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgUmVuZGVyZWRFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFJlbmRlcmVkRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkSChSZW5kZXJlZEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlbmRlcmVkRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFJlbmRlcmVkRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLm1vZGlmaWVkRW1TaXplU3RhY2sgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFJlbmRlcmVkRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiY2FsY3VsYXRlT3BhY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVPcGFjaXR5KCkge1xuICAgICAgdmFyIG9wYWNpdHkgPSAxLjA7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcywgY29uc2lzdGVudC10aGlzXG5cbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG9wYWNpdHlTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ29wYWNpdHknLCBmYWxzZSwgdHJ1ZSk7IC8vIG5vIGFuY2VzdG9ycyBvbiBzdHlsZSBjYWxsXG5cbiAgICAgICAgaWYgKG9wYWNpdHlTdHlsZS5oYXNWYWx1ZSh0cnVlKSkge1xuICAgICAgICAgIG9wYWNpdHkgKj0gb3BhY2l0eVN0eWxlLmdldE51bWJlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3BhY2l0eTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb250ZXh0KGN0eCkge1xuICAgICAgdmFyIGZyb21NZWFzdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgaWYgKCFmcm9tTWVhc3VyZSkge1xuICAgICAgICAvLyBjYXVzZXMgc3RhY2sgb3ZlcmZsb3cgd2hlbiBtZWFzdXJpbmcgdGV4dCB3aXRoIGdyYWRpZW50c1xuICAgICAgICAvLyBmaWxsXG4gICAgICAgIHZhciBmaWxsU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbCcpO1xuICAgICAgICB2YXIgZmlsbE9wYWNpdHlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsLW9wYWNpdHknKTtcbiAgICAgICAgdmFyIHN0cm9rZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZScpO1xuICAgICAgICB2YXIgc3Ryb2tlT3BhY2l0eVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2Utb3BhY2l0eScpO1xuXG4gICAgICAgIGlmIChmaWxsU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgdmFyIGZpbGxTdHlsZSA9IGZpbGxTdHlsZVByb3AuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCBmaWxsT3BhY2l0eVN0eWxlUHJvcCk7XG5cbiAgICAgICAgICBpZiAoZmlsbFN0eWxlKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmaWxsU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBpZiAoZmlsbFN0eWxlUHJvcC5nZXRTdHJpbmcoKSA9PT0gJ2N1cnJlbnRDb2xvcicpIHtcbiAgICAgICAgICAgIGZpbGxTdHlsZVByb3Auc2V0VmFsdWUodGhpcy5nZXRTdHlsZSgnY29sb3InKS5nZXRDb2xvcigpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2ZpbGxTdHlsZSA9IGZpbGxTdHlsZVByb3AuZ2V0Q29sb3IoKTtcblxuICAgICAgICAgIGlmIChfZmlsbFN0eWxlICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBfZmlsbFN0eWxlID09PSAnbm9uZScgPyAncmdiYSgwLDAsMCwwKScgOiBfZmlsbFN0eWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxsT3BhY2l0eVN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgdmFyIF9maWxsU3R5bGUyID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdmaWxsJywgY3R4LmZpbGxTdHlsZSkuYWRkT3BhY2l0eShmaWxsT3BhY2l0eVN0eWxlUHJvcCkuZ2V0Q29sb3IoKTtcblxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBfZmlsbFN0eWxlMjtcbiAgICAgICAgfSAvLyBzdHJva2VcblxuXG4gICAgICAgIGlmIChzdHJva2VTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZVByb3AuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCBzdHJva2VPcGFjaXR5UHJvcCk7XG5cbiAgICAgICAgICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdHJva2VTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIGlmIChzdHJva2VTdHlsZVByb3AuZ2V0U3RyaW5nKCkgPT09ICdjdXJyZW50Q29sb3InKSB7XG4gICAgICAgICAgICBzdHJva2VTdHlsZVByb3Auc2V0VmFsdWUodGhpcy5nZXRTdHlsZSgnY29sb3InKS5nZXRDb2xvcigpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGVQcm9wLmdldFN0cmluZygpO1xuXG4gICAgICAgICAgaWYgKF9zdHJva2VTdHlsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBfc3Ryb2tlU3R5bGUgPT09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IF9zdHJva2VTdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3Ryb2tlT3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHZhciBfc3Ryb2tlU3R5bGUyID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdzdHJva2UnLCBjdHguc3Ryb2tlU3R5bGUpLmFkZE9wYWNpdHkoc3Ryb2tlT3BhY2l0eVByb3ApLmdldFN0cmluZygpO1xuXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gX3N0cm9rZVN0eWxlMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJva2VXaWR0aFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS13aWR0aCcpO1xuXG4gICAgICAgIGlmIChzdHJva2VXaWR0aFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgdmFyIG5ld0xpbmVXaWR0aCA9IHN0cm9rZVdpZHRoU3R5bGVQcm9wLmdldFBpeGVscygpO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAhbmV3TGluZVdpZHRoID8gUFNFVURPX1pFUk8gLy8gYnJvd3NlcnMgZG9uJ3QgcmVzcGVjdCAwIChvciBub2RlLWNhbnZhcz8gOi0pXG4gICAgICAgICAgOiBuZXdMaW5lV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3Ryb2tlTGluZWNhcFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1saW5lY2FwJyk7XG4gICAgICAgIHZhciBzdHJva2VMaW5lam9pblN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1saW5lam9pbicpO1xuICAgICAgICB2YXIgc3Ryb2tlTWl0ZXJsaW1pdFByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbWl0ZXJsaW1pdCcpOyAvLyBORUVEIFRFU1RcbiAgICAgICAgLy8gY29uc3QgcG9pbnRPcmRlclN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3BhaW50LW9yZGVyJyk7XG5cbiAgICAgICAgdmFyIHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknKTtcbiAgICAgICAgdmFyIHN0cm9rZURhc2hvZmZzZXRQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblxuICAgICAgICBpZiAoc3Ryb2tlTGluZWNhcFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgY3R4LmxpbmVDYXAgPSBzdHJva2VMaW5lY2FwU3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cm9rZUxpbmVqb2luU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBjdHgubGluZUpvaW4gPSBzdHJva2VMaW5lam9pblN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJva2VNaXRlcmxpbWl0UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSBzdHJva2VNaXRlcmxpbWl0UHJvcC5nZXROdW1iZXIoKTtcbiAgICAgICAgfSAvLyBORUVEIFRFU1RcbiAgICAgICAgLy8gaWYgKHBvaW50T3JkZXJTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAvLyBcdC8vID9cbiAgICAgICAgLy8gXHRjdHgucGFpbnRPcmRlciA9IHBvaW50T3JkZXJTdHlsZVByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgLy8gfVxuXG5cbiAgICAgICAgaWYgKHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5oYXNWYWx1ZSgpICYmIHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5nZXRTdHJpbmcoKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgdmFyIGdhcHMgPSB0b051bWJlcnMoc3Ryb2tlRGFzaGFycmF5U3R5bGVQcm9wLmdldFN0cmluZygpKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGdhcHMpO1xuICAgICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4LndlYmtpdExpbmVEYXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgY3R4LndlYmtpdExpbmVEYXNoID0gZ2FwcztcbiAgICAgICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgubW96RGFzaCAhPT0gJ3VuZGVmaW5lZCcgJiYgIShnYXBzLmxlbmd0aCA9PT0gMSAmJiBnYXBzWzBdID09PSAwKSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICAgIGN0eC5tb3pEYXNoID0gZ2FwcztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IHN0cm9rZURhc2hvZmZzZXRQcm9wLmdldFBpeGVscygpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjdHgubGluZURhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgud2Via2l0TGluZURhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICBjdHgud2Via2l0TGluZURhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4Lm1vekRhc2hPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgY3R4Lm1vekRhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBmb250XG5cblxuICAgICAgdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlb2YgY3R4LmZvbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBmb250U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udCcpO1xuICAgICAgICB2YXIgZm9udFN0eWxlU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1zdHlsZScpO1xuICAgICAgICB2YXIgZm9udFZhcmlhbnRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LXZhcmlhbnQnKTtcbiAgICAgICAgdmFyIGZvbnRXZWlnaHRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LXdlaWdodCcpO1xuICAgICAgICB2YXIgZm9udFNpemVTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LXNpemUnKTtcbiAgICAgICAgdmFyIGZvbnRGYW1pbHlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LWZhbWlseScpO1xuICAgICAgICB2YXIgZm9udCA9IG5ldyBGb250KGZvbnRTdHlsZVN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgZm9udFZhcmlhbnRTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGZvbnRXZWlnaHRTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGZvbnRTaXplU3R5bGVQcm9wLmhhc1ZhbHVlKCkgPyBcIlwiLmNvbmNhdChmb250U2l6ZVN0eWxlUHJvcC5nZXRQaXhlbHModHJ1ZSksIFwicHhcIikgOiAnJywgZm9udEZhbWlseVN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgRm9udC5wYXJzZShmb250U3R5bGVQcm9wLmdldFN0cmluZygpLCBjdHguZm9udCkpO1xuICAgICAgICBmb250U3R5bGVTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250U3R5bGUpO1xuICAgICAgICBmb250VmFyaWFudFN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRWYXJpYW50KTtcbiAgICAgICAgZm9udFdlaWdodFN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRXZWlnaHQpO1xuICAgICAgICBmb250U2l6ZVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRTaXplKTtcbiAgICAgICAgZm9udEZhbWlseVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRGYW1pbHkpO1xuICAgICAgICBjdHguZm9udCA9IGZvbnQudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAoZm9udFNpemVTdHlsZVByb3AuaXNQaXhlbHMoKSkge1xuICAgICAgICAgIHRoaXMuZG9jdW1lbnQuZW1TaXplID0gZm9udFNpemVTdHlsZVByb3AuZ2V0UGl4ZWxzKCk7XG4gICAgICAgICAgdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWZyb21NZWFzdXJlKSB7XG4gICAgICAgIC8vIGVmZmVjdHNcbiAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoY3R4KTsgLy8gb3BhY2l0eVxuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY2FsY3VsYXRlT3BhY2l0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDb250ZXh0KGN0eCkge1xuICAgICAgX2dldF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShSZW5kZXJlZEVsZW1lbnQucHJvdG90eXBlKSwgXCJjbGVhckNvbnRleHRcIiwgdGhpcykuY2FsbCh0aGlzLCBjdHgpO1xuXG4gICAgICBpZiAodGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQucG9wRW1TaXplKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlbmRlcmVkRWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRHKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEcoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEcoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgUGF0aEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZW5kZXJlZEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShQYXRoRWxlbWVudCwgX1JlbmRlcmVkRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRHKFBhdGhFbGVtZW50KTtcblxuICBmdW5jdGlvbiBQYXRoRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgUGF0aEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdwYXRoJztcbiAgICBfdGhpcy5wYXRoUGFyc2VyID0gbnVsbDtcbiAgICBfdGhpcy5wYXRoUGFyc2VyID0gbmV3IFBhdGhQYXJzZXIoX3RoaXMuZ2V0QXR0cmlidXRlKCdkJykuZ2V0U3RyaW5nKCkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUGF0aEVsZW1lbnQsIFt7XG4gICAga2V5OiBcInBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aChjdHgpIHtcbiAgICAgIHZhciBwYXRoUGFyc2VyID0gdGhpcy5wYXRoUGFyc2VyO1xuICAgICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICBwYXRoUGFyc2VyLnJlc2V0KCk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoIXBhdGhQYXJzZXIuaXNFbmQoKSkge1xuICAgICAgICBzd2l0Y2ggKHBhdGhQYXJzZXIubmV4dCgpLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTU9WRV9UTzpcbiAgICAgICAgICAgIHRoaXMucGF0aE0oY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgICAgdGhpcy5wYXRoTChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkhPUklaX0xJTkVfVE86XG4gICAgICAgICAgICB0aGlzLnBhdGhIKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuVkVSVF9MSU5FX1RPOlxuICAgICAgICAgICAgdGhpcy5wYXRoVihjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgICAgdGhpcy5wYXRoQyhjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9DVVJWRV9UTzpcbiAgICAgICAgICAgIHRoaXMucGF0aFMoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgICAgdGhpcy5wYXRoUShjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9RVUFEX1RPOlxuICAgICAgICAgICAgdGhpcy5wYXRoVChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgIHRoaXMucGF0aEEoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgICAgdGhpcy5wYXRoWihjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3goXykge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlcnMoKSB7XG4gICAgICB2YXIgcGF0aFBhcnNlciA9IHRoaXMucGF0aFBhcnNlcjtcbiAgICAgIHZhciBwb2ludHMgPSBwYXRoUGFyc2VyLmdldE1hcmtlclBvaW50cygpO1xuICAgICAgdmFyIGFuZ2xlcyA9IHBhdGhQYXJzZXIuZ2V0TWFya2VyQW5nbGVzKCk7XG4gICAgICB2YXIgbWFya2VycyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHBvaW50LCBpKSB7XG4gICAgICAgIHJldHVybiBbcG9pbnQsIGFuZ2xlc1tpXV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICAgIHRoaXMucGF0aChjdHgpO1xuICAgICAgdGhpcy5kb2N1bWVudC5zY3JlZW4ubW91c2UuY2hlY2tQYXRoKHRoaXMsIGN0eCk7XG4gICAgICB2YXIgZmlsbFJ1bGVTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsLXJ1bGUnKTtcblxuICAgICAgaWYgKGN0eC5maWxsU3R5bGUgIT09ICcnKSB7XG4gICAgICAgIGlmIChmaWxsUnVsZVN0eWxlUHJvcC5nZXRTdHJpbmcoJ2luaGVyaXQnKSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgY3R4LmZpbGwoZmlsbFJ1bGVTdHlsZVByb3AuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSAhPT0gJycpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCd2ZWN0b3ItZWZmZWN0JykuZ2V0U3RyaW5nKCkgPT09ICdub24tc2NhbGluZy1zdHJva2UnKSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xuXG4gICAgICBpZiAobWFya2Vycykge1xuICAgICAgICB2YXIgbWFya2Vyc0xhc3RJbmRleCA9IG1hcmtlcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG1hcmtlclN0YXJ0U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLXN0YXJ0Jyk7XG4gICAgICAgIHZhciBtYXJrZXJNaWRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdtYXJrZXItbWlkJyk7XG4gICAgICAgIHZhciBtYXJrZXJFbmRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdtYXJrZXItZW5kJyk7XG5cbiAgICAgICAgaWYgKG1hcmtlclN0YXJ0U3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlclN0YXJ0U3R5bGVQcm9wLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICAgIHZhciBfbWFya2VycyQgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0obWFya2Vyc1swXSwgMiksXG4gICAgICAgICAgICAgIHBvaW50ID0gX21hcmtlcnMkWzBdLFxuICAgICAgICAgICAgICBhbmdsZSA9IF9tYXJrZXJzJFsxXTtcblxuICAgICAgICAgIG1hcmtlci5yZW5kZXIoY3R4LCBwb2ludCwgYW5nbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hcmtlck1pZFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgIHZhciBfbWFya2VyID0gbWFya2VyTWlkU3R5bGVQcm9wLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbWFya2Vyc0xhc3RJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgX21hcmtlcnMkaSA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShtYXJrZXJzW2ldLCAyKSxcbiAgICAgICAgICAgICAgICBfcG9pbnQgPSBfbWFya2VycyRpWzBdLFxuICAgICAgICAgICAgICAgIF9hbmdsZSA9IF9tYXJrZXJzJGlbMV07XG5cbiAgICAgICAgICAgIF9tYXJrZXIucmVuZGVyKGN0eCwgX3BvaW50LCBfYW5nbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJrZXJFbmRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICB2YXIgX21hcmtlcjIgPSBtYXJrZXJFbmRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICAgICAgdmFyIF9tYXJrZXJzJG1hcmtlcnNMYXN0SSA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShtYXJrZXJzW21hcmtlcnNMYXN0SW5kZXhdLCAyKSxcbiAgICAgICAgICAgICAgX3BvaW50MiA9IF9tYXJrZXJzJG1hcmtlcnNMYXN0SVswXSxcbiAgICAgICAgICAgICAgX2FuZ2xlMiA9IF9tYXJrZXJzJG1hcmtlcnNMYXN0SVsxXTtcblxuICAgICAgICAgIF9tYXJrZXIyLnJlbmRlcihjdHgsIF9wb2ludDIsIF9hbmdsZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhNXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhNKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgIHZhciBwYXRoUGFyc2VyID0gdGhpcy5wYXRoUGFyc2VyO1xuXG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhNID0gUGF0aEVsZW1lbnQucGF0aE0ocGF0aFBhcnNlciksXG4gICAgICAgICAgcG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aE0ucG9pbnQ7XG5cbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50KTtcbiAgICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhMKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgIHZhciBwYXRoUGFyc2VyID0gdGhpcy5wYXRoUGFyc2VyO1xuXG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhMID0gUGF0aEVsZW1lbnQucGF0aEwocGF0aFBhcnNlciksXG4gICAgICAgICAgY3VycmVudCA9IF9QYXRoRWxlbWVudCRwYXRoTC5jdXJyZW50LFxuICAgICAgICAgIHBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhMLnBvaW50O1xuXG4gICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoSFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoSChjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICB2YXIgcGF0aFBhcnNlciA9IHRoaXMucGF0aFBhcnNlcjtcblxuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoSCA9IFBhdGhFbGVtZW50LnBhdGhIKHBhdGhQYXJzZXIpLFxuICAgICAgICAgIGN1cnJlbnQgPSBfUGF0aEVsZW1lbnQkcGF0aEguY3VycmVudCxcbiAgICAgICAgICBwb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoSC5wb2ludDtcblxuICAgICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICAgIHkgPSBwb2ludC55O1xuICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIocG9pbnQsIGN1cnJlbnQpO1xuICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFYoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgdmFyIHBhdGhQYXJzZXIgPSB0aGlzLnBhdGhQYXJzZXI7XG5cbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aFYgPSBQYXRoRWxlbWVudC5wYXRoVihwYXRoUGFyc2VyKSxcbiAgICAgICAgICBjdXJyZW50ID0gX1BhdGhFbGVtZW50JHBhdGhWLmN1cnJlbnQsXG4gICAgICAgICAgcG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFYucG9pbnQ7XG5cbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhDXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhDKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgIHZhciBwYXRoUGFyc2VyID0gdGhpcy5wYXRoUGFyc2VyO1xuXG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhDID0gUGF0aEVsZW1lbnQucGF0aEMocGF0aFBhcnNlciksXG4gICAgICAgICAgY3VycmVudCA9IF9QYXRoRWxlbWVudCRwYXRoQy5jdXJyZW50LFxuICAgICAgICAgIHBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhDLnBvaW50LFxuICAgICAgICAgIGNvbnRyb2xQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoQy5jb250cm9sUG9pbnQsXG4gICAgICAgICAgY3VycmVudFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhDLmN1cnJlbnRQb2ludDtcblxuICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIHBvaW50KTtcbiAgICAgIGJvdW5kaW5nQm94LmFkZEJlemllckN1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoUyhjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICB2YXIgcGF0aFBhcnNlciA9IHRoaXMucGF0aFBhcnNlcjtcblxuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoUyA9IFBhdGhFbGVtZW50LnBhdGhTKHBhdGhQYXJzZXIpLFxuICAgICAgICAgIGN1cnJlbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFMuY3VycmVudCxcbiAgICAgICAgICBwb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoUy5wb2ludCxcbiAgICAgICAgICBjb250cm9sUG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFMuY29udHJvbFBvaW50LFxuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoUy5jdXJyZW50UG9pbnQ7XG5cbiAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBwb2ludCk7XG4gICAgICBib3VuZGluZ0JveC5hZGRCZXppZXJDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgcG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFEoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgdmFyIHBhdGhQYXJzZXIgPSB0aGlzLnBhdGhQYXJzZXI7XG5cbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aFEgPSBQYXRoRWxlbWVudC5wYXRoUShwYXRoUGFyc2VyKSxcbiAgICAgICAgICBjdXJyZW50ID0gX1BhdGhFbGVtZW50JHBhdGhRLmN1cnJlbnQsXG4gICAgICAgICAgY29udHJvbFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhRLmNvbnRyb2xQb2ludCxcbiAgICAgICAgICBjdXJyZW50UG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFEuY3VycmVudFBvaW50O1xuXG4gICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihjdXJyZW50UG9pbnQsIGNvbnRyb2xQb2ludCwgY29udHJvbFBvaW50KTtcbiAgICAgIGJvdW5kaW5nQm94LmFkZFF1YWRyYXRpY0N1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoVFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoVChjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICB2YXIgcGF0aFBhcnNlciA9IHRoaXMucGF0aFBhcnNlcjtcblxuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoVCA9IFBhdGhFbGVtZW50LnBhdGhUKHBhdGhQYXJzZXIpLFxuICAgICAgICAgIGN1cnJlbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFQuY3VycmVudCxcbiAgICAgICAgICBjb250cm9sUG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFQuY29udHJvbFBvaW50LFxuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoVC5jdXJyZW50UG9pbnQ7XG5cbiAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBjb250cm9sUG9pbnQpO1xuICAgICAgYm91bmRpbmdCb3guYWRkUXVhZHJhdGljQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhBXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhBKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgIHZhciBwYXRoUGFyc2VyID0gdGhpcy5wYXRoUGFyc2VyO1xuXG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhBID0gUGF0aEVsZW1lbnQucGF0aEEocGF0aFBhcnNlciksXG4gICAgICAgICAgY3VycmVudFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhBLmN1cnJlbnRQb2ludCxcbiAgICAgICAgICByWCA9IF9QYXRoRWxlbWVudCRwYXRoQS5yWCxcbiAgICAgICAgICByWSA9IF9QYXRoRWxlbWVudCRwYXRoQS5yWSxcbiAgICAgICAgICBzd2VlcEZsYWcgPSBfUGF0aEVsZW1lbnQkcGF0aEEuc3dlZXBGbGFnLFxuICAgICAgICAgIHhBeGlzUm90YXRpb24gPSBfUGF0aEVsZW1lbnQkcGF0aEEueEF4aXNSb3RhdGlvbixcbiAgICAgICAgICBjZW50cCA9IF9QYXRoRWxlbWVudCRwYXRoQS5jZW50cCxcbiAgICAgICAgICBhMSA9IF9QYXRoRWxlbWVudCRwYXRoQS5hMSxcbiAgICAgICAgICBhZCA9IF9QYXRoRWxlbWVudCRwYXRoQS5hZDsgLy8gZm9yIG1hcmtlcnNcblxuXG4gICAgICB2YXIgZGlyID0gMSAtIHN3ZWVwRmxhZyA/IDEuMCA6IC0xLjA7XG4gICAgICB2YXIgYWggPSBhMSArIGRpciAqIChhZCAvIDIuMCk7XG4gICAgICB2YXIgaGFsZldheSA9IG5ldyBQb2ludChjZW50cC54ICsgclggKiBNYXRoLmNvcyhhaCksIGNlbnRwLnkgKyByWSAqIE1hdGguc2luKGFoKSk7XG4gICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlckFuZ2xlKGhhbGZXYXksIGFoIC0gZGlyICogTWF0aC5QSSAvIDIpO1xuICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXJBbmdsZShjdXJyZW50UG9pbnQsIGFoIC0gZGlyICogTWF0aC5QSSk7XG4gICAgICBib3VuZGluZ0JveC5hZGRQb2ludChjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpOyAvLyBUT0RPOiB0aGlzIGlzIHRvbyBuYWl2ZSwgbWFrZSBpdCBiZXR0ZXJcblxuICAgICAgaWYgKGN0eCAmJiAhaXNOYU4oYTEpICYmICFpc05hTihhZCkpIHtcbiAgICAgICAgdmFyIHIgPSByWCA+IHJZID8gclggOiByWTtcbiAgICAgICAgdmFyIHN4ID0gclggPiByWSA/IDEgOiByWCAvIHJZO1xuICAgICAgICB2YXIgc3kgPSByWCA+IHJZID8gclkgLyByWCA6IDE7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY2VudHAueCwgY2VudHAueSk7XG4gICAgICAgIGN0eC5yb3RhdGUoeEF4aXNSb3RhdGlvbik7XG4gICAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xuICAgICAgICBjdHguYXJjKDAsIDAsIHIsIGExLCBhMSArIGFkLCBCb29sZWFuKDEgLSBzd2VlcEZsYWcpKTtcbiAgICAgICAgY3R4LnNjYWxlKDEgLyBzeCwgMSAvIHN5KTtcbiAgICAgICAgY3R4LnJvdGF0ZSgteEF4aXNSb3RhdGlvbik7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLWNlbnRwLngsIC1jZW50cC55KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFooY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgUGF0aEVsZW1lbnQucGF0aFoodGhpcy5wYXRoUGFyc2VyKTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICAvLyBvbmx5IGNsb3NlIHBhdGggaWYgaXQgaXMgbm90IGEgc3RyYWlnaHQgbGluZVxuICAgICAgICBpZiAoYm91bmRpbmdCb3gueDEgIT09IGJvdW5kaW5nQm94LngyICYmIGJvdW5kaW5nQm94LnkxICE9PSBib3VuZGluZ0JveC55Mikge1xuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhdGhNXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhNKHBhdGhQYXJzZXIpIHtcbiAgICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgIHBhdGhQYXJzZXIuc3RhcnQgPSBwYXRoUGFyc2VyLmN1cnJlbnQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDogcG9pbnRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhMKHBhdGhQYXJzZXIpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gcGF0aFBhcnNlci5jdXJyZW50O1xuICAgICAgdmFyIHBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudDogY3VycmVudCxcbiAgICAgICAgcG9pbnQ6IHBvaW50XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoSFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoSChwYXRoUGFyc2VyKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHBhdGhQYXJzZXIuY3VycmVudCxcbiAgICAgICAgICBjb21tYW5kID0gcGF0aFBhcnNlci5jb21tYW5kO1xuICAgICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KChjb21tYW5kLnJlbGF0aXZlID8gY3VycmVudC54IDogMCkgKyBjb21tYW5kLngsIGN1cnJlbnQueSk7XG4gICAgICBwYXRoUGFyc2VyLmN1cnJlbnQgPSBwb2ludDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgICAgIHBvaW50OiBwb2ludFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFYocGF0aFBhcnNlcikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBwYXRoUGFyc2VyLmN1cnJlbnQsXG4gICAgICAgICAgY29tbWFuZCA9IHBhdGhQYXJzZXIuY29tbWFuZDtcbiAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludChjdXJyZW50LngsIChjb21tYW5kLnJlbGF0aXZlID8gY3VycmVudC55IDogMCkgKyBjb21tYW5kLnkpO1xuICAgICAgcGF0aFBhcnNlci5jdXJyZW50ID0gcG9pbnQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgICAgICBwb2ludDogcG9pbnRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhDXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhDKHBhdGhQYXJzZXIpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gcGF0aFBhcnNlci5jdXJyZW50O1xuICAgICAgdmFyIHBvaW50ID0gcGF0aFBhcnNlci5nZXRQb2ludCgneDEnLCAneTEnKTtcbiAgICAgIHZhciBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ29udHJvbFBvaW50KCd4MicsICd5MicpO1xuICAgICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgY29udHJvbFBvaW50OiBjb250cm9sUG9pbnQsXG4gICAgICAgIGN1cnJlbnRQb2ludDogY3VycmVudFBvaW50XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoUyhwYXRoUGFyc2VyKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHBhdGhQYXJzZXIuY3VycmVudDtcbiAgICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgICB2YXIgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0NvbnRyb2xQb2ludCgneDInLCAneTInKTtcbiAgICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGNvbnRyb2xQb2ludDogY29udHJvbFBvaW50LFxuICAgICAgICBjdXJyZW50UG9pbnQ6IGN1cnJlbnRQb2ludFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFEocGF0aFBhcnNlcikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBwYXRoUGFyc2VyLmN1cnJlbnQ7XG4gICAgICB2YXIgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0NvbnRyb2xQb2ludCgneDEnLCAneTEnKTtcbiAgICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgICAgICBjb250cm9sUG9pbnQ6IGNvbnRyb2xQb2ludCxcbiAgICAgICAgY3VycmVudFBvaW50OiBjdXJyZW50UG9pbnRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhUXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhUKHBhdGhQYXJzZXIpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gcGF0aFBhcnNlci5jdXJyZW50O1xuICAgICAgdmFyIGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgICBwYXRoUGFyc2VyLmNvbnRyb2wgPSBjb250cm9sUG9pbnQ7XG4gICAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudDogY3VycmVudCxcbiAgICAgICAgY29udHJvbFBvaW50OiBjb250cm9sUG9pbnQsXG4gICAgICAgIGN1cnJlbnRQb2ludDogY3VycmVudFBvaW50XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoQVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoQShwYXRoUGFyc2VyKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHBhdGhQYXJzZXIuY3VycmVudCxcbiAgICAgICAgICBjb21tYW5kID0gcGF0aFBhcnNlci5jb21tYW5kO1xuICAgICAgdmFyIHJYID0gY29tbWFuZC5yWCxcbiAgICAgICAgICByWSA9IGNvbW1hbmQuclksXG4gICAgICAgICAgeFJvdCA9IGNvbW1hbmQueFJvdCxcbiAgICAgICAgICBsQXJjRmxhZyA9IGNvbW1hbmQubEFyY0ZsYWcsXG4gICAgICAgICAgc3dlZXBGbGFnID0gY29tbWFuZC5zd2VlcEZsYWc7XG4gICAgICB2YXIgeEF4aXNSb3RhdGlvbiA9IHhSb3QgKiAoTWF0aC5QSSAvIDE4MC4wKTtcbiAgICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7IC8vIENvbnZlcnNpb24gZnJvbSBlbmRwb2ludCB0byBjZW50ZXIgcGFyYW1ldGVyaXphdGlvblxuICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAvLyB4MScsIHkxJ1xuXG4gICAgICB2YXIgY3VycnAgPSBuZXcgUG9pbnQoTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC54IC0gY3VycmVudFBvaW50LngpIC8gMi4wICsgTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC55IC0gY3VycmVudFBvaW50LnkpIC8gMi4wLCAtTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC54IC0gY3VycmVudFBvaW50LngpIC8gMi4wICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC55IC0gY3VycmVudFBvaW50LnkpIC8gMi4wKTsgLy8gYWRqdXN0IHJhZGlpXG5cbiAgICAgIHZhciBsID0gTWF0aC5wb3coY3VycnAueCwgMikgLyBNYXRoLnBvdyhyWCwgMikgKyBNYXRoLnBvdyhjdXJycC55LCAyKSAvIE1hdGgucG93KHJZLCAyKTtcblxuICAgICAgaWYgKGwgPiAxKSB7XG4gICAgICAgIHJYICo9IE1hdGguc3FydChsKTtcbiAgICAgICAgclkgKj0gTWF0aC5zcXJ0KGwpO1xuICAgICAgfSAvLyBjeCcsIGN5J1xuXG5cbiAgICAgIHZhciBzID0gKGxBcmNGbGFnID09PSBzd2VlcEZsYWcgPyAtMSA6IDEpICogTWF0aC5zcXJ0KChNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhyWSwgMikgLSBNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhjdXJycC55LCAyKSAtIE1hdGgucG93KHJZLCAyKSAqIE1hdGgucG93KGN1cnJwLngsIDIpKSAvIChNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhjdXJycC55LCAyKSArIE1hdGgucG93KHJZLCAyKSAqIE1hdGgucG93KGN1cnJwLngsIDIpKSk7XG5cbiAgICAgIGlmIChpc05hTihzKSkge1xuICAgICAgICBzID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNwcCA9IG5ldyBQb2ludChzICogclggKiBjdXJycC55IC8gclksIHMgKiAtclkgKiBjdXJycC54IC8gclgpOyAvLyBjeCwgY3lcblxuICAgICAgdmFyIGNlbnRwID0gbmV3IFBvaW50KChjdXJyZW50LnggKyBjdXJyZW50UG9pbnQueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC54IC0gTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiBjcHAueSwgKGN1cnJlbnQueSArIGN1cnJlbnRQb2ludC55KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnggKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC55KTsgLy8gaW5pdGlhbCBhbmdsZVxuXG4gICAgICB2YXIgYTEgPSB2ZWN0b3JzQW5nbGUoWzEsIDBdLCBbKGN1cnJwLnggLSBjcHAueCkgLyByWCwgKGN1cnJwLnkgLSBjcHAueSkgLyByWV0pOyAvLyDOuDFcbiAgICAgIC8vIGFuZ2xlIGRlbHRhXG5cbiAgICAgIHZhciB1ID0gWyhjdXJycC54IC0gY3BwLngpIC8gclgsIChjdXJycC55IC0gY3BwLnkpIC8gclldO1xuICAgICAgdmFyIHYgPSBbKC1jdXJycC54IC0gY3BwLngpIC8gclgsICgtY3VycnAueSAtIGNwcC55KSAvIHJZXTtcbiAgICAgIHZhciBhZCA9IHZlY3RvcnNBbmdsZSh1LCB2KTsgLy8gzpTOuFxuXG4gICAgICBpZiAodmVjdG9yc1JhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICAgIGFkID0gTWF0aC5QSTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZlY3RvcnNSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICAgIGFkID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudFBvaW50OiBjdXJyZW50UG9pbnQsXG4gICAgICAgIHJYOiByWCxcbiAgICAgICAgclk6IHJZLFxuICAgICAgICBzd2VlcEZsYWc6IHN3ZWVwRmxhZyxcbiAgICAgICAgeEF4aXNSb3RhdGlvbjogeEF4aXNSb3RhdGlvbixcbiAgICAgICAgY2VudHA6IGNlbnRwLFxuICAgICAgICBhMTogYTEsXG4gICAgICAgIGFkOiBhZFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFoocGF0aFBhcnNlcikge1xuICAgICAgcGF0aFBhcnNlci5jdXJyZW50ID0gcGF0aFBhcnNlci5zdGFydDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGF0aEVsZW1lbnQ7XG59KFJlbmRlcmVkRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRGKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEYoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEYoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgR2x5cGhFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGF0aEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShHbHlwaEVsZW1lbnQsIF9QYXRoRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRGKEdseXBoRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gR2x5cGhFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBHbHlwaEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdnbHlwaCc7XG4gICAgX3RoaXMuaG9yaXpBZHZYID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdob3Jpei1hZHYteCcpLmdldE51bWJlcigpO1xuICAgIF90aGlzLnVuaWNvZGUgPSBfdGhpcy5nZXRBdHRyaWJ1dGUoJ3VuaWNvZGUnKS5nZXRTdHJpbmcoKTtcbiAgICBfdGhpcy5hcmFiaWNGb3JtID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdhcmFiaWMtZm9ybScpLmdldFN0cmluZygpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBHbHlwaEVsZW1lbnQ7XG59KFBhdGhFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJEUoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkRSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkRSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBUZXh0RWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlbmRlcmVkRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFRleHRFbGVtZW50LCBfUmVuZGVyZWRFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJEUoVGV4dEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFRleHRFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBUZXh0RWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBub2RlLCAodGhpcyBpbnN0YW5jZW9mIFRleHRFbGVtZW50ID8gdGhpcy5jb25zdHJ1Y3RvciA6IHZvaWQgMCkgPT09IFRleHRFbGVtZW50ID8gdHJ1ZSA6IGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAndGV4dCc7XG4gICAgX3RoaXMueCA9IDA7XG4gICAgX3RoaXMueSA9IDA7XG4gICAgX3RoaXMubWVhc3VyZUNhY2hlID0gLTE7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUZXh0RWxlbWVudCwgW3tcbiAgICBrZXk6IFwic2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb250ZXh0KGN0eCkge1xuICAgICAgdmFyIGZyb21NZWFzdXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgX2dldF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUZXh0RWxlbWVudC5wcm90b3R5cGUpLCBcInNldENvbnRleHRcIiwgdGhpcykuY2FsbCh0aGlzLCBjdHgsIGZyb21NZWFzdXJlKTtcblxuICAgICAgdmFyIHRleHRCYXNlbGluZSA9IHRoaXMuZ2V0U3R5bGUoJ2RvbWluYW50LWJhc2VsaW5lJykuZ2V0VGV4dEJhc2VsaW5lKCkgfHwgdGhpcy5nZXRTdHlsZSgnYWxpZ25tZW50LWJhc2VsaW5lJykuZ2V0VGV4dEJhc2VsaW5lKCk7XG5cbiAgICAgIGlmICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZUNvb3JkaW5hdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVDb29yZGluYXRlcygpIHtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgdGhpcy5sZWFmVGV4dHMgPSBbXTtcbiAgICAgIHRoaXMudGV4dENodW5rU3RhcnQgPSAwO1xuICAgICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgdGhpcy5tYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VEVsZW1lbnRCb3VuZGluZ0JveChjdHgpO1xuICAgICAgfSAvLyBmaXJzdCwgY2FsY3VsYXRlIGNoaWxkIHBvc2l0aW9uc1xuXG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvb3JkaW5hdGVzKCk7XG4gICAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KTtcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IG51bGw7IC8vIHRoZW4gY2FsY3VsYXRlIGJvdW5kaW5nIGJveFxuXG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgdmFyIGNoaWxkQm91bmRpbmdCb3ggPSBfdGhpczIuZ2V0Q2hpbGRCb3VuZGluZ0JveChjdHgsIF90aGlzMiwgX3RoaXMyLCBpKTtcblxuICAgICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgYm91bmRpbmdCb3ggPSBjaGlsZEJvdW5kaW5nQm94O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkQm91bmRpbmdCb3gpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9udFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9udFNpemUoKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgdmFyIGluaGVyaXRGb250U2l6ZSA9IEZvbnQucGFyc2UoZG9jdW1lbnQuY3R4LmZvbnQpLmZvbnRTaXplO1xuICAgICAgdmFyIGZvbnRTaXplID0gcGFyZW50LmdldFN0eWxlKCdmb250LXNpemUnKS5nZXROdW1iZXIoaW5oZXJpdEZvbnRTaXplKTtcbiAgICAgIHJldHVybiBmb250U2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VEVsZW1lbnRCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRURWxlbWVudEJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSAtIGZvbnRTaXplLCB0aGlzLnggKyB0aGlzLm1lYXN1cmVUZXh0KGN0eCksIHRoaXMueSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEdseXBoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdseXBoKGZvbnQsIHRleHQsIGkpIHtcbiAgICAgIHZhciBjaGFyID0gdGV4dFtpXTtcbiAgICAgIHZhciBnbHlwaCA9IG51bGw7XG5cbiAgICAgIGlmIChmb250LmlzQXJhYmljKSB7XG4gICAgICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHByZXZDaGFyID0gdGV4dFtpIC0gMV07XG4gICAgICAgIHZhciBuZXh0Q2hhciA9IHRleHRbaSArIDFdO1xuICAgICAgICB2YXIgYXJhYmljRm9ybSA9ICdpc29sYXRlZCc7XG5cbiAgICAgICAgaWYgKChpID09PSAwIHx8IHByZXZDaGFyID09PSAnICcpICYmIGkgPCBsZW4gLSAxICYmIG5leHRDaGFyICE9PSAnICcpIHtcbiAgICAgICAgICBhcmFiaWNGb3JtID0gJ3Rlcm1pbmFsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID4gMCAmJiBwcmV2Q2hhciAhPT0gJyAnICYmIGkgPCBsZW4gLSAxICYmIG5leHRDaGFyICE9PSAnICcpIHtcbiAgICAgICAgICBhcmFiaWNGb3JtID0gJ21lZGlhbCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA+IDAgJiYgcHJldkNoYXIgIT09ICcgJyAmJiAoaSA9PT0gbGVuIC0gMSB8fCBuZXh0Q2hhciA9PT0gJyAnKSkge1xuICAgICAgICAgIGFyYWJpY0Zvcm0gPSAnaW5pdGlhbCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZvbnQuZ2x5cGhzW2NoYXJdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE5FRUQgVEVTVFxuICAgICAgICAgIHZhciBtYXliZUdseXBoID0gZm9udC5nbHlwaHNbY2hhcl07XG4gICAgICAgICAgZ2x5cGggPSBtYXliZUdseXBoIGluc3RhbmNlb2YgR2x5cGhFbGVtZW50ID8gbWF5YmVHbHlwaCA6IG1heWJlR2x5cGhbYXJhYmljRm9ybV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdseXBoID0gZm9udC5nbHlwaHNbY2hhcl07XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2x5cGgpIHtcbiAgICAgICAgZ2x5cGggPSBmb250Lm1pc3NpbmdHbHlwaDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdseXBoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHQoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRleHRGcm9tTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0RnJvbU5vZGUobm9kZSkge1xuICAgICAgdmFyIHRleHROb2RlID0gbm9kZSB8fCB0aGlzLm5vZGU7XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IEFycmF5LmZyb20odGV4dE5vZGUucGFyZW50Tm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgIHZhciBpbmRleCA9IGNoaWxkTm9kZXMuaW5kZXhPZih0ZXh0Tm9kZSk7XG4gICAgICB2YXIgbGFzdEluZGV4ID0gY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHRleHQgPSBjb21wcmVzc1NwYWNlcyggLy8gdGV4dE5vZGUudmFsdWVcbiAgICAgIC8vIHx8IHRleHROb2RlLnRleHRcbiAgICAgIHRleHROb2RlLnRleHRDb250ZW50IHx8ICcnKTtcblxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHRleHQgPSB0cmltTGVmdCh0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgdGV4dCA9IHRyaW1SaWdodCh0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckNoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICB0aGlzLnJlbmRlclRFbGVtZW50Q2hpbGRyZW4oY3R4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBmaXJzdCwgY2FsY3VsYXRlIGNoaWxkIHBvc2l0aW9uc1xuXG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvb3JkaW5hdGVzKCk7XG4gICAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KTsgLy8gdGhlbiByZW5kZXJcblxuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgIF90aGlzMy5yZW5kZXJDaGlsZChjdHgsIF90aGlzMywgX3RoaXMzLCBpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG1vdXNlID0gdGhpcy5kb2N1bWVudC5zY3JlZW4ubW91c2U7IC8vIERvIG5vdCBjYWxjIGJvdW5kaW5nIGJveCBpZiBtb3VzZSBpcyBub3Qgd29ya2luZy5cblxuICAgICAgaWYgKG1vdXNlLmlzV29ya2luZygpKSB7XG4gICAgICAgIG1vdXNlLmNoZWNrQm91bmRpbmdCb3godGhpcywgdGhpcy5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyVEVsZW1lbnRDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJURWxlbWVudENoaWxkcmVuKGN0eCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgIHZhciByZW5kZXJUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgICB2YXIgY3VzdG9tRm9udCA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIGlmIChjdXN0b21Gb250KSB7XG4gICAgICAgIHZhciB1bml0c1BlckVtID0gY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtO1xuICAgICAgICB2YXIgY3R4Rm9udCA9IEZvbnQucGFyc2UoZG9jdW1lbnQuY3R4LmZvbnQpO1xuICAgICAgICB2YXIgZm9udFNpemUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc2l6ZScpLmdldE51bWJlcihjdHhGb250LmZvbnRTaXplKTtcbiAgICAgICAgdmFyIGZvbnRTdHlsZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zdHlsZScpLmdldFN0cmluZyhjdHhGb250LmZvbnRTdHlsZSk7XG4gICAgICAgIHZhciBzY2FsZSA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcbiAgICAgICAgdmFyIHRleHQgPSBjdXN0b21Gb250LmlzUlRMID8gcmVuZGVyVGV4dC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogcmVuZGVyVGV4dDtcbiAgICAgICAgdmFyIGR4ID0gdG9OdW1iZXJzKHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoY3VzdG9tRm9udCwgdGV4dCwgaSk7XG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgY3R4LnNjYWxlKHNjYWxlLCAtc2NhbGUpO1xuICAgICAgICAgIHZhciBsdyA9IGN0eC5saW5lV2lkdGg7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGN0eC5saW5lV2lkdGggKiB1bml0c1BlckVtIC8gZm9udFNpemU7XG5cbiAgICAgICAgICBpZiAoZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgICAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAuNCwgMSwgMCwgMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2x5cGgucmVuZGVyKGN0eCk7XG5cbiAgICAgICAgICBpZiAoZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgICAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAtLjQsIDEsIDAsIDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsdztcbiAgICAgICAgICBjdHguc2NhbGUoMSAvIHNjYWxlLCAtMSAvIHNjYWxlKTtcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKC10aGlzLngsIC10aGlzLnkpO1xuICAgICAgICAgIHRoaXMueCArPSBmb250U2l6ZSAqIChnbHlwaC5ob3JpekFkdlggfHwgY3VzdG9tRm9udC5ob3JpekFkdlgpIC8gdW5pdHNQZXJFbTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZHhbaV0gIT09ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICAgIHRoaXMueCArPSBkeFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgIHkgPSB0aGlzLnk7IC8vIE5FRUQgVEVTVFxuICAgICAgLy8gaWYgKGN0eC5wYWludE9yZGVyID09PSAnc3Ryb2tlJykge1xuICAgICAgLy8gXHRpZiAoY3R4LnN0cm9rZVN0eWxlKSB7XG4gICAgICAvLyBcdFx0Y3R4LnN0cm9rZVRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgICAvLyBcdH1cbiAgICAgIC8vIFx0aWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgIC8vIFx0XHRjdHguZmlsbFRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgICAvLyBcdH1cbiAgICAgIC8vIH0gZWxzZSB7XG5cbiAgICAgIGlmIChjdHguZmlsbFN0eWxlKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgICBjdHguc3Ryb2tlVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAgIH0gLy8gfVxuXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5QW5jaG9yaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5QW5jaG9yaW5nKCkge1xuICAgICAgaWYgKHRoaXMudGV4dENodW5rU3RhcnQgPj0gdGhpcy5sZWFmVGV4dHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVGhpcyBpcyBiYXNpY2FsbHkgdGhlIFwiQXBwbHkgYW5jaG9yaW5nXCIgcGFydCBvZiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMi90ZXh0Lmh0bWwjVGV4dExheW91dEFsZ29yaXRobS5cbiAgICAgIC8vIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgd2UgYXBwbHkgdGhlIGFuY2hvcmluZyBhcyBzb29uIGFzIGEgY2h1bmsgaXMgZmluaXNoZWQuIFRoaXMgc2F2ZXMgc29tZSBleHRyYSBsb29waW5nLlxuICAgICAgLy8gVmVydGljYWwgdGV4dCBpcyBub3Qgc3VwcG9ydGVkLlxuXG5cbiAgICAgIHZhciBmaXJzdEVsZW1lbnQgPSB0aGlzLmxlYWZUZXh0c1t0aGlzLnRleHRDaHVua1N0YXJ0XTtcbiAgICAgIHZhciB0ZXh0QW5jaG9yID0gZmlyc3RFbGVtZW50LmdldFN0eWxlKCd0ZXh0LWFuY2hvcicpLmdldFN0cmluZygnc3RhcnQnKTtcbiAgICAgIHZhciBpc1JUTCA9IGZhbHNlOyAvLyB3ZSB0cmVhdCBSVEwgbGlrZSBMVFJcblxuICAgICAgdmFyIHNoaWZ0ID0gMDtcblxuICAgICAgaWYgKHRleHRBbmNob3IgPT09ICdzdGFydCcgJiYgIWlzUlRMIHx8IHRleHRBbmNob3IgPT09ICdlbmQnICYmIGlzUlRMKSB7XG4gICAgICAgIHNoaWZ0ID0gZmlyc3RFbGVtZW50LnggLSB0aGlzLm1pblg7XG4gICAgICB9IGVsc2UgaWYgKHRleHRBbmNob3IgPT09ICdlbmQnICYmICFpc1JUTCB8fCB0ZXh0QW5jaG9yID09PSAnc3RhcnQnICYmIGlzUlRMKSB7XG4gICAgICAgIHNoaWZ0ID0gZmlyc3RFbGVtZW50LnggLSB0aGlzLm1heFg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gKHRoaXMubWluWCArIHRoaXMubWF4WCkgLyAyO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50ZXh0Q2h1bmtTdGFydDsgaSA8IHRoaXMubGVhZlRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubGVhZlRleHRzW2ldLnggKz0gc2hpZnQ7XG4gICAgICB9IC8vIHN0YXJ0IG5ldyBjaHVua1xuXG5cbiAgICAgIHRoaXMubWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIHRoaXMubWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgIHRoaXMudGV4dENodW5rU3RhcnQgPSB0aGlzLmxlYWZUZXh0cy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShjdHgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgX3RoaXM0LmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGN0eCwgX3RoaXM0LCBfdGhpczQsIGkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFwcGx5QW5jaG9yaW5nKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKF8sIGkpIHtcbiAgICAgICAgICB0ZXh0UGFyZW50LmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9ubHkgbGVhZnMgYXJlIHJlbGV2YW50XG4gICAgICAgIHRoaXMuYWRqdXN0Q2hpbGRDb29yZGluYXRlcyhjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkanVzdENoaWxkQ29vcmRpbmF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0Q2hpbGRDb29yZGluYXRlcyhjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkLm1lYXN1cmVUZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNoaWxkLnNldENvbnRleHQoY3R4LCB0cnVlKTtcbiAgICAgIHZhciB4QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgICAgdmFyIHlBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgICB2YXIgZHhBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdkeCcpO1xuICAgICAgdmFyIGR5QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnZHknKTtcbiAgICAgIHZhciBjdXN0b21Gb250ID0gY2hpbGQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5JykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgdmFyIGlzUlRMID0gQm9vbGVhbihjdXN0b21Gb250KSAmJiBjdXN0b21Gb250LmlzUlRMO1xuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAvLyBGaXJzdCBjaGlsZHJlbiBpbmhlcml0IGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQocykuIFBvc2l0aW9uYWwgYXR0cmlidXRlc1xuICAgICAgICAvLyBhcmUgb25seSBpbmhlcml0ZWQgZnJvbSBhIHBhcmVudCB0byBpdCdzIGZpcnN0IGNoaWxkLlxuICAgICAgICBpZiAoIXhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB4QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ3gnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB5QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ3knKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgZHhBdHRyLnNldFZhbHVlKGNoaWxkLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgnZHgnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWR5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgZHlBdHRyLnNldFZhbHVlKGNoaWxkLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgnZHknKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoID0gY2hpbGQubWVhc3VyZVRleHQoY3R4KTtcblxuICAgICAgaWYgKGlzUlRMKSB7XG4gICAgICAgIHRleHRQYXJlbnQueCAtPSB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgLy8gYW4gXCJ4XCIgYXR0cmlidXRlIG1hcmtzIHRoZSBzdGFydCBvZiBhIG5ldyBjaHVua1xuICAgICAgICB0ZXh0UGFyZW50LmFwcGx5QW5jaG9yaW5nKCk7XG4gICAgICAgIGNoaWxkLnggPSB4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcblxuICAgICAgICBpZiAoZHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBjaGlsZC54ICs9IGR4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgdGV4dFBhcmVudC54ICs9IGR4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLnggPSB0ZXh0UGFyZW50Lng7XG4gICAgICB9XG5cbiAgICAgIHRleHRQYXJlbnQueCA9IGNoaWxkLng7XG5cbiAgICAgIGlmICghaXNSVEwpIHtcbiAgICAgICAgdGV4dFBhcmVudC54ICs9IHdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBjaGlsZC55ID0geUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICAgICAgaWYgKGR5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgY2hpbGQueSArPSBkeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHRleHRQYXJlbnQueSArPSBkeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC55ID0gdGV4dFBhcmVudC55O1xuICAgICAgfVxuXG4gICAgICB0ZXh0UGFyZW50LnkgPSBjaGlsZC55OyAvLyB1cGRhdGUgdGhlIGN1cnJlbnQgY2h1bmsgYW5kIGl0J3MgYm91bmRzXG5cbiAgICAgIHRleHRQYXJlbnQubGVhZlRleHRzLnB1c2goY2hpbGQpO1xuICAgICAgdGV4dFBhcmVudC5taW5YID0gTWF0aC5taW4odGV4dFBhcmVudC5taW5YLCBjaGlsZC54LCBjaGlsZC54ICsgd2lkdGgpO1xuICAgICAgdGV4dFBhcmVudC5tYXhYID0gTWF0aC5tYXgodGV4dFBhcmVudC5tYXhYLCBjaGlsZC54LCBjaGlsZC54ICsgd2lkdGgpO1xuICAgICAgY2hpbGQuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDaGlsZEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkQm91bmRpbmdCb3goY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTsgLy8gbm90IGEgdGV4dCBub2RlP1xuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkLmdldEJvdW5kaW5nQm94ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSBjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpO1xuXG4gICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgIHZhciBjaGlsZEJvdW5kaW5nQm94ID0gdGV4dFBhcmVudC5nZXRDaGlsZEJvdW5kaW5nQm94KGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZEJvdW5kaW5nQm94KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDaGlsZChjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgY2hpbGQucmVuZGVyKGN0eCk7XG4gICAgICBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgIHRleHRQYXJlbnQucmVuZGVyQ2hpbGQoY3R4LCB0ZXh0UGFyZW50LCBjaGlsZCwgaSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVhc3VyZVRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVhc3VyZVRleHQoY3R4KSB7XG4gICAgICB2YXIgbWVhc3VyZUNhY2hlID0gdGhpcy5tZWFzdXJlQ2FjaGU7XG5cbiAgICAgIGlmICh+bWVhc3VyZUNhY2hlKSB7XG4gICAgICAgIHJldHVybiBtZWFzdXJlQ2FjaGU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZW5kZXJUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgICB2YXIgbWVhc3VyZSA9IHRoaXMubWVhc3VyZVRhcmdldFRleHQoY3R4LCByZW5kZXJUZXh0KTtcbiAgICAgIHRoaXMubWVhc3VyZUNhY2hlID0gbWVhc3VyZTtcbiAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZWFzdXJlVGFyZ2V0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHRhcmdldFRleHQpIHtcbiAgICAgIGlmICghdGFyZ2V0VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgIHZhciBjdXN0b21Gb250ID0gcGFyZW50LmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcblxuICAgICAgaWYgKGN1c3RvbUZvbnQpIHtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgICB2YXIgdGV4dCA9IGN1c3RvbUZvbnQuaXNSVEwgPyB0YXJnZXRUZXh0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiB0YXJnZXRUZXh0O1xuICAgICAgICB2YXIgZHggPSB0b051bWJlcnMocGFyZW50LmdldEF0dHJpYnV0ZSgnZHgnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgdmFyIF9tZWFzdXJlID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcbiAgICAgICAgICBfbWVhc3VyZSArPSAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAqIGZvbnRTaXplIC8gY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBkeFtpXSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKGR4W2ldKSkge1xuICAgICAgICAgICAgX21lYXN1cmUgKz0gZHhbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9tZWFzdXJlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWN0eC5tZWFzdXJlVGV4dCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0VGV4dC5sZW5ndGggKiAxMDtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuc2V0Q29udGV4dChjdHgsIHRydWUpO1xuXG4gICAgICB2YXIgX2N0eCRtZWFzdXJlVGV4dCA9IGN0eC5tZWFzdXJlVGV4dCh0YXJnZXRUZXh0KSxcbiAgICAgICAgICBtZWFzdXJlID0gX2N0eCRtZWFzdXJlVGV4dC53aWR0aDtcblxuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBJbmhlcml0cyBwb3NpdGlvbmFsIGF0dHJpYnV0ZXMgZnJvbSB7QGxpbmsgVGV4dEVsZW1lbnR9IHBhcmVudChzKS4gQXR0cmlidXRlc1xyXG4gICAgICogYXJlIG9ubHkgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgdG8gaXRzIGZpcnN0IGNoaWxkLlxyXG4gICAgICogQHBhcmFtIG5hbWUgLSBUaGUgYXR0cmlidXRlIG5hbWUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYXR0cmlidXRlIHZhbHVlIG9yIG51bGwuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEluaGVyaXRlZEF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmhlcml0ZWRBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLGNvbnNpc3RlbnQtdGhpc1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAoY3VycmVudCBpbnN0YW5jZW9mIFRleHRFbGVtZW50ICYmIGN1cnJlbnQuaXNGaXJzdENoaWxkKCkpIHtcbiAgICAgICAgdmFyIHBhcmVudEF0dHIgPSBjdXJyZW50LnBhcmVudC5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICAgICAgaWYgKHBhcmVudEF0dHIuaGFzVmFsdWUodHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50QXR0ci5nZXRWYWx1ZSgnMCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dEVsZW1lbnQ7XG59KFJlbmRlcmVkRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciREKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEQoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgVFNwYW5FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGV4dEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUU3BhbkVsZW1lbnQsIF9UZXh0RWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciREKFRTcGFuRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gVFNwYW5FbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBUU3BhbkVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgKHRoaXMgaW5zdGFuY2VvZiBUU3BhbkVsZW1lbnQgPyB0aGlzLmNvbnN0cnVjdG9yIDogdm9pZCAwKSA9PT0gVFNwYW5FbGVtZW50ID8gdHJ1ZSA6IGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAndHNwYW4nOyAvLyBpZiB0aGlzIG5vZGUgaGFzIGNoaWxkcmVuLCB0aGVuIHRoZXkgb3duIHRoZSB0ZXh0XG5cbiAgICBfdGhpcy50ZXh0ID0gX3RoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCA/ICcnIDogX3RoaXMuZ2V0VGV4dEZyb21Ob2RlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUU3BhbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcImdldFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRTcGFuRWxlbWVudDtcbn0oVGV4dEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkQyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRDKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRDKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFRleHROb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVFNwYW5FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVGV4dE5vZGUsIF9UU3BhbkVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkQyhUZXh0Tm9kZSk7XG5cbiAgZnVuY3Rpb24gVGV4dE5vZGUoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBUZXh0Tm9kZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAndGV4dE5vZGUnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBUZXh0Tm9kZTtcbn0oVFNwYW5FbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJEIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkQigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkQigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBTVkdFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVuZGVyZWRFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oU1ZHRWxlbWVudCwgX1JlbmRlcmVkRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRCKFNWR0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFNWR0VsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBTVkdFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdzdmcnO1xuICAgIF90aGlzLnJvb3QgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFNWR0VsZW1lbnQsIFt7XG4gICAga2V5OiBcInNldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29udGV4dChjdHgpIHtcbiAgICAgIHZhciBfdGhpcyRub2RlJHBhcmVudE5vZGU7XG5cbiAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQ7XG4gICAgICB2YXIgc2NyZWVuID0gZG9jdW1lbnQuc2NyZWVuLFxuICAgICAgICAgIHdpbmRvdyA9IGRvY3VtZW50LndpbmRvdztcbiAgICAgIHZhciBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgICAgc2NyZWVuLnNldERlZmF1bHRzKGN0eCk7XG5cbiAgICAgIGlmIChjYW52YXMuc3R5bGUgJiYgdHlwZW9mIGN0eC5mb250ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjdHguZm9udCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNhbnZhcykuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udCcpO1xuICAgICAgICB2YXIgZm9udFNpemVQcm9wID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZm9udFNpemUnLCBGb250LnBhcnNlKGN0eC5mb250KS5mb250U2l6ZSk7XG5cbiAgICAgICAgaWYgKGZvbnRTaXplUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgZG9jdW1lbnQucm9vdEVtU2l6ZSA9IGZvbnRTaXplUHJvcC5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgICBkb2N1bWVudC5lbVNpemUgPSBkb2N1bWVudC5yb290RW1TaXplO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNyZWF0ZSBuZXcgdmlldyBwb3J0XG5cblxuICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3knLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9zY3JlZW4kdmlld1BvcnQgPSBzY3JlZW4udmlld1BvcnQsXG4gICAgICAgICAgd2lkdGggPSBfc2NyZWVuJHZpZXdQb3J0LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9zY3JlZW4kdmlld1BvcnQuaGVpZ2h0O1xuXG4gICAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkge1xuICAgICAgICB0aGlzLmdldFN0eWxlKCd3aWR0aCcsIHRydWUpLnNldFZhbHVlKCcxMDAlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkge1xuICAgICAgICB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCB0cnVlKS5zZXRWYWx1ZSgnMTAwJScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuaGFzVmFsdWUoKSkge1xuICAgICAgICB0aGlzLmdldFN0eWxlKCdjb2xvcicsIHRydWUpLnNldFZhbHVlKCdibGFjaycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmWEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWCcpO1xuICAgICAgdmFyIHJlZllBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlknKTtcbiAgICAgIHZhciB2aWV3Qm94QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgICB2YXIgdmlld0JveCA9IHZpZXdCb3hBdHRyLmhhc1ZhbHVlKCkgPyB0b051bWJlcnModmlld0JveEF0dHIuZ2V0U3RyaW5nKCkpIDogbnVsbDtcbiAgICAgIHZhciBjbGlwID0gIXRoaXMucm9vdCAmJiB0aGlzLmdldFN0eWxlKCdvdmVyZmxvdycpLmdldFZhbHVlKCdoaWRkZW4nKSAhPT0gJ3Zpc2libGUnO1xuICAgICAgdmFyIG1pblggPSAwO1xuICAgICAgdmFyIG1pblkgPSAwO1xuICAgICAgdmFyIGNsaXBYID0gMDtcbiAgICAgIHZhciBjbGlwWSA9IDA7XG5cbiAgICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICAgIG1pblggPSB2aWV3Qm94WzBdO1xuICAgICAgICBtaW5ZID0gdmlld0JveFsxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbWFya2VyJykge1xuICAgICAgICAgIGNsaXBYID0gbWluWDtcbiAgICAgICAgICBjbGlwWSA9IG1pblk7XG4gICAgICAgICAgbWluWCA9IDA7XG4gICAgICAgICAgbWluWSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2NyZWVuLnZpZXdQb3J0LnNldEN1cnJlbnQod2lkdGgsIGhlaWdodCk7IC8vIERlZmF1bHQgdmFsdWUgb2YgdHJhbnNmb3JtLW9yaWdpbiBpcyBjZW50ZXIgb25seSBmb3Igcm9vdCBTVkcgZWxlbWVudHNcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvdHJhbnNmb3JtLW9yaWdpblxuXG4gICAgICBpZiAodGhpcy5ub2RlIC8vIGlzIG5vdCB0ZW1wb3JhcnkgU1ZHRWxlbWVudFxuICAgICAgJiYgKCF0aGlzLnBhcmVudCB8fCAoKF90aGlzJG5vZGUkcGFyZW50Tm9kZSA9IHRoaXMubm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfdGhpcyRub2RlJHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG5vZGUkcGFyZW50Tm9kZS5ub2RlTmFtZSkgPT09ICdmb3JlaWduT2JqZWN0JykgJiYgdGhpcy5nZXRTdHlsZSgndHJhbnNmb3JtJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCBmYWxzZSwgdHJ1ZSkuaGFzVmFsdWUoKSkge1xuICAgICAgICB0aGlzLmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgdHJ1ZSwgdHJ1ZSkuc2V0VmFsdWUoJzUwJSA1MCUnKTtcbiAgICAgIH1cblxuICAgICAgX2dldF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTVkdFbGVtZW50LnByb3RvdHlwZSksIFwic2V0Q29udGV4dFwiLCB0aGlzKS5jYWxsKHRoaXMsIGN0eCk7XG5cbiAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKSk7XG5cbiAgICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICAgIHdpZHRoID0gdmlld0JveFsyXTtcbiAgICAgICAgaGVpZ2h0ID0gdmlld0JveFszXTtcbiAgICAgIH1cblxuICAgICAgZG9jdW1lbnQuc2V0Vmlld0JveCh7XG4gICAgICAgIGN0eDogY3R4LFxuICAgICAgICBhc3BlY3RSYXRpbzogdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSxcbiAgICAgICAgd2lkdGg6IHNjcmVlbi52aWV3UG9ydC53aWR0aCxcbiAgICAgICAgZGVzaXJlZFdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzY3JlZW4udmlld1BvcnQuaGVpZ2h0LFxuICAgICAgICBkZXNpcmVkSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIG1pblg6IG1pblgsXG4gICAgICAgIG1pblk6IG1pblksXG4gICAgICAgIHJlZlg6IHJlZlhBdHRyLmdldFZhbHVlKCksXG4gICAgICAgIHJlZlk6IHJlZllBdHRyLmdldFZhbHVlKCksXG4gICAgICAgIGNsaXA6IGNsaXAsXG4gICAgICAgIGNsaXBYOiBjbGlwWCxcbiAgICAgICAgY2xpcFk6IGNsaXBZXG4gICAgICB9KTtcblxuICAgICAgaWYgKHZpZXdCb3gpIHtcbiAgICAgICAgc2NyZWVuLnZpZXdQb3J0LnJlbW92ZUN1cnJlbnQoKTtcbiAgICAgICAgc2NyZWVuLnZpZXdQb3J0LnNldEN1cnJlbnQod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNvbnRleHQoY3R4KSB7XG4gICAgICBfZ2V0X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFNWR0VsZW1lbnQucHJvdG90eXBlKSwgXCJjbGVhckNvbnRleHRcIiwgdGhpcykuY2FsbCh0aGlzLCBjdHgpO1xuXG4gICAgICB0aGlzLmRvY3VtZW50LnNjcmVlbi52aWV3UG9ydC5yZW1vdmVDdXJyZW50KCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVzaXplIFNWRyB0byBmaXQgaW4gZ2l2ZW4gc2l6ZS5cclxuICAgICAqIEBwYXJhbSB3aWR0aFxyXG4gICAgICogQHBhcmFtIGhlaWdodFxyXG4gICAgICogQHBhcmFtIHByZXNlcnZlQXNwZWN0UmF0aW9cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSh3aWR0aCkge1xuICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogd2lkdGg7XG4gICAgICB2YXIgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgd2lkdGhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSk7XG4gICAgICB2YXIgaGVpZ2h0QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0cnVlKTtcbiAgICAgIHZhciB2aWV3Qm94QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgICB2YXIgc3R5bGVBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB2YXIgb3JpZ2luV2lkdGggPSB3aWR0aEF0dHIuZ2V0TnVtYmVyKDApO1xuICAgICAgdmFyIG9yaWdpbkhlaWdodCA9IGhlaWdodEF0dHIuZ2V0TnVtYmVyKDApO1xuXG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgICBpZiAodHlwZW9mIHByZXNlcnZlQXNwZWN0UmF0aW8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCB0cnVlKS5zZXRWYWx1ZShwcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJlc2VydmVBc3BlY3RSYXRpb0F0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpO1xuXG4gICAgICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLnNldFZhbHVlKHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyLmdldFN0cmluZygpLnJlcGxhY2UoL15cXHMqKFxcUy4qXFxTKVxccyokLywgJyQxJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aWR0aEF0dHIuc2V0VmFsdWUod2lkdGgpO1xuICAgICAgaGVpZ2h0QXR0ci5zZXRWYWx1ZShoZWlnaHQpO1xuXG4gICAgICBpZiAoIXZpZXdCb3hBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmlld0JveEF0dHIuc2V0VmFsdWUoXCIwIDAgXCIuY29uY2F0KG9yaWdpbldpZHRoIHx8IHdpZHRoLCBcIiBcIikuY29uY2F0KG9yaWdpbkhlaWdodCB8fCBoZWlnaHQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciB3aWR0aFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKTtcbiAgICAgICAgdmFyIGhlaWdodFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG5cbiAgICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHdpZHRoU3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBoZWlnaHRTdHlsZS5zZXRWYWx1ZShcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNWR0VsZW1lbnQ7XG59KFJlbmRlcmVkRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRBKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEEoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgUmVjdEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXRoRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFJlY3RFbGVtZW50LCBfUGF0aEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkQShSZWN0RWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gUmVjdEVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBSZWN0RWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAncmVjdCc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShSZWN0RWxlbWVudCwgW3tcbiAgICBrZXk6IFwicGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoKGN0eCkge1xuICAgICAgdmFyIHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnLCBmYWxzZSwgdHJ1ZSkuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JywgZmFsc2UsIHRydWUpLmdldFBpeGVscygneScpO1xuICAgICAgdmFyIHJ4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeCcpO1xuICAgICAgdmFyIHJ5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeScpO1xuICAgICAgdmFyIHJ4ID0gcnhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIHJ5ID0gcnlBdHRyLmdldFBpeGVscygneScpO1xuXG4gICAgICBpZiAocnhBdHRyLmhhc1ZhbHVlKCkgJiYgIXJ5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHJ5ID0gcng7XG4gICAgICB9XG5cbiAgICAgIGlmIChyeUF0dHIuaGFzVmFsdWUoKSAmJiAhcnhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgcnggPSByeTtcbiAgICAgIH1cblxuICAgICAgcnggPSBNYXRoLm1pbihyeCwgd2lkdGggLyAyLjApO1xuICAgICAgcnkgPSBNYXRoLm1pbihyeSwgaGVpZ2h0IC8gMi4wKTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICB2YXIgS0FQUEEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7IC8vIGFsd2F5cyBzdGFydCB0aGUgcGF0aCBzbyB3ZSBkb24ndCBmaWxsIHByaW9yIHBhdGhzXG5cbiAgICAgICAgaWYgKGhlaWdodCA+IDAgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcngsIHkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcngsIHkpO1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3aWR0aCAtIHJ4ICsgS0FQUEEgKiByeCwgeSwgeCArIHdpZHRoLCB5ICsgcnkgLSBLQVBQQSAqIHJ5LCB4ICsgd2lkdGgsIHkgKyByeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByeSk7XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkgKyBLQVBQQSAqIHJ5LCB4ICsgd2lkdGggLSByeCArIEtBUFBBICogcngsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJ4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgICBjdHgubGluZVRvKHggKyByeCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHJ4IC0gS0FQUEEgKiByeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJ5ICsgS0FQUEEgKiByeSwgeCwgeSArIGhlaWdodCAtIHJ5KTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIHJ5IC0gS0FQUEEgKiByeSwgeCArIHJ4IC0gS0FQUEEgKiByeCwgeSwgeCArIHJ4LCB5KTtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVjdEVsZW1lbnQ7XG59KFBhdGhFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHooRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkeigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkeigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBDaXJjbGVFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGF0aEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShDaXJjbGVFbGVtZW50LCBfUGF0aEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkeihDaXJjbGVFbGVtZW50KTtcblxuICBmdW5jdGlvbiBDaXJjbGVFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgQ2lyY2xlRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAnY2lyY2xlJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKENpcmNsZUVsZW1lbnQsIFt7XG4gICAga2V5OiBcInBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aChjdHgpIHtcbiAgICAgIHZhciBjeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIGN5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB2YXIgciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0UGl4ZWxzKCk7XG5cbiAgICAgIGlmIChjdHggJiYgciA+IDApIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KGN4IC0gciwgY3kgLSByLCBjeCArIHIsIGN5ICsgcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcmtlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya2VycygpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjbGVFbGVtZW50O1xufShQYXRoRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciR5KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHkoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHkoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRWxsaXBzZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXRoRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEVsbGlwc2VFbGVtZW50LCBfUGF0aEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkeShFbGxpcHNlRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gRWxsaXBzZUVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBFbGxpcHNlRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAnZWxsaXBzZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShFbGxpcHNlRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoKGN0eCkge1xuICAgICAgdmFyIEtBUFBBID0gNCAqICgoTWF0aC5zcXJ0KDIpIC0gMSkgLyAzKTtcbiAgICAgIHZhciByeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeCcpLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIHJ5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB2YXIgY3ggPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciBjeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldFBpeGVscygneScpO1xuXG4gICAgICBpZiAoY3R4ICYmIHJ4ID4gMCAmJiByeSA+IDApIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGN4ICsgcngsIGN5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggKyByeCwgY3kgKyBLQVBQQSAqIHJ5LCBjeCArIEtBUFBBICogcngsIGN5ICsgcnksIGN4LCBjeSArIHJ5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggLSBLQVBQQSAqIHJ4LCBjeSArIHJ5LCBjeCAtIHJ4LCBjeSArIEtBUFBBICogcnksIGN4IC0gcngsIGN5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggLSByeCwgY3kgLSBLQVBQQSAqIHJ5LCBjeCAtIEtBUFBBICogcngsIGN5IC0gcnksIGN4LCBjeSAtIHJ5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggKyBLQVBQQSAqIHJ4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSAtIEtBUFBBICogcnksIGN4ICsgcngsIGN5KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KGN4IC0gcngsIGN5IC0gcnksIGN4ICsgcngsIGN5ICsgcnkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWxsaXBzZUVsZW1lbnQ7XG59KFBhdGhFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHgoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkeCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkeCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBMaW5lRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhdGhFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oTGluZUVsZW1lbnQsIF9QYXRoRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciR4KExpbmVFbGVtZW50KTtcblxuICBmdW5jdGlvbiBMaW5lRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIExpbmVFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdsaW5lJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKExpbmVFbGVtZW50LCBbe1xuICAgIGtleTogXCJnZXRQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnRzKCkge1xuICAgICAgcmV0dXJuIFtuZXcgUG9pbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuZ2V0UGl4ZWxzKCd4JyksIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmdldFBpeGVscygneScpKSwgbmV3IFBvaW50KHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXRQaXhlbHMoJ3knKSldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGgoY3R4KSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0UG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKSxcbiAgICAgICAgICBfdGhpcyRnZXRQb2ludHMyID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF90aGlzJGdldFBvaW50cywgMiksXG4gICAgICAgICAgX3RoaXMkZ2V0UG9pbnRzMiQgPSBfdGhpcyRnZXRQb2ludHMyWzBdLFxuICAgICAgICAgIHgwID0gX3RoaXMkZ2V0UG9pbnRzMiQueCxcbiAgICAgICAgICB5MCA9IF90aGlzJGdldFBvaW50czIkLnksXG4gICAgICAgICAgX3RoaXMkZ2V0UG9pbnRzMiQyID0gX3RoaXMkZ2V0UG9pbnRzMlsxXSxcbiAgICAgICAgICB4MSA9IF90aGlzJGdldFBvaW50czIkMi54LFxuICAgICAgICAgIHkxID0gX3RoaXMkZ2V0UG9pbnRzMiQyLnk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHgwLCB5MCk7XG4gICAgICAgIGN0eC5saW5lVG8oeDEsIHkxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcmtlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya2VycygpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRQb2ludHMzID0gdGhpcy5nZXRQb2ludHMoKSxcbiAgICAgICAgICBfdGhpcyRnZXRQb2ludHM0ID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF90aGlzJGdldFBvaW50czMsIDIpLFxuICAgICAgICAgIHAwID0gX3RoaXMkZ2V0UG9pbnRzNFswXSxcbiAgICAgICAgICBwMSA9IF90aGlzJGdldFBvaW50czRbMV07XG5cbiAgICAgIHZhciBhID0gcDAuYW5nbGVUbyhwMSk7XG4gICAgICByZXR1cm4gW1twMCwgYV0sIFtwMSwgYV1dO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lRWxlbWVudDtcbn0oUGF0aEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkdyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR3KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR3KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFBvbHlsaW5lRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhdGhFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUG9seWxpbmVFbGVtZW50LCBfUGF0aEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkdyhQb2x5bGluZUVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFBvbHlsaW5lRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgUG9seWxpbmVFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAncG9seWxpbmUnO1xuICAgIF90aGlzLnBvaW50cyA9IFtdO1xuICAgIF90aGlzLnBvaW50cyA9IFBvaW50LnBhcnNlUGF0aChfdGhpcy5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpLmdldFN0cmluZygpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBvbHlsaW5lRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoKGN0eCkge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXG4gICAgICB2YXIgX3BvaW50cyA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShwb2ludHMsIDEpLFxuICAgICAgICAgIF9wb2ludHMkID0gX3BvaW50c1swXSxcbiAgICAgICAgICB4MCA9IF9wb2ludHMkLngsXG4gICAgICAgICAgeTAgPSBfcG9pbnRzJC55O1xuXG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goeDAsIHkwKTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgIH1cblxuICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHggPSBfcmVmLngsXG4gICAgICAgICAgICB5ID0gX3JlZi55O1xuICAgICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcmtlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFya2VycygpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgIHZhciBsYXN0SW5kZXggPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQsIGkpIHtcbiAgICAgICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtlcnMucHVzaChbcG9pbnQsIHBvaW50LmFuZ2xlVG8ocG9pbnRzW2kgKyAxXSldKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWFya2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1hcmtlcnMucHVzaChbcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSwgbWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdWzFdXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb2x5bGluZUVsZW1lbnQ7XG59KFBhdGhFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHYoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBQb2x5Z29uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BvbHlsaW5lRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBvbHlnb25FbGVtZW50LCBfUG9seWxpbmVFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHYoUG9seWdvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFBvbHlnb25FbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgUG9seWdvbkVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ3BvbHlnb24nO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUG9seWdvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aChjdHgpIHtcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IF9nZXRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oUG9seWdvbkVsZW1lbnQucHJvdG90eXBlKSwgXCJwYXRoXCIsIHRoaXMpLmNhbGwodGhpcywgY3R4KTtcblxuICAgICAgdmFyIF90aGlzJHBvaW50cyA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLnBvaW50cywgMSksXG4gICAgICAgICAgX3RoaXMkcG9pbnRzJCA9IF90aGlzJHBvaW50c1swXSxcbiAgICAgICAgICB4ID0gX3RoaXMkcG9pbnRzJC54LFxuICAgICAgICAgIHkgPSBfdGhpcyRwb2ludHMkLnk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvbHlnb25FbGVtZW50O1xufShQb2x5bGluZUVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkdShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR1KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR1KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFBhdHRlcm5FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBhdHRlcm5FbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciR1KFBhdHRlcm5FbGVtZW50KTtcblxuICBmdW5jdGlvbiBQYXR0ZXJuRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFBhdHRlcm5FbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdwYXR0ZXJuJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBhdHRlcm5FbGVtZW50LCBbe1xuICAgIGtleTogXCJjcmVhdGVQYXR0ZXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBhdHRlcm4oY3R4LCBfLCBwYXJlbnRPcGFjaXR5UHJvcCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnLCB0cnVlKTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knLCB0cnVlKTsgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50XG5cbiAgICAgIHZhciBwYXR0ZXJuU3ZnID0gbmV3IFNWR0VsZW1lbnQodGhpcy5kb2N1bWVudCwgbnVsbCk7XG4gICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMudmlld0JveCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAndmlld0JveCcsIHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0VmFsdWUoKSk7XG4gICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3dpZHRoJywgXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikpO1xuICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnaGVpZ2h0JywgXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpKTtcbiAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy50cmFuc2Zvcm0gPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3RyYW5zZm9ybScsIHRoaXMuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJykuZ2V0VmFsdWUoKSk7XG4gICAgICBwYXR0ZXJuU3ZnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIHZhciBwYXR0ZXJuQ2FudmFzID0gdGhpcy5kb2N1bWVudC5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHZhciB4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgICB2YXIgeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpO1xuXG4gICAgICBpZiAoeEF0dHIuaGFzVmFsdWUoKSAmJiB5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHBhdHRlcm5DdHgudHJhbnNsYXRlKHhBdHRyLmdldFBpeGVscygneCcsIHRydWUpLCB5QXR0ci5nZXRQaXhlbHMoJ3knLCB0cnVlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnRPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzWydmaWxsLW9wYWNpdHknXSA9IHBhcmVudE9wYWNpdHlQcm9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0aGlzLnN0eWxlcywgJ2ZpbGwtb3BhY2l0eScpO1xuICAgICAgfSAvLyByZW5kZXIgM3gzIGdyaWQgc28gd2hlbiB3ZSB0cmFuc2Zvcm0gdGhlcmUncyBubyB3aGl0ZSBzcGFjZSBvbiBlZGdlc1xuXG5cbiAgICAgIGZvciAodmFyIHggPSAtMTsgeCA8PSAxOyB4KyspIHtcbiAgICAgICAgZm9yICh2YXIgeSA9IC0xOyB5IDw9IDE7IHkrKykge1xuICAgICAgICAgIHBhdHRlcm5DdHguc2F2ZSgpO1xuICAgICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy54ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd4JywgeCAqIHBhdHRlcm5DYW52YXMud2lkdGgpO1xuICAgICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd5JywgeSAqIHBhdHRlcm5DYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBwYXR0ZXJuU3ZnLnJlbmRlcihwYXR0ZXJuQ3R4KTtcbiAgICAgICAgICBwYXR0ZXJuQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm5DYW52YXMsICdyZXBlYXQnKTtcbiAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXR0ZXJuRWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciR0KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHQoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgTWFya2VyRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShNYXJrZXJFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciR0KE1hcmtlckVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIE1hcmtlckVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBNYXJrZXJFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdtYXJrZXInO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oTWFya2VyRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihjdHgsIHBvaW50LCBhbmdsZSkge1xuICAgICAgaWYgKCFwb2ludCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgIHZhciBvcmllbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnb3JpZW50JykuZ2V0U3RyaW5nKCdhdXRvJyk7XG4gICAgICB2YXIgbWFya2VyVW5pdHMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VyVW5pdHMnKS5nZXRTdHJpbmcoJ3N0cm9rZVdpZHRoJyk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgICBpZiAob3JpZW50ID09PSAnYXV0bycpIHtcbiAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrZXJVbml0cyA9PT0gJ3N0cm9rZVdpZHRoJykge1xuICAgICAgICBjdHguc2NhbGUoY3R4LmxpbmVXaWR0aCwgY3R4LmxpbmVXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7IC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuXG4gICAgICB2YXIgbWFya2VyU3ZnID0gbmV3IFNWR0VsZW1lbnQodGhpcy5kb2N1bWVudCwgbnVsbCk7XG4gICAgICBtYXJrZXJTdmcudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnZpZXdCb3ggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3ZpZXdCb3gnLCB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFZhbHVlKCkpO1xuICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMucmVmWCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAncmVmWCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZYJykuZ2V0VmFsdWUoKSk7XG4gICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5yZWZZID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdyZWZZJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlknKS5nZXRWYWx1ZSgpKTtcbiAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd3aWR0aCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdtYXJrZXJXaWR0aCcpLmdldFZhbHVlKCkpO1xuICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdoZWlnaHQnLCB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VySGVpZ2h0JykuZ2V0VmFsdWUoKSk7XG4gICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5vdmVyZmxvdyA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnb3ZlcmZsb3cnLCB0aGlzLmdldEF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS5nZXRWYWx1ZSgpKTtcbiAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLmZpbGwgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2ZpbGwnLCB0aGlzLmdldEF0dHJpYnV0ZSgnZmlsbCcpLmdldENvbG9yKCdibGFjaycpKTtcbiAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnN0cm9rZSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnc3Ryb2tlJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpLmdldFZhbHVlKCdub25lJykpO1xuICAgICAgbWFya2VyU3ZnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIG1hcmtlclN2Zy5yZW5kZXIoY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmIChtYXJrZXJVbml0cyA9PT0gJ3N0cm9rZVdpZHRoJykge1xuICAgICAgICBjdHguc2NhbGUoMSAvIGN0eC5saW5lV2lkdGgsIDEgLyBjdHgubGluZVdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9yaWVudCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGN0eC5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXJrZXJFbGVtZW50O1xufShFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHMoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBEZWZzRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZWZzRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkcyhEZWZzRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gRGVmc0VsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBEZWZzRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAnZGVmcyc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZWZzRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHsvLyBOT09QXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERlZnNFbGVtZW50O1xufShFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBHRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlbmRlcmVkRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEdFbGVtZW50LCBfUmVuZGVyZWRFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHIoR0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEdFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgR0VsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ2cnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oR0VsZW1lbnQsIFt7XG4gICAga2V5OiBcImdldEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkLmdldEJvdW5kaW5nQm94KGN0eCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdFbGVtZW50O1xufShSZW5kZXJlZEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRxKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEdyYWRpZW50RWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShHcmFkaWVudEVsZW1lbnQsIF9FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHEoR3JhZGllbnRFbGVtZW50KTtcblxuICBmdW5jdGlvbiBHcmFkaWVudEVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEdyYWRpZW50RWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICBfdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0ID0gWydncmFkaWVudFVuaXRzJ107XG4gICAgX3RoaXMuc3RvcHMgPSBbXTtcblxuICAgIHZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemUgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkX19kZWZhdWx0W1wiZGVmYXVsdFwiXShfdGhpcyksXG4gICAgICAgIHN0b3BzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplLnN0b3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZS5jaGlsZHJlbjtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3N0b3AnKSB7XG4gICAgICAgIHN0b3BzLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oR3JhZGllbnRFbGVtZW50LCBbe1xuICAgIGtleTogXCJnZXRHcmFkaWVudFVuaXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdyYWRpZW50VW5pdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnKS5nZXRTdHJpbmcoJ29iamVjdEJvdW5kaW5nQm94Jyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUdyYWRpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUdyYWRpZW50KGN0eCwgZWxlbWVudCwgcGFyZW50T3BhY2l0eVByb3ApIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIGNvbnNpc3RlbnQtdGhpc1xuICAgICAgdmFyIHN0b3BzQ29udGFpbmVyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgc3RvcHNDb250YWluZXIgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIHRoaXMuaW5oZXJpdFN0b3BDb250YWluZXIoc3RvcHNDb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3N0b3BzQ29udGFpbmVyID0gc3RvcHNDb250YWluZXIsXG4gICAgICAgICAgc3RvcHMgPSBfc3RvcHNDb250YWluZXIuc3RvcHM7XG4gICAgICB2YXIgZ3JhZGllbnQgPSB0aGlzLmdldEdyYWRpZW50KGN0eCwgZWxlbWVudCk7XG5cbiAgICAgIGlmICghZ3JhZGllbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkUGFyZW50T3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCwgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV0uY29sb3IpO1xuICAgICAgfVxuXG4gICAgICBzdG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLm9mZnNldCwgX3RoaXMyLmFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIHN0b3AuY29sb3IpKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAvLyByZW5kZXIgYXMgdHJhbnNmb3JtZWQgcGF0dGVybiBvbiB0ZW1wb3JhcnkgY2FudmFzXG4gICAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQ7XG4gICAgICAgIHZhciBfZG9jdW1lbnQkc2NyZWVuID0gZG9jdW1lbnQuc2NyZWVuLFxuICAgICAgICAgICAgTUFYX1ZJUlRVQUxfUElYRUxTID0gX2RvY3VtZW50JHNjcmVlbi5NQVhfVklSVFVBTF9QSVhFTFMsXG4gICAgICAgICAgICB2aWV3UG9ydCA9IF9kb2N1bWVudCRzY3JlZW4udmlld1BvcnQ7XG5cbiAgICAgICAgdmFyIF92aWV3UG9ydCR2aWV3UG9ydHMgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0odmlld1BvcnQudmlld1BvcnRzLCAxKSxcbiAgICAgICAgICAgIHJvb3RWaWV3ID0gX3ZpZXdQb3J0JHZpZXdQb3J0c1swXTtcblxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0RWxlbWVudChkb2N1bWVudCwgbnVsbCk7XG4gICAgICAgIHJlY3QuYXR0cmlidXRlcy54ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneCcsIC1NQVhfVklSVFVBTF9QSVhFTFMgLyAzLjApO1xuICAgICAgICByZWN0LmF0dHJpYnV0ZXMueSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3knLCAtTUFYX1ZJUlRVQUxfUElYRUxTIC8gMy4wKTtcbiAgICAgICAgcmVjdC5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCBNQVhfVklSVFVBTF9QSVhFTFMpO1xuICAgICAgICByZWN0LmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnaGVpZ2h0JywgTUFYX1ZJUlRVQUxfUElYRUxTKTtcbiAgICAgICAgdmFyIGdyb3VwID0gbmV3IEdFbGVtZW50KGRvY3VtZW50LCBudWxsKTtcbiAgICAgICAgZ3JvdXAuYXR0cmlidXRlcy50cmFuc2Zvcm0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd0cmFuc2Zvcm0nLCB0aGlzLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgZ3JvdXAuY2hpbGRyZW4gPSBbcmVjdF07XG4gICAgICAgIHZhciBwYXR0ZXJuU3ZnID0gbmV3IFNWR0VsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3gnLCAwKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnkgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd5JywgMCk7XG4gICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgcm9vdFZpZXcud2lkdGgpO1xuICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnaGVpZ2h0Jywgcm9vdFZpZXcuaGVpZ2h0KTtcbiAgICAgICAgcGF0dGVyblN2Zy5jaGlsZHJlbiA9IFtncm91cF07XG4gICAgICAgIHZhciBwYXR0ZXJuQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHJvb3RWaWV3LndpZHRoLCByb290Vmlldy5oZWlnaHQpO1xuICAgICAgICB2YXIgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgICAgcGF0dGVyblN2Zy5yZW5kZXIocGF0dGVybkN0eCk7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuQ3R4LmNyZWF0ZVBhdHRlcm4ocGF0dGVybkNhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaGVyaXRTdG9wQ29udGFpbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaGVyaXRTdG9wQ29udGFpbmVyKHN0b3BzQ29udGFpbmVyKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZVRvSW5oZXJpdCkge1xuICAgICAgICBpZiAoIV90aGlzMy5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5oYXNWYWx1ZSgpICYmIHN0b3BzQ29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBfdGhpczMuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCwgdHJ1ZSkuc2V0VmFsdWUoc3RvcHNDb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuZ2V0VmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRQYXJlbnRPcGFjaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIGNvbG9yKSB7XG4gICAgICBpZiAocGFyZW50T3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgY29sb3JQcm9wID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGNvbG9yUHJvcC5hZGRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wKS5nZXRDb2xvcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdyYWRpZW50RWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRwKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHAoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHAoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgTGluZWFyR3JhZGllbnRFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfR3JhZGllbnRFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oTGluZWFyR3JhZGllbnRFbGVtZW50LCBfR3JhZGllbnRFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHAoTGluZWFyR3JhZGllbnRFbGVtZW50KTtcblxuICBmdW5jdGlvbiBMaW5lYXJHcmFkaWVudEVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIExpbmVhckdyYWRpZW50RWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICBfdGhpcy50eXBlID0gJ2xpbmVhckdyYWRpZW50JztcblxuICAgIF90aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgneDEnLCAneTEnLCAneDInLCAneTInKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oTGluZWFyR3JhZGllbnRFbGVtZW50LCBbe1xuICAgIGtleTogXCJnZXRHcmFkaWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBpc0JvdW5kaW5nQm94VW5pdHMgPSB0aGlzLmdldEdyYWRpZW50VW5pdHMoKSA9PT0gJ29iamVjdEJvdW5kaW5nQm94JztcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KSA6IG51bGw7XG5cbiAgICAgIGlmIChpc0JvdW5kaW5nQm94VW5pdHMgJiYgIWJvdW5kaW5nQm94KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneDInLCB0cnVlKS5zZXRWYWx1ZSgxKTtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB4MSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgeTEgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIHZhciB4MiA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgeTIgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgaWYgKHgxID09PSB4MiAmJiB5MSA9PT0geTIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lYXJHcmFkaWVudEVsZW1lbnQ7XG59KEdyYWRpZW50RWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRvKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG8oKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG8oKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgUmFkaWFsR3JhZGllbnRFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfR3JhZGllbnRFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUmFkaWFsR3JhZGllbnRFbGVtZW50LCBfR3JhZGllbnRFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJG8oUmFkaWFsR3JhZGllbnRFbGVtZW50KTtcblxuICBmdW5jdGlvbiBSYWRpYWxHcmFkaWVudEVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFJhZGlhbEdyYWRpZW50RWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICBfdGhpcy50eXBlID0gJ3JhZGlhbEdyYWRpZW50JztcblxuICAgIF90aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgnY3gnLCAnY3knLCAncicsICdmeCcsICdmeScsICdmcicpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShSYWRpYWxHcmFkaWVudEVsZW1lbnQsIFt7XG4gICAga2V5OiBcImdldEdyYWRpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdyYWRpZW50KGN0eCwgZWxlbWVudCkge1xuICAgICAgdmFyIGlzQm91bmRpbmdCb3hVbml0cyA9IHRoaXMuZ2V0R3JhZGllbnRVbml0cygpID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnO1xuICAgICAgdmFyIGJvdW5kaW5nQm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpO1xuXG4gICAgICBpZiAoaXNCb3VuZGluZ0JveFVuaXRzICYmICFib3VuZGluZ0JveCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcsIHRydWUpLnNldFZhbHVlKCc1MCUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdjeScsIHRydWUpLnNldFZhbHVlKCc1MCUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgncicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3InLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgY3kgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIHZhciBmeCA9IGN4O1xuICAgICAgdmFyIGZ5ID0gY3k7XG5cbiAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnZngnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGZ4ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnZngnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdmeScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgZnkgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z5JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyAoYm91bmRpbmdCb3gud2lkdGggKyBib3VuZGluZ0JveC5oZWlnaHQpIC8gMi4wICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0UGl4ZWxzKCk7XG4gICAgICB2YXIgZnIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZnInKS5nZXRQaXhlbHMoKTtcbiAgICAgIHJldHVybiBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoZngsIGZ5LCBmciwgY3gsIGN5LCByKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFkaWFsR3JhZGllbnRFbGVtZW50O1xufShHcmFkaWVudEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRuKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRuKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFN0b3BFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFN0b3BFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRuKFN0b3BFbGVtZW50KTtcblxuICBmdW5jdGlvbiBTdG9wRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgU3RvcEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdzdG9wJztcbiAgICB2YXIgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgX3RoaXMuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKS5nZXROdW1iZXIoKSkpO1xuXG4gICAgdmFyIHN0b3BPcGFjaXR5ID0gX3RoaXMuZ2V0U3R5bGUoJ3N0b3Atb3BhY2l0eScpO1xuXG4gICAgdmFyIHN0b3BDb2xvciA9IF90aGlzLmdldFN0eWxlKCdzdG9wLWNvbG9yJywgdHJ1ZSk7XG5cbiAgICBpZiAoc3RvcENvbG9yLmdldFN0cmluZygpID09PSAnJykge1xuICAgICAgc3RvcENvbG9yLnNldFZhbHVlKCcjMDAwJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0b3BPcGFjaXR5Lmhhc1ZhbHVlKCkpIHtcbiAgICAgIHN0b3BDb2xvciA9IHN0b3BDb2xvci5hZGRPcGFjaXR5KHN0b3BPcGFjaXR5KTtcbiAgICB9XG5cbiAgICBfdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgX3RoaXMuY29sb3IgPSBzdG9wQ29sb3IuZ2V0Q29sb3IoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gU3RvcEVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRtKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRtKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEFuaW1hdGVFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEFuaW1hdGVFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRtKEFuaW1hdGVFbGVtZW50KTtcblxuICBmdW5jdGlvbiBBbmltYXRlRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgQW5pbWF0ZUVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdhbmltYXRlJztcbiAgICBfdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgX3RoaXMuaW5pdGlhbFZhbHVlID0gbnVsbDtcbiAgICBfdGhpcy5pbml0aWFsVW5pdHMgPSAnJztcbiAgICBfdGhpcy5yZW1vdmVkID0gZmFsc2U7XG4gICAgX3RoaXMuZnJvemVuID0gZmFsc2U7XG4gICAgZG9jdW1lbnQuc2NyZWVuLmFuaW1hdGlvbnMucHVzaChfYXNzZXJ0VGhpc0luaXRpYWxpemVkX19kZWZhdWx0W1wiZGVmYXVsdFwiXShfdGhpcykpO1xuICAgIF90aGlzLmJlZ2luID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdiZWdpbicpLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIF90aGlzLm1heER1cmF0aW9uID0gX3RoaXMuYmVnaW4gKyBfdGhpcy5nZXRBdHRyaWJ1dGUoJ2R1cicpLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIF90aGlzLmZyb20gPSBfdGhpcy5nZXRBdHRyaWJ1dGUoJ2Zyb20nKTtcbiAgICBfdGhpcy50byA9IF90aGlzLmdldEF0dHJpYnV0ZSgndG8nKTtcbiAgICBfdGhpcy52YWx1ZXMgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd2YWx1ZXMnLCBudWxsKTtcblxuICAgIHZhciB2YWx1ZXNBdHRyID0gX3RoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZXMnKTtcblxuICAgIGlmICh2YWx1ZXNBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIF90aGlzLnZhbHVlcy5zZXRWYWx1ZSh2YWx1ZXNBdHRyLmdldFN0cmluZygpLnNwbGl0KCc7JykpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oQW5pbWF0ZUVsZW1lbnQsIFt7XG4gICAga2V5OiBcImdldFByb3BlcnR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb3BlcnR5KCkge1xuICAgICAgdmFyIGF0dHJpYnV0ZVR5cGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXR0cmlidXRlVHlwZScpLmdldFN0cmluZygpO1xuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXR0cmlidXRlTmFtZScpLmdldFN0cmluZygpO1xuXG4gICAgICBpZiAoYXR0cmlidXRlVHlwZSA9PT0gJ0NTUycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldFN0eWxlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY1ZhbHVlKCkge1xuICAgICAgdmFyIGluaXRpYWxVbml0cyA9IHRoaXMuaW5pdGlhbFVuaXRzO1xuXG4gICAgICB2YXIgX3RoaXMkZ2V0UHJvZ3Jlc3MgPSB0aGlzLmdldFByb2dyZXNzKCksXG4gICAgICAgICAgcHJvZ3Jlc3MgPSBfdGhpcyRnZXRQcm9ncmVzcy5wcm9ncmVzcyxcbiAgICAgICAgICBmcm9tID0gX3RoaXMkZ2V0UHJvZ3Jlc3MuZnJvbSxcbiAgICAgICAgICB0byA9IF90aGlzJGdldFByb2dyZXNzLnRvOyAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuXG5cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGZyb20uZ2V0TnVtYmVyKCkgKyAodG8uZ2V0TnVtYmVyKCkgLSBmcm9tLmdldE51bWJlcigpKSAqIHByb2dyZXNzO1xuXG4gICAgICBpZiAoaW5pdGlhbFVuaXRzID09PSAnJScpIHtcbiAgICAgICAgbmV3VmFsdWUgKj0gMTAwLjA7IC8vIG51bVZhbHVlKCkgcmV0dXJucyAwLTEgd2hlcmVhcyBwcm9wZXJ0aWVzIGFyZSAwLTEwMFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobmV3VmFsdWUpLmNvbmNhdChpbml0aWFsVW5pdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGRlbHRhKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuZ2V0UHJvcGVydHkoKTsgLy8gc2V0IGluaXRpYWwgdmFsdWVcblxuICAgICAgaWYgKCF0aGlzLmluaXRpYWxWYWx1ZSkge1xuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFVuaXRzID0gcHJvcC5nZXRVbml0cygpO1xuICAgICAgfSAvLyBpZiB3ZSdyZSBwYXN0IHRoZSBlbmQgdGltZVxuXG5cbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uID4gdGhpcy5tYXhEdXJhdGlvbikge1xuICAgICAgICB2YXIgZmlsbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmaWxsJykuZ2V0U3RyaW5nKCdyZW1vdmUnKTsgLy8gbG9vcCBmb3IgaW5kZWZpbml0ZWx5IHJlcGVhdGluZyBhbmltYXRpb25zXG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdyZXBlYXRDb3VudCcpLmdldFN0cmluZygpID09PSAnaW5kZWZpbml0ZScgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlcGVhdER1cicpLmdldFN0cmluZygpID09PSAnaW5kZWZpbml0ZScpIHtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxsID09PSAnZnJlZXplJyAmJiAhdGhpcy5mcm96ZW4pIHtcbiAgICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gICAgICAgICAgcGFyZW50LmFuaW1hdGlvbkZyb3plbiA9IHRydWU7XG4gICAgICAgICAgcGFyZW50LmFuaW1hdGlvbkZyb3plblZhbHVlID0gcHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWxsID09PSAncmVtb3ZlJyAmJiAhdGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBwcm9wLnNldFZhbHVlKHBhcmVudC5hbmltYXRpb25Gcm96ZW4gPyBwYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgOiB0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHVyYXRpb24gKz0gZGVsdGE7IC8vIGlmIHdlJ3JlIHBhc3QgdGhlIGJlZ2luIHRpbWVcblxuICAgICAgdmFyIHVwZGF0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuYmVnaW4gPCB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY2FsY1ZhbHVlKCk7IC8vIHR3ZWVuXG5cbiAgICAgICAgdmFyIHR5cGVBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblxuICAgICAgICBpZiAodHlwZUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIC8vIGZvciB0cmFuc2Zvcm0sIGV0Yy5cbiAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVBdHRyLmdldFN0cmluZygpO1xuICAgICAgICAgIG5ld1ZhbHVlID0gXCJcIi5jb25jYXQodHlwZSwgXCIoXCIpLmNvbmNhdChuZXdWYWx1ZSwgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcC5zZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgcHJvZ3Jlc3M6ICh0aGlzLmR1cmF0aW9uIC0gdGhpcy5iZWdpbikgLyAodGhpcy5tYXhEdXJhdGlvbiAtIHRoaXMuYmVnaW4pXG4gICAgICB9O1xuXG4gICAgICBpZiAodmFsdWVzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmFyIHAgPSByZXN1bHQucHJvZ3Jlc3MgKiAodmFsdWVzLmdldFZhbHVlKCkubGVuZ3RoIC0gMSk7XG4gICAgICAgIHZhciBsYiA9IE1hdGguZmxvb3IocCk7XG4gICAgICAgIHZhciB1YiA9IE1hdGguY2VpbChwKTtcbiAgICAgICAgcmVzdWx0LmZyb20gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdmcm9tJywgcGFyc2VGbG9hdCh2YWx1ZXMuZ2V0VmFsdWUoKVtsYl0pKTtcbiAgICAgICAgcmVzdWx0LnRvID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndG8nLCBwYXJzZUZsb2F0KHZhbHVlcy5nZXRWYWx1ZSgpW3ViXSkpO1xuICAgICAgICByZXN1bHQucHJvZ3Jlc3MgPSAocCAtIGxiKSAvICh1YiAtIGxiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5mcm9tID0gdGhpcy5mcm9tO1xuICAgICAgICByZXN1bHQudG8gPSB0aGlzLnRvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbmltYXRlRWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRsKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGwoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGwoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgQW5pbWF0ZUNvbG9yRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0FuaW1hdGVFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oQW5pbWF0ZUNvbG9yRWxlbWVudCwgX0FuaW1hdGVFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGwoQW5pbWF0ZUNvbG9yRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gQW5pbWF0ZUNvbG9yRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEFuaW1hdGVDb2xvckVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ2FuaW1hdGVDb2xvcic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShBbmltYXRlQ29sb3JFbGVtZW50LCBbe1xuICAgIGtleTogXCJjYWxjVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY1ZhbHVlKCkge1xuICAgICAgdmFyIF90aGlzJGdldFByb2dyZXNzID0gdGhpcy5nZXRQcm9ncmVzcygpLFxuICAgICAgICAgIHByb2dyZXNzID0gX3RoaXMkZ2V0UHJvZ3Jlc3MucHJvZ3Jlc3MsXG4gICAgICAgICAgZnJvbSA9IF90aGlzJGdldFByb2dyZXNzLmZyb20sXG4gICAgICAgICAgdG8gPSBfdGhpcyRnZXRQcm9ncmVzcy50bztcblxuICAgICAgdmFyIGNvbG9yRnJvbSA9IG5ldyBSR0JDb2xvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oZnJvbS5nZXRDb2xvcigpKTtcbiAgICAgIHZhciBjb2xvclRvID0gbmV3IFJHQkNvbG9yX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0by5nZXRDb2xvcigpKTtcblxuICAgICAgaWYgKGNvbG9yRnJvbS5vayAmJiBjb2xvclRvLm9rKSB7XG4gICAgICAgIC8vIHR3ZWVuIGNvbG9yIGxpbmVhcmx5XG4gICAgICAgIHZhciByID0gY29sb3JGcm9tLnIgKyAoY29sb3JUby5yIC0gY29sb3JGcm9tLnIpICogcHJvZ3Jlc3M7XG4gICAgICAgIHZhciBnID0gY29sb3JGcm9tLmcgKyAoY29sb3JUby5nIC0gY29sb3JGcm9tLmcpICogcHJvZ3Jlc3M7XG4gICAgICAgIHZhciBiID0gY29sb3JGcm9tLmIgKyAoY29sb3JUby5iIC0gY29sb3JGcm9tLmIpICogcHJvZ3Jlc3M7IC8vID8gYWxwaGFcblxuICAgICAgICByZXR1cm4gXCJyZ2IoXCIuY29uY2F0KE1hdGguZmxvb3IociksIFwiLCBcIikuY29uY2F0KE1hdGguZmxvb3IoZyksIFwiLCBcIikuY29uY2F0KE1hdGguZmxvb3IoYiksIFwiKVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdmcm9tJykuZ2V0Q29sb3IoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQW5pbWF0ZUNvbG9yRWxlbWVudDtcbn0oQW5pbWF0ZUVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkayhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRrKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRrKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5pbWF0ZUVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShBbmltYXRlVHJhbnNmb3JtRWxlbWVudCwgX0FuaW1hdGVFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGsoQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ2FuaW1hdGVUcmFuc2Zvcm0nO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQsIFt7XG4gICAga2V5OiBcImNhbGNWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjVmFsdWUoKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0UHJvZ3Jlc3MgPSB0aGlzLmdldFByb2dyZXNzKCksXG4gICAgICAgICAgcHJvZ3Jlc3MgPSBfdGhpcyRnZXRQcm9ncmVzcy5wcm9ncmVzcyxcbiAgICAgICAgICBmcm9tID0gX3RoaXMkZ2V0UHJvZ3Jlc3MuZnJvbSxcbiAgICAgICAgICB0byA9IF90aGlzJGdldFByb2dyZXNzLnRvOyAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuXG5cbiAgICAgIHZhciB0cmFuc2Zvcm1Gcm9tID0gdG9OdW1iZXJzKGZyb20uZ2V0U3RyaW5nKCkpO1xuICAgICAgdmFyIHRyYW5zZm9ybVRvID0gdG9OdW1iZXJzKHRvLmdldFN0cmluZygpKTtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHRyYW5zZm9ybUZyb20ubWFwKGZ1bmN0aW9uIChmcm9tLCBpKSB7XG4gICAgICAgIHZhciB0byA9IHRyYW5zZm9ybVRvW2ldO1xuICAgICAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogcHJvZ3Jlc3M7XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50O1xufShBbmltYXRlRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGooRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBGb250RWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGb250RWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkaihGb250RWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gRm9udEVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEZvbnRFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAnZm9udCc7XG4gICAgX3RoaXMuZ2x5cGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBfdGhpcy5ob3JpekFkdlggPSBfdGhpcy5nZXRBdHRyaWJ1dGUoJ2hvcml6LWFkdi14JykuZ2V0TnVtYmVyKCk7XG4gICAgdmFyIGRlZmluaXRpb25zID0gZG9jdW1lbnQuZGVmaW5pdGlvbnM7XG5cbiAgICB2YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3RoaXMpLFxuICAgICAgICBjaGlsZHJlbiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZS5jaGlsZHJlbjtcblxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKGNoaWxkcmVuKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgc3dpdGNoIChjaGlsZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX3RoaXMuZm9udEZhY2UgPSBjaGlsZDtcbiAgICAgICAgICAgICAgdmFyIGZvbnRGYW1pbHlTdHlsZSA9IGNoaWxkLmdldFN0eWxlKCdmb250LWZhbWlseScpO1xuXG4gICAgICAgICAgICAgIGlmIChmb250RmFtaWx5U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25zW2ZvbnRGYW1pbHlTdHlsZS5nZXRTdHJpbmcoKV0gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkX19kZWZhdWx0W1wiZGVmYXVsdFwiXShfdGhpcyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgICAgICAgX3RoaXMubWlzc2luZ0dseXBoID0gY2hpbGQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2dseXBoJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGdseXBoID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgaWYgKGdseXBoLmFyYWJpY0Zvcm0pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1JUTCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNBcmFiaWMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF90aGlzLmdseXBoc1tnbHlwaC51bmljb2RlXVtnbHlwaC5hcmFiaWNGb3JtXSA9IGdseXBoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmdseXBoc1tnbHlwaC51bmljb2RlXSA9IGdseXBoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IuZigpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRm9udEVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7Ly8gTk8gUkVOREVSXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvbnRFbGVtZW50O1xufShFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGkoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBGb250RmFjZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRm9udEZhY2VFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRpKEZvbnRGYWNlRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gRm9udEZhY2VFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBGb250RmFjZUVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIF90aGlzLmFzY2VudCA9IF90aGlzLmdldEF0dHJpYnV0ZSgnYXNjZW50JykuZ2V0TnVtYmVyKCk7XG4gICAgX3RoaXMuZGVzY2VudCA9IF90aGlzLmdldEF0dHJpYnV0ZSgnZGVzY2VudCcpLmdldE51bWJlcigpO1xuICAgIF90aGlzLnVuaXRzUGVyRW0gPSBfdGhpcy5nZXRBdHRyaWJ1dGUoJ3VuaXRzLXBlci1lbScpLmdldE51bWJlcigpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBGb250RmFjZUVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkaChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRoKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRoKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIE1pc3NpbmdHbHlwaEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXRoRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKE1pc3NpbmdHbHlwaEVsZW1lbnQsIF9QYXRoRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRoKE1pc3NpbmdHbHlwaEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIE1pc3NpbmdHbHlwaEVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBNaXNzaW5nR2x5cGhFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdtaXNzaW5nLWdseXBoJztcbiAgICBfdGhpcy5ob3JpekFkdlggPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBNaXNzaW5nR2x5cGhFbGVtZW50O1xufShQYXRoRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRnKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGcoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGcoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgVFJlZkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UZXh0RWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFRSZWZFbGVtZW50LCBfVGV4dEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkZyhUUmVmRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gVFJlZkVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBUUmVmRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAndHJlZic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUUmVmRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiZ2V0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBmaXJzdENoaWxkID0gZWxlbWVudC5jaGlsZHJlblswXTtcblxuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHJldHVybiBmaXJzdENoaWxkLmdldFRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRSZWZFbGVtZW50O1xufShUZXh0RWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRmKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGYoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGYoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgQUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UZXh0RWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEFFbGVtZW50LCBfVGV4dEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkZihBRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gQUVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEFFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAnYSc7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBjaGlsZE5vZGVzWzBdO1xuICAgIHZhciBoYXNUZXh0ID0gY2hpbGROb2Rlcy5sZW5ndGggPiAwICYmIEFycmF5LmZyb20oY2hpbGROb2RlcykuZXZlcnkoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAzO1xuICAgIH0pO1xuICAgIF90aGlzLmhhc1RleHQgPSBoYXNUZXh0O1xuICAgIF90aGlzLnRleHQgPSBoYXNUZXh0ID8gX3RoaXMuZ2V0VGV4dEZyb21Ob2RlKGZpcnN0Q2hpbGQpIDogJyc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShBRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiZ2V0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQ2hpbGRyZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICBpZiAodGhpcy5oYXNUZXh0KSB7XG4gICAgICAgIC8vIHJlbmRlciBhcyB0ZXh0IGVsZW1lbnRcbiAgICAgICAgX2dldF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShBRWxlbWVudC5wcm90b3R5cGUpLCBcInJlbmRlckNoaWxkcmVuXCIsIHRoaXMpLmNhbGwodGhpcywgY3R4KTtcblxuICAgICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgICAgeCA9IHRoaXMueCxcbiAgICAgICAgICAgIHkgPSB0aGlzLnk7XG4gICAgICAgIHZhciBtb3VzZSA9IGRvY3VtZW50LnNjcmVlbi5tb3VzZTtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZm9udFNpemUnLCBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KS5mb250U2l6ZSk7IC8vIERvIG5vdCBjYWxjIGJvdW5kaW5nIGJveCBpZiBtb3VzZSBpcyBub3Qgd29ya2luZy5cblxuICAgICAgICBpZiAobW91c2UuaXNXb3JraW5nKCkpIHtcbiAgICAgICAgICBtb3VzZS5jaGVja0JvdW5kaW5nQm94KHRoaXMsIG5ldyBCb3VuZGluZ0JveCh4LCB5IC0gZm9udFNpemUuZ2V0UGl4ZWxzKCd5JyksIHggKyB0aGlzLm1lYXN1cmVUZXh0KGN0eCksIHkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gcmVuZGVyIGFzIHRlbXBvcmFyeSBncm91cFxuICAgICAgICB2YXIgZyA9IG5ldyBHRWxlbWVudCh0aGlzLmRvY3VtZW50LCBudWxsKTtcbiAgICAgICAgZy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIGcucGFyZW50ID0gdGhpcztcbiAgICAgICAgZy5yZW5kZXIoY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgdmFyIHdpbmRvdyA9IHRoaXMuZG9jdW1lbnQud2luZG93O1xuXG4gICAgICBpZiAod2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5vcGVuKHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldFN0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZU1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZU1vdmUoKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5kb2N1bWVudC5jdHg7XG4gICAgICBjdHguY2FudmFzLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQUVsZW1lbnQ7XG59KFRleHRFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5X19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRlKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGUoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGUoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgVGV4dFBhdGhFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGV4dEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUZXh0UGF0aEVsZW1lbnQsIF9UZXh0RWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRlKFRleHRQYXRoRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gVGV4dFBhdGhFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBUZXh0UGF0aEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICd0ZXh0UGF0aCc7XG4gICAgX3RoaXMudGV4dFdpZHRoID0gMDtcbiAgICBfdGhpcy50ZXh0SGVpZ2h0ID0gMDtcbiAgICBfdGhpcy5wYXRoTGVuZ3RoID0gLTE7XG4gICAgX3RoaXMuZ2x5cGhJbmZvID0gbnVsbDtcbiAgICBfdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGUgPSBbXTtcbiAgICBfdGhpcy5tZWFzdXJlc0NhY2hlID0gbmV3IE1hcChbWycnLCAwXV0pO1xuXG4gICAgdmFyIHBhdGhFbGVtZW50ID0gX3RoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcblxuICAgIF90aGlzLnRleHQgPSBfdGhpcy5nZXRUZXh0RnJvbU5vZGUoKTtcbiAgICBfdGhpcy5kYXRhQXJyYXkgPSBfdGhpcy5wYXJzZVBhdGhEYXRhKHBhdGhFbGVtZW50KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFRleHRQYXRoRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiZ2V0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoKGN0eCkge1xuICAgICAgdmFyIGRhdGFBcnJheSA9IHRoaXMuZGF0YUFycmF5O1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgZGF0YUFycmF5LmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfcmVmLnR5cGUsXG4gICAgICAgICAgICBwb2ludHMgPSBfcmVmLnBvaW50cztcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF9wb2ludHMgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ocG9pbnRzLCA4KSxcbiAgICAgICAgICAgICAgICAgIGN4ID0gX3BvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgIGN5ID0gX3BvaW50c1sxXSxcbiAgICAgICAgICAgICAgICAgIHJ4ID0gX3BvaW50c1syXSxcbiAgICAgICAgICAgICAgICAgIHJ5ID0gX3BvaW50c1szXSxcbiAgICAgICAgICAgICAgICAgIHRoZXRhID0gX3BvaW50c1s0XSxcbiAgICAgICAgICAgICAgICAgIGRUaGV0YSA9IF9wb2ludHNbNV0sXG4gICAgICAgICAgICAgICAgICBwc2kgPSBfcG9pbnRzWzZdLFxuICAgICAgICAgICAgICAgICAgZnMgPSBfcG9pbnRzWzddO1xuXG4gICAgICAgICAgICAgIHZhciByID0gcnggPiByeSA/IHJ4IDogcnk7XG4gICAgICAgICAgICAgIHZhciBzY2FsZVggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG5cbiAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKHBzaSk7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgQm9vbGVhbigxIC0gZnMpKTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSAvIHNjYWxlWCwgMSAvIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtcHNpKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNMT1NFX1BBVEg6XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICAgIHRoaXMuc2V0VGV4dERhdGEoY3R4KTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgdGV4dERlY29yYXRpb24gPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgndGV4dC1kZWNvcmF0aW9uJykuZ2V0U3RyaW5nKCk7XG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICB2YXIgZ2x5cGhJbmZvID0gdGhpcy5nbHlwaEluZm87XG4gICAgICB2YXIgZmlsbCA9IGN0eC5maWxsU3R5bGU7XG5cbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICBnbHlwaEluZm8uZm9yRWFjaChmdW5jdGlvbiAoZ2x5cGgsIGkpIHtcbiAgICAgICAgdmFyIHAwID0gZ2x5cGgucDAsXG4gICAgICAgICAgICBwMSA9IGdseXBoLnAxLFxuICAgICAgICAgICAgcm90YXRpb24gPSBnbHlwaC5yb3RhdGlvbixcbiAgICAgICAgICAgIHBhcnRpYWxUZXh0ID0gZ2x5cGgudGV4dDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShwMC54LCBwMC55KTtcbiAgICAgICAgY3R4LnJvdGF0ZShyb3RhdGlvbik7XG5cbiAgICAgICAgaWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgICAgICBjdHguZmlsbFRleHQocGFydGlhbFRleHQsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHAwLngsIHAwLnkgKyBmb250U2l6ZSAvIDgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN0eC5saW5lVG8ocDEueCwgcDEueSArIGZvbnRTaXplIC8gNSk7XG4gICAgICAgIH0gLy8gLy8gVG8gYXNzaXN0IHdpdGggZGVidWdnaW5nIHZpc3VhbGx5LCB1bmNvbW1lbnQgZm9sbG93aW5nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgLy8gaWYgKGkgJSAyKVxuICAgICAgICAvLyBcdGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vIFx0Y3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICAgICAgLy8gY3R4Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgICAgLy8gY3R4LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgICAgLy8gY3R4LnN0cm9rZSgpO1xuICAgICAgICAvLyBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBmb250U2l6ZSAvIDIwO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBmaWxsO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGV0dGVyU3BhY2luZ0F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExldHRlclNwYWNpbmdBdCgpIHtcbiAgICAgIHZhciBpZHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICByZXR1cm4gdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGVbaWR4XSB8fCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kU2VnbWVudFRvRml0Q2hhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kU2VnbWVudFRvRml0Q2hhcihjdHgsIGFuY2hvciwgdGV4dEZ1bGxXaWR0aCwgZnVsbFBhdGhXaWR0aCwgc3BhY2VzTnVtYmVyLCBpbnB1dE9mZnNldCwgZHksIGMsIGNoYXJJKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gaW5wdXRPZmZzZXQ7XG4gICAgICB2YXIgZ2x5cGhXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQoY3R4LCBjKTtcblxuICAgICAgaWYgKGMgPT09ICcgJyAmJiBhbmNob3IgPT09ICdqdXN0aWZ5JyAmJiB0ZXh0RnVsbFdpZHRoIDwgZnVsbFBhdGhXaWR0aCkge1xuICAgICAgICBnbHlwaFdpZHRoICs9IChmdWxsUGF0aFdpZHRoIC0gdGV4dEZ1bGxXaWR0aCkgLyBzcGFjZXNOdW1iZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFySSA+IC0xKSB7XG4gICAgICAgIG9mZnNldCArPSB0aGlzLmdldExldHRlclNwYWNpbmdBdChjaGFySSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcGxpbmVTdGVwID0gdGhpcy50ZXh0SGVpZ2h0IC8gMjA7XG4gICAgICB2YXIgcDAgPSB0aGlzLmdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgob2Zmc2V0LCBzcGxpbmVTdGVwLCAwKTtcbiAgICAgIHZhciBwMSA9IHRoaXMuZ2V0RXF1aWRpc3RhbnRQb2ludE9uUGF0aChvZmZzZXQgKyBnbHlwaFdpZHRoLCBzcGxpbmVTdGVwLCAwKTtcbiAgICAgIHZhciBzZWdtZW50ID0ge1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMVxuICAgICAgfTtcbiAgICAgIHZhciByb3RhdGlvbiA9IHAwICYmIHAxID8gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpIDogMDtcblxuICAgICAgaWYgKGR5KSB7XG4gICAgICAgIHZhciBkeVggPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiArIHJvdGF0aW9uKSAqIGR5O1xuICAgICAgICB2YXIgZHlZID0gTWF0aC5jb3MoLXJvdGF0aW9uKSAqIGR5O1xuICAgICAgICBzZWdtZW50LnAwID0gX29iamVjdFNwcmVhZCQyKF9vYmplY3RTcHJlYWQkMih7fSwgcDApLCB7fSwge1xuICAgICAgICAgIHg6IHAwLnggKyBkeVgsXG4gICAgICAgICAgeTogcDAueSArIGR5WVxuICAgICAgICB9KTtcbiAgICAgICAgc2VnbWVudC5wMSA9IF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIHAxKSwge30sIHtcbiAgICAgICAgICB4OiBwMS54ICsgZHlYLFxuICAgICAgICAgIHk6IHAxLnkgKyBkeVlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCArPSBnbHlwaFdpZHRoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHNlZ21lbnQ6IHNlZ21lbnQsXG4gICAgICAgIHJvdGF0aW9uOiByb3RhdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVhc3VyZVRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVhc3VyZVRleHQoY3R4LCB0ZXh0KSB7XG4gICAgICB2YXIgbWVhc3VyZXNDYWNoZSA9IHRoaXMubWVhc3VyZXNDYWNoZTtcbiAgICAgIHZhciB0YXJnZXRUZXh0ID0gdGV4dCB8fCB0aGlzLmdldFRleHQoKTtcblxuICAgICAgaWYgKG1lYXN1cmVzQ2FjaGUuaGFzKHRhcmdldFRleHQpKSB7XG4gICAgICAgIHJldHVybiBtZWFzdXJlc0NhY2hlLmdldCh0YXJnZXRUZXh0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lYXN1cmUgPSB0aGlzLm1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgdGFyZ2V0VGV4dCk7XG4gICAgICBtZWFzdXJlc0NhY2hlLnNldCh0YXJnZXRUZXh0LCBtZWFzdXJlKTtcbiAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgIH0gLy8gVGhpcyBtZXRob2Qgc3VwcG9zZXMgd2hhdCBhbGwgY3VzdG9tIGZvbnRzIGFscmVhZHkgbG9hZGVkLlxuICAgIC8vIElmIHNvbWUgZm9udCB3aWxsIGJlIGxvYWRlZCBhZnRlciB0aGlzIG1ldGhvZCBjYWxsLCA8dGV4dFBhdGg+IHdpbGwgbm90IGJlIHJlbmRlcmVkIGNvcnJlY3RseS5cbiAgICAvLyBZb3UgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIG1hbnVhbGx5IHRvIHVwZGF0ZSBnbHlwaHMgY2FjaGUuXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUZXh0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0RGF0YShjdHgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5nbHlwaEluZm8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgdmFyIGNoYXJzID0gcmVuZGVyVGV4dC5zcGxpdCgnJyk7XG4gICAgICB2YXIgc3BhY2VzTnVtYmVyID0gcmVuZGVyVGV4dC5zcGxpdCgnICcpLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgZHggPSB0aGlzLnBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4Jykuc3BsaXQoKS5tYXAoZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIF8uZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB9KTtcbiAgICAgIHZhciBkeSA9IHRoaXMucGFyZW50LmdldEF0dHJpYnV0ZSgnZHknKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIHZhciBhbmNob3IgPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgndGV4dC1hbmNob3InKS5nZXRTdHJpbmcoJ3N0YXJ0Jyk7XG4gICAgICB2YXIgdGhpc1NwYWNpbmcgPSB0aGlzLmdldFN0eWxlKCdsZXR0ZXItc3BhY2luZycpO1xuICAgICAgdmFyIHBhcmVudFNwYWNpbmcgPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgnbGV0dGVyLXNwYWNpbmcnKTtcbiAgICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gMDtcblxuICAgICAgaWYgKCF0aGlzU3BhY2luZy5oYXNWYWx1ZSgpIHx8IHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgPT09ICdpbmhlcml0Jykge1xuICAgICAgICBsZXR0ZXJTcGFjaW5nID0gcGFyZW50U3BhY2luZy5nZXRQaXhlbHMoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpc1NwYWNpbmcuaGFzVmFsdWUoKSkge1xuICAgICAgICBpZiAodGhpc1NwYWNpbmcuZ2V0VmFsdWUoKSAhPT0gJ2luaXRpYWwnICYmIHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgIT09ICd1bnNldCcpIHtcbiAgICAgICAgICBsZXR0ZXJTcGFjaW5nID0gdGhpc1NwYWNpbmcuZ2V0UGl4ZWxzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZmlsbCBsZXR0ZXItc3BhY2luZyBjYWNoZVxuXG5cbiAgICAgIHZhciBsZXR0ZXJTcGFjaW5nQ2FjaGUgPSBbXTtcbiAgICAgIHZhciB0ZXh0TGVuID0gcmVuZGVyVGV4dC5sZW5ndGg7XG4gICAgICB0aGlzLmxldHRlclNwYWNpbmdDYWNoZSA9IGxldHRlclNwYWNpbmdDYWNoZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGVuOyBpKyspIHtcbiAgICAgICAgbGV0dGVyU3BhY2luZ0NhY2hlLnB1c2godHlwZW9mIGR4W2ldICE9PSAndW5kZWZpbmVkJyA/IGR4W2ldIDogbGV0dGVyU3BhY2luZyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkeFN1bSA9IGxldHRlclNwYWNpbmdDYWNoZS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VyLCBpKSB7XG4gICAgICAgIHJldHVybiBpID09PSAwID8gMCA6IGFjYyArIGN1ciB8fCAwO1xuICAgICAgfSwgMCk7XG4gICAgICB2YXIgdGV4dFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dChjdHgpO1xuICAgICAgdmFyIHRleHRGdWxsV2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGggKyBkeFN1bSwgMCk7XG4gICAgICB0aGlzLnRleHRXaWR0aCA9IHRleHRXaWR0aDtcbiAgICAgIHRoaXMudGV4dEhlaWdodCA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICAgIHRoaXMuZ2x5cGhJbmZvID0gW107XG4gICAgICB2YXIgZnVsbFBhdGhXaWR0aCA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5nZXRTdHlsZSgnc3RhcnRPZmZzZXQnKS5nZXROdW1iZXIoMCkgKiBmdWxsUGF0aFdpZHRoO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgIGlmIChhbmNob3IgPT09ICdtaWRkbGUnIHx8IGFuY2hvciA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgb2Zmc2V0ID0gLXRleHRGdWxsV2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5jaG9yID09PSAnZW5kJyB8fCBhbmNob3IgPT09ICdyaWdodCcpIHtcbiAgICAgICAgb2Zmc2V0ID0gLXRleHRGdWxsV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCArPSBzdGFydE9mZnNldDtcbiAgICAgIGNoYXJzLmZvckVhY2goZnVuY3Rpb24gKGNoYXIsIGkpIHtcbiAgICAgICAgLy8gRmluZCBzdWNoIHNlZ21lbnQgd2hhdCBkaXN0YW5jZSBiZXR3ZWVuIHAwIGFuZCBwMSBpcyBhcHByb3guIHdpZHRoIG9mIGdseXBoXG4gICAgICAgIHZhciBfdGhpczIkZmluZFNlZ21lbnRUb0YgPSBfdGhpczIuZmluZFNlZ21lbnRUb0ZpdENoYXIoY3R4LCBhbmNob3IsIHRleHRGdWxsV2lkdGgsIGZ1bGxQYXRoV2lkdGgsIHNwYWNlc051bWJlciwgb2Zmc2V0LCBkeSwgY2hhciwgaSksXG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gX3RoaXMyJGZpbmRTZWdtZW50VG9GLm9mZnNldCxcbiAgICAgICAgICAgIHNlZ21lbnQgPSBfdGhpczIkZmluZFNlZ21lbnRUb0Yuc2VnbWVudCxcbiAgICAgICAgICAgIHJvdGF0aW9uID0gX3RoaXMyJGZpbmRTZWdtZW50VG9GLnJvdGF0aW9uO1xuXG4gICAgICAgIG9mZnNldCA9IG5leHRPZmZzZXQ7XG5cbiAgICAgICAgaWYgKCFzZWdtZW50LnAwIHx8ICFzZWdtZW50LnAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRMaW5lTGVuZ3RoKFxuICAgICAgICAvLyBcdHNlZ21lbnQucDAueCxcbiAgICAgICAgLy8gXHRzZWdtZW50LnAwLnksXG4gICAgICAgIC8vIFx0c2VnbWVudC5wMS54LFxuICAgICAgICAvLyBcdHNlZ21lbnQucDEueVxuICAgICAgICAvLyApO1xuICAgICAgICAvLyBOb3RlOiBTaW5jZSBnbHlwaHMgYXJlIHJlbmRlcmVkIG9uZSBhdCBhIHRpbWUsIGFueSBrZXJuaW5nIHBhaXIgZGF0YSBidWlsdCBpbnRvIHRoZSBmb250IHdpbGwgbm90IGJlIHVzZWQuXG4gICAgICAgIC8vIENhbiBmb3Jlc2VlIGhhdmluZyBhIHJvdWdoIHBhaXIgdGFibGUgYnVpbHQgaW4gdGhhdCB0aGUgZGV2ZWxvcGVyIGNhbiBvdmVycmlkZSBhcyBuZWVkZWQuXG4gICAgICAgIC8vIE9yIHVzZSBcImR4XCIgYXR0cmlidXRlIG9mIHRoZSA8dGV4dD4gbm9kZSBhcyBhIG5haXZlIHJlcGxhY2VtZW50XG4gICAgICAgIC8vIGNvbnN0IGtlcm4gPSAwO1xuICAgICAgICAvLyBwbGFjZWhvbGRlciBmb3IgZnV0dXJlIGltcGxlbWVudGF0aW9uXG4gICAgICAgIC8vIGNvbnN0IG1pZHBvaW50ID0gdGhpcy5nZXRQb2ludE9uTGluZShcbiAgICAgICAgLy8gXHRrZXJuICsgd2lkdGggLyAyLjAsXG4gICAgICAgIC8vIFx0c2VnbWVudC5wMC54LCBzZWdtZW50LnAwLnksIHNlZ21lbnQucDEueCwgc2VnbWVudC5wMS55XG4gICAgICAgIC8vICk7XG5cblxuICAgICAgICBfdGhpczIuZ2x5cGhJbmZvLnB1c2goe1xuICAgICAgICAgIC8vIHRyYW5zcG9zZVg6IG1pZHBvaW50LngsXG4gICAgICAgICAgLy8gdHJhbnNwb3NlWTogbWlkcG9pbnQueSxcbiAgICAgICAgICB0ZXh0OiBjaGFyc1tpXSxcbiAgICAgICAgICBwMDogc2VnbWVudC5wMCxcbiAgICAgICAgICBwMTogc2VnbWVudC5wMSxcbiAgICAgICAgICByb3RhdGlvbjogcm90YXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VQYXRoRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVBhdGhEYXRhKHBhdGgpIHtcbiAgICAgIHRoaXMucGF0aExlbmd0aCA9IC0xOyAvLyByZXNldCBwYXRoIGxlbmd0aFxuXG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aENvbW1hbmRzID0gW107XG4gICAgICB2YXIgcGF0aFBhcnNlciA9IHBhdGgucGF0aFBhcnNlcjtcbiAgICAgIHBhdGhQYXJzZXIucmVzZXQoKTsgLy8gY29udmVydCBsLCBILCBoLCBWLCBhbmQgdiB0byBMXG5cbiAgICAgIHdoaWxlICghcGF0aFBhcnNlci5pc0VuZCgpKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gcGF0aFBhcnNlci5jdXJyZW50O1xuICAgICAgICB2YXIgc3RhcnRYID0gY3VycmVudCA/IGN1cnJlbnQueCA6IDA7XG4gICAgICAgIHZhciBzdGFydFkgPSBjdXJyZW50ID8gY3VycmVudC55IDogMDtcbiAgICAgICAgdmFyIGNvbW1hbmQgPSBwYXRoUGFyc2VyLm5leHQoKTtcbiAgICAgICAgdmFyIG5leHRDb21tYW5kVHlwZSA9IGNvbW1hbmQudHlwZTtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgICAgIHN3aXRjaCAoY29tbWFuZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgICB0aGlzLnBhdGhNKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoTChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuSE9SSVpfTElORV9UTzpcbiAgICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aEgocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlZFUlRfTElORV9UTzpcbiAgICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aFYocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgICAgdGhpcy5wYXRoQyhwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX0NVUlZFX1RPOlxuICAgICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoUyhwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgICAgIHRoaXMucGF0aFEocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9RVUFEX1RPOlxuICAgICAgICAgICAgbmV4dENvbW1hbmRUeXBlID0gdGhpcy5wYXRoVChwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5wYXRoQShwYXRoUGFyc2VyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNMT1NFX1BBVEg6XG4gICAgICAgICAgICBQYXRoRWxlbWVudC5wYXRoWihwYXRoUGFyc2VyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1hbmQudHlwZSAhPT0gUGF0aFBhcnNlci5DTE9TRV9QQVRIKSB7XG4gICAgICAgICAgcGF0aENvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogbmV4dENvbW1hbmRUeXBlLFxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICAgIHk6IHN0YXJ0WVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGhMZW5ndGg6IHRoaXMuY2FsY0xlbmd0aChzdGFydFgsIHN0YXJ0WSwgbmV4dENvbW1hbmRUeXBlLCBwb2ludHMpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aENvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogUGF0aFBhcnNlci5DTE9TRV9QQVRILFxuICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgIHBhdGhMZW5ndGg6IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aENvbW1hbmRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTShwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aE0kcG8gPSBQYXRoRWxlbWVudC5wYXRoTShwYXRoUGFyc2VyKS5wb2ludCxcbiAgICAgICAgICB4ID0gX1BhdGhFbGVtZW50JHBhdGhNJHBvLngsXG4gICAgICAgICAgeSA9IF9QYXRoRWxlbWVudCRwYXRoTSRwby55O1xuICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhMKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoTCRwbyA9IFBhdGhFbGVtZW50LnBhdGhMKHBhdGhQYXJzZXIpLnBvaW50LFxuICAgICAgICAgIHggPSBfUGF0aEVsZW1lbnQkcGF0aEwkcG8ueCxcbiAgICAgICAgICB5ID0gX1BhdGhFbGVtZW50JHBhdGhMJHBvLnk7XG4gICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhIXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhIKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoSCRwbyA9IFBhdGhFbGVtZW50LnBhdGhIKHBhdGhQYXJzZXIpLnBvaW50LFxuICAgICAgICAgIHggPSBfUGF0aEVsZW1lbnQkcGF0aEgkcG8ueCxcbiAgICAgICAgICB5ID0gX1BhdGhFbGVtZW50JHBhdGhIJHBvLnk7XG4gICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhWXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhWKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoViRwbyA9IFBhdGhFbGVtZW50LnBhdGhWKHBhdGhQYXJzZXIpLnBvaW50LFxuICAgICAgICAgIHggPSBfUGF0aEVsZW1lbnQkcGF0aFYkcG8ueCxcbiAgICAgICAgICB5ID0gX1BhdGhFbGVtZW50JHBhdGhWJHBvLnk7XG4gICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhDXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhDKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoQyA9IFBhdGhFbGVtZW50LnBhdGhDKHBhdGhQYXJzZXIpLFxuICAgICAgICAgIHBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhDLnBvaW50LFxuICAgICAgICAgIGNvbnRyb2xQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoQy5jb250cm9sUG9pbnQsXG4gICAgICAgICAgY3VycmVudFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhDLmN1cnJlbnRQb2ludDtcblxuICAgICAgcG9pbnRzLnB1c2gocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoUyhwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aFMgPSBQYXRoRWxlbWVudC5wYXRoUyhwYXRoUGFyc2VyKSxcbiAgICAgICAgICBwb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoUy5wb2ludCxcbiAgICAgICAgICBjb250cm9sUG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFMuY29udHJvbFBvaW50LFxuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoUy5jdXJyZW50UG9pbnQ7XG5cbiAgICAgIHBvaW50cy5wdXNoKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgIHJldHVybiBQYXRoUGFyc2VyLkNVUlZFX1RPO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoUVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoUShwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aFEgPSBQYXRoRWxlbWVudC5wYXRoUShwYXRoUGFyc2VyKSxcbiAgICAgICAgICBjb250cm9sUG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFEuY29udHJvbFBvaW50LFxuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoUS5jdXJyZW50UG9pbnQ7XG5cbiAgICAgIHBvaW50cy5wdXNoKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFQocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhUID0gUGF0aEVsZW1lbnQucGF0aFQocGF0aFBhcnNlciksXG4gICAgICAgICAgY29udHJvbFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhULmNvbnRyb2xQb2ludCxcbiAgICAgICAgICBjdXJyZW50UG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFQuY3VycmVudFBvaW50O1xuXG4gICAgICBwb2ludHMucHVzaChjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICByZXR1cm4gUGF0aFBhcnNlci5RVUFEX1RPO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoQVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoQShwYXRoUGFyc2VyKSB7XG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhBID0gUGF0aEVsZW1lbnQucGF0aEEocGF0aFBhcnNlciksXG4gICAgICAgICAgclggPSBfUGF0aEVsZW1lbnQkcGF0aEEuclgsXG4gICAgICAgICAgclkgPSBfUGF0aEVsZW1lbnQkcGF0aEEuclksXG4gICAgICAgICAgc3dlZXBGbGFnID0gX1BhdGhFbGVtZW50JHBhdGhBLnN3ZWVwRmxhZyxcbiAgICAgICAgICB4QXhpc1JvdGF0aW9uID0gX1BhdGhFbGVtZW50JHBhdGhBLnhBeGlzUm90YXRpb24sXG4gICAgICAgICAgY2VudHAgPSBfUGF0aEVsZW1lbnQkcGF0aEEuY2VudHAsXG4gICAgICAgICAgYTEgPSBfUGF0aEVsZW1lbnQkcGF0aEEuYTEsXG4gICAgICAgICAgYWQgPSBfUGF0aEVsZW1lbnQkcGF0aEEuYWQ7XG5cbiAgICAgIGlmIChzd2VlcEZsYWcgPT09IDAgJiYgYWQgPiAwKSB7XG4gICAgICAgIGFkIC09IDIgKiBNYXRoLlBJO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3dlZXBGbGFnID09PSAxICYmIGFkIDwgMCkge1xuICAgICAgICBhZCArPSAyICogTWF0aC5QSTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtjZW50cC54LCBjZW50cC55LCByWCwgclksIGExLCBhZCwgeEF4aXNSb3RhdGlvbiwgc3dlZXBGbGFnXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY0xlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjTGVuZ3RoKHgsIHksIGNvbW1hbmRUeXBlLCBwb2ludHMpIHtcbiAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgdmFyIHAxID0gbnVsbDtcbiAgICAgIHZhciBwMiA9IG51bGw7XG4gICAgICB2YXIgdCA9IDA7XG5cbiAgICAgIHN3aXRjaCAoY29tbWFuZFR5cGUpIHtcbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZUxlbmd0aCh4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSk7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIDEwMCBsaW5lIHNlZ21lbnRzXG4gICAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICAgIHAxID0gdGhpcy5nZXRQb2ludE9uQ3ViaWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG5cbiAgICAgICAgICBmb3IgKHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25DdWJpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBsZW47XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcblxuICAgICAgICAgIGZvciAodCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKSB7XG4gICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGxlbjtcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50c1s0XTsgLy8gNCA9IHRoZXRhXG5cbiAgICAgICAgICAgIHZhciBkVGhldGEgPSBwb2ludHNbNV07IC8vIDUgPSBkVGhldGFcblxuICAgICAgICAgICAgdmFyIGVuZCA9IHBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgICAgIHZhciBpbmMgPSBNYXRoLlBJIC8gMTgwLjA7IC8vIDEgZGVncmVlIHJlc29sdXRpb25cblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHN0YXJ0IC0gZW5kKSA8IGluYykge1xuICAgICAgICAgICAgICBpbmMgPSBNYXRoLmFicyhzdGFydCAtIGVuZCk7XG4gICAgICAgICAgICB9IC8vIE5vdGU6IGZvciBwdXJwb3NlIG9mIGNhbGN1bGF0aW5nIGFyYyBsZW5ndGgsIG5vdCBnb2luZyB0byB3b3JyeSBhYm91dCByb3RhdGluZyBYLWF4aXMgYnkgYW5nbGUgcHNpXG5cblxuICAgICAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgc3RhcnQsIDApO1xuXG4gICAgICAgICAgICBpZiAoZFRoZXRhIDwgMCkge1xuICAgICAgICAgICAgICAvLyBjbG9ja3dpc2VcbiAgICAgICAgICAgICAgZm9yICh0ID0gc3RhcnQgLSBpbmM7IHQgPiBlbmQ7IHQgLT0gaW5jKSB7XG4gICAgICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgdCwgMCk7XG4gICAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAgICAgICAgICBmb3IgKHQgPSBzdGFydCArIGluYzsgdCA8IGVuZDsgdCArPSBpbmMpIHtcbiAgICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCB0LCAwKTtcbiAgICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgZW5kLCAwKTtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50T25MaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50T25MaW5lKGRpc3QsIHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAgICAgdmFyIGZyb21YID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBwMXg7XG4gICAgICB2YXIgZnJvbVkgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHAxeTtcbiAgICAgIHZhciBtID0gKHAyeSAtIHAxeSkgLyAocDJ4IC0gcDF4ICsgUFNFVURPX1pFUk8pO1xuICAgICAgdmFyIHJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAvICgxICsgbSAqIG0pKTtcblxuICAgICAgaWYgKHAyeCA8IHAxeCkge1xuICAgICAgICBydW4gKj0gLTE7XG4gICAgICB9XG5cbiAgICAgIHZhciByaXNlID0gbSAqIHJ1bjtcbiAgICAgIHZhciBwdCA9IG51bGw7XG5cbiAgICAgIGlmIChwMnggPT09IHAxeCkge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBsaW5lXG4gICAgICAgIHB0ID0ge1xuICAgICAgICAgIHg6IGZyb21YLFxuICAgICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoZnJvbVkgLSBwMXkpIC8gKGZyb21YIC0gcDF4ICsgUFNFVURPX1pFUk8pID09PSBtKSB7XG4gICAgICAgIHB0ID0ge1xuICAgICAgICAgIHg6IGZyb21YICsgcnVuLFxuICAgICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGl4ID0gMDtcbiAgICAgICAgdmFyIGl5ID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuZ2V0TGluZUxlbmd0aChwMXgsIHAxeSwgcDJ4LCBwMnkpO1xuXG4gICAgICAgIGlmIChsZW4gPCBQU0VVRE9fWkVSTykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHUgPSAoZnJvbVggLSBwMXgpICogKHAyeCAtIHAxeCkgKyAoZnJvbVkgLSBwMXkpICogKHAyeSAtIHAxeSk7XG4gICAgICAgIHUgLz0gbGVuICogbGVuO1xuICAgICAgICBpeCA9IHAxeCArIHUgKiAocDJ4IC0gcDF4KTtcbiAgICAgICAgaXkgPSBwMXkgKyB1ICogKHAyeSAtIHAxeSk7XG4gICAgICAgIHZhciBwUmlzZSA9IHRoaXMuZ2V0TGluZUxlbmd0aChmcm9tWCwgZnJvbVksIGl4LCBpeSk7XG4gICAgICAgIHZhciBwUnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC0gcFJpc2UgKiBwUmlzZSk7XG4gICAgICAgIHJ1biA9IE1hdGguc3FydChwUnVuICogcFJ1biAvICgxICsgbSAqIG0pKTtcblxuICAgICAgICBpZiAocDJ4IDwgcDF4KSB7XG4gICAgICAgICAgcnVuICo9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgcmlzZSA9IG0gKiBydW47XG4gICAgICAgIHB0ID0ge1xuICAgICAgICAgIHg6IGl4ICsgcnVuLFxuICAgICAgICAgIHk6IGl5ICsgcmlzZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50T25QYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50T25QYXRoKGRpc3RhbmNlKSB7XG4gICAgICB2YXIgZnVsbExlbiA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgICAgdmFyIGN1bXVsYXRpdmVQYXRoTGVuZ3RoID0gMDtcbiAgICAgIHZhciBwID0gbnVsbDtcblxuICAgICAgaWYgKGRpc3RhbmNlIDwgLTAuMDAwMDUgfHwgZGlzdGFuY2UgLSAwLjAwMDA1ID4gZnVsbExlbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGFBcnJheSA9IHRoaXMuZGF0YUFycmF5O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YUFycmF5KSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY29tbWFuZCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGNvbW1hbmQgJiYgKGNvbW1hbmQucGF0aExlbmd0aCA8IDAuMDAwMDUgfHwgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKyBjb21tYW5kLnBhdGhMZW5ndGggKyAwLjAwMDA1IDwgZGlzdGFuY2UpKSB7XG4gICAgICAgICAgICBjdW11bGF0aXZlUGF0aExlbmd0aCArPSBjb21tYW5kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGVsdGEgPSBkaXN0YW5jZSAtIGN1bXVsYXRpdmVQYXRoTGVuZ3RoO1xuICAgICAgICAgIHZhciBjdXJyZW50VCA9IDA7XG5cbiAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25MaW5lKGRlbHRhLCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSwgY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY29tbWFuZC5wb2ludHNbNF07IC8vIDQgPSB0aGV0YVxuXG4gICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IGNvbW1hbmQucG9pbnRzWzVdOyAvLyA1ID0gZFRoZXRhXG5cbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gY29tbWFuZC5wb2ludHNbNF0gKyBkVGhldGE7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgPSBzdGFydCArIGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoICogZFRoZXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRUaGV0YSA8IDAgJiYgY3VycmVudFQgPCBlbmQgfHwgZFRoZXRhID49IDAgJiYgY3VycmVudFQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdLCBjdXJyZW50VCwgY29tbWFuZC5wb2ludHNbNl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgICAgY3VycmVudFQgPSBkZWx0YSAvIGNvbW1hbmQucGF0aExlbmd0aDtcblxuICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPiAxKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgPSAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKGN1cnJlbnRULCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSwgY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnBvaW50c1syXSwgY29tbWFuZC5wb2ludHNbM10sIGNvbW1hbmQucG9pbnRzWzRdLCBjb21tYW5kLnBvaW50c1s1XSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgICAgICAgY3VycmVudFQgPSBkZWx0YSAvIGNvbW1hbmQucGF0aExlbmd0aDtcblxuICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPiAxKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgPSAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihjdXJyZW50VCwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMaW5lTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExpbmVMZW5ndGgoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGF0aExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXRoTGVuZ3RoKCkge1xuICAgICAgaWYgKHRoaXMucGF0aExlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gdGhpcy5kYXRhQXJyYXkucmVkdWNlKGZ1bmN0aW9uIChsZW5ndGgsIGNvbW1hbmQpIHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZC5wYXRoTGVuZ3RoID4gMCA/IGxlbmd0aCArIGNvbW1hbmQucGF0aExlbmd0aCA6IGxlbmd0aDtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhdGhMZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50T25DdWJpY0JlemllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludE9uQ3ViaWNCZXppZXIocGN0LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5LCBwNHgsIHA0eSkge1xuICAgICAgdmFyIHggPSBwNHggKiBDQjEocGN0KSArIHAzeCAqIENCMihwY3QpICsgcDJ4ICogQ0IzKHBjdCkgKyBwMXggKiBDQjQocGN0KTtcbiAgICAgIHZhciB5ID0gcDR5ICogQ0IxKHBjdCkgKyBwM3kgKiBDQjIocGN0KSArIHAyeSAqIENCMyhwY3QpICsgcDF5ICogQ0I0KHBjdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50T25RdWFkcmF0aWNCZXppZXIocGN0LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgICB2YXIgeCA9IHAzeCAqIFFCMShwY3QpICsgcDJ4ICogUUIyKHBjdCkgKyBwMXggKiBRQjMocGN0KTtcbiAgICAgIHZhciB5ID0gcDN5ICogUUIxKHBjdCkgKyBwMnkgKiBRQjIocGN0KSArIHAxeSAqIFFCMyhwY3QpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoY3gsIGN5LCByeCwgcnksIHRoZXRhLCBwc2kpIHtcbiAgICAgIHZhciBjb3NQc2kgPSBNYXRoLmNvcyhwc2kpO1xuICAgICAgdmFyIHNpblBzaSA9IE1hdGguc2luKHBzaSk7XG4gICAgICB2YXIgcHQgPSB7XG4gICAgICAgIHg6IHJ4ICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5OiByeSAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGN4ICsgKHB0LnggKiBjb3NQc2kgLSBwdC55ICogc2luUHNpKSxcbiAgICAgICAgeTogY3kgKyAocHQueCAqIHNpblBzaSArIHB0LnkgKiBjb3NQc2kpXG4gICAgICB9O1xuICAgIH0gLy8gVE9ETyBuZWVkIHNvbWUgb3B0aW1pc2F0aW9ucy4gcG9zc2libHkgYnVpbGQgY2FjaGUgb25seSBmb3IgY3VydmVkIHNlZ21lbnRzP1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYnVpbGRFcXVpZGlzdGFudENhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJ1aWxkRXF1aWRpc3RhbnRDYWNoZShpbnB1dFN0ZXAsIGlucHV0UHJlY2lzaW9uKSB7XG4gICAgICB2YXIgZnVsbExlbiA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgICAgdmFyIHByZWNpc2lvbiA9IGlucHV0UHJlY2lzaW9uIHx8IDAuMjU7IC8vIGFjY3VyYWN5IHZzIHBlcmZvcm1hbmNlXG5cbiAgICAgIHZhciBzdGVwID0gaW5wdXRTdGVwIHx8IGZ1bGxMZW4gLyAxMDA7XG5cbiAgICAgIGlmICghdGhpcy5lcXVpZGlzdGFudENhY2hlIHx8IHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5zdGVwICE9PSBzdGVwIHx8IHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wcmVjaXNpb24gIT09IHByZWNpc2lvbikge1xuICAgICAgICAvLyBQcmVwYXJlIGNhY2hlXG4gICAgICAgIHRoaXMuZXF1aWRpc3RhbnRDYWNoZSA9IHtcbiAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgICAgIHBvaW50czogW11cbiAgICAgICAgfTsgLy8gQ2FsY3VsYXRlIHBvaW50c1xuXG4gICAgICAgIHZhciBzID0gMDtcblxuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8PSBmdWxsTGVuOyBsICs9IHByZWNpc2lvbikge1xuICAgICAgICAgIHZhciBwMCA9IHRoaXMuZ2V0UG9pbnRPblBhdGgobCk7XG4gICAgICAgICAgdmFyIHAxID0gdGhpcy5nZXRQb2ludE9uUGF0aChsICsgcHJlY2lzaW9uKTtcblxuICAgICAgICAgIGlmICghcDAgfHwgIXAxKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMC54LCBwMC55LCBwMS54LCBwMS55KTtcblxuICAgICAgICAgIGlmIChzID49IHN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgIHg6IHAwLngsXG4gICAgICAgICAgICAgIHk6IHAwLnksXG4gICAgICAgICAgICAgIGRpc3RhbmNlOiBsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHMgLT0gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RXF1aWRpc3RhbnRQb2ludE9uUGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKHRhcmdldERpc3RhbmNlLCBzdGVwLCBwcmVjaXNpb24pIHtcbiAgICAgIHRoaXMuYnVpbGRFcXVpZGlzdGFudENhY2hlKHN0ZXAsIHByZWNpc2lvbik7XG5cbiAgICAgIGlmICh0YXJnZXREaXN0YW5jZSA8IDAgfHwgdGFyZ2V0RGlzdGFuY2UgLSB0aGlzLmdldFBhdGhMZW5ndGgoKSA+IDAuMDAwMDUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZHggPSBNYXRoLnJvdW5kKHRhcmdldERpc3RhbmNlIC8gdGhpcy5nZXRQYXRoTGVuZ3RoKCkgKiAodGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50cy5sZW5ndGggLSAxKSk7XG4gICAgICByZXR1cm4gdGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50c1tpZHhdIHx8IG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHRQYXRoRWxlbWVudDtcbn0oVGV4dEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkZChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRkKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRkKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIGRhdGFVcmlSZWdleCA9IC9eXFxzKmRhdGE6KChbXi8sO10rXFwvW14vLDtdKykoPzo7KFteLDs9XSs9W14sOz1dKykpPyk/KD86OyhiYXNlNjQpKT8sKC4qKSQvaTtcblxudmFyIEltYWdlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlbmRlcmVkRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEltYWdlRWxlbWVudCwgX1JlbmRlcmVkRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRkKEltYWdlRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gSW1hZ2VFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBJbWFnZUVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdpbWFnZSc7XG4gICAgX3RoaXMubG9hZGVkID0gZmFsc2U7XG5cbiAgICB2YXIgaHJlZiA9IF90aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXRTdHJpbmcoKTtcblxuICAgIGlmICghaHJlZikge1xuICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXShfdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3ZnID0gaHJlZi5lbmRzV2l0aCgnLnN2ZycpIHx8IC9eXFxzKmRhdGE6aW1hZ2VcXC9zdmdcXCt4bWwvaS50ZXN0KGhyZWYpO1xuICAgIGRvY3VtZW50LmltYWdlcy5wdXNoKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF90aGlzKSk7XG5cbiAgICBpZiAoIWlzU3ZnKSB7XG4gICAgICB2b2lkIF90aGlzLmxvYWRJbWFnZShocmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm9pZCBfdGhpcy5sb2FkU3ZnKGhyZWYpO1xuICAgIH1cblxuICAgIF90aGlzLmlzU3ZnID0gaXNTdmc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShJbWFnZUVsZW1lbnQsIFt7XG4gICAga2V5OiBcImxvYWRJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xvYWRJbWFnZSA9IF9hc3luY1RvR2VuZXJhdG9yX19kZWZhdWx0W1wiZGVmYXVsdFwiXSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShocmVmKSB7XG4gICAgICAgIHZhciBpbWFnZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuY3JlYXRlSW1hZ2UoaHJlZik7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGltYWdlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNztcbiAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIGxvYWRpbmcgaW1hZ2UgXFxcIlwiLmNvbmNhdChocmVmLCBcIlxcXCI6XCIpLCBfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDddXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZShfeCkge1xuICAgICAgICByZXR1cm4gX2xvYWRJbWFnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9hZEltYWdlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRTdmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9sb2FkU3ZnID0gX2FzeW5jVG9HZW5lcmF0b3JfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihocmVmKSB7XG4gICAgICAgIHZhciBtYXRjaCwgZGF0YSwgcmVzcG9uc2UsIHN2ZztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1hdGNoID0gZGF0YVVyaVJlZ2V4LmV4ZWMoaHJlZik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhID0gbWF0Y2hbNV07XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbNF0gPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gYXRvYihkYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGRlY29kZVVSSUNvbXBvbmVudChkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDY7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmZldGNoKGhyZWYpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIHN2ZyA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBzdmc7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTY7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oNik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIGxvYWRpbmcgaW1hZ2UgXFxcIlwiLmNvbmNhdChocmVmLCBcIlxcXCI6XCIpLCBfY29udGV4dDIudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzYsIDE2XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsb2FkU3ZnKF94Mikge1xuICAgICAgICByZXR1cm4gX2xvYWRTdmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvYWRTdmc7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQ2hpbGRyZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgICAgICBsb2FkZWQgPSB0aGlzLmxvYWRlZDtcbiAgICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICAgIGlmICghbG9hZGVkIHx8ICFpbWFnZSB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgICBpZiAodGhpcy5pc1N2Zykge1xuICAgICAgICB2YXIgc3ViRG9jdW1lbnQgPSBkb2N1bWVudC5jYW52Zy5mb3JrU3RyaW5nKGN0eCwgdGhpcy5pbWFnZSwge1xuICAgICAgICAgIGlnbm9yZU1vdXNlOiB0cnVlLFxuICAgICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgICBpZ25vcmVEaW1lbnNpb25zOiB0cnVlLFxuICAgICAgICAgIGlnbm9yZUNsZWFyOiB0cnVlLFxuICAgICAgICAgIG9mZnNldFg6IDAsXG4gICAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgICBzY2FsZVdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBzY2FsZUhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJEb2N1bWVudC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucGFyZW50ID0gdGhpcztcbiAgICAgICAgdm9pZCBzdWJEb2N1bWVudC5yZW5kZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICBkb2N1bWVudC5zZXRWaWV3Qm94KHtcbiAgICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgICBhc3BlY3RSYXRpbzogdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgZGVzaXJlZFdpZHRoOiBfaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgZGVzaXJlZEhlaWdodDogX2ltYWdlLmhlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIF9pbWFnZS5jb21wbGV0ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgX2ltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKF9pbWFnZSwgMCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KCkge1xuICAgICAgdmFyIHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2VFbGVtZW50O1xufShSZW5kZXJlZEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkYyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRjKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRjKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFN5bWJvbEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZW5kZXJlZEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTeW1ib2xFbGVtZW50LCBfUmVuZGVyZWRFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGMoU3ltYm9sRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gU3ltYm9sRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFN5bWJvbEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ3N5bWJvbCc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTeW1ib2xFbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKF8pIHsvLyBOTyBSRU5ERVJcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3ltYm9sRWxlbWVudDtcbn0oUmVuZGVyZWRFbGVtZW50KTtcblxudmFyIFNWR0ZvbnRMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTVkdGb250TG9hZGVyKGRvY3VtZW50KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBTVkdGb250TG9hZGVyKTtcblxuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgIGRvY3VtZW50LmZvbnRzLnB1c2godGhpcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFNWR0ZvbnRMb2FkZXIsIFt7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9sb2FkID0gX2FzeW5jVG9HZW5lcmF0b3JfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKGZvbnRGYW1pbHksIHVybCkge1xuICAgICAgICB2YXIgZG9jdW1lbnQsIHN2Z0RvY3VtZW50LCBmb250cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jYW52Zy5wYXJzZXIubG9hZCh1cmwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBzdmdEb2N1bWVudCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgZm9udHMgPSBzdmdEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9udCcpO1xuICAgICAgICAgICAgICAgIEFycmF5LmZyb20oZm9udHMpLmZvckVhY2goZnVuY3Rpb24gKGZvbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZm9udCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZm9udE5vZGUpO1xuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZGVmaW5pdGlvbnNbZm9udEZhbWlseV0gPSBmb250O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGZvbnQgXFxcIlwiLmNvbmNhdCh1cmwsIFwiXFxcIjpcIiksIF9jb250ZXh0LnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMCwgOV1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbG9hZChfeCwgX3gyKSB7XG4gICAgICAgIHJldHVybiBfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9hZDtcbiAgICB9KClcbiAgfV0pO1xuXG4gIHJldHVybiBTVkdGb250TG9hZGVyO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkYihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRiKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRiKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFN0eWxlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTdHlsZUVsZW1lbnQsIF9FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGIoU3R5bGVFbGVtZW50KTtcblxuICBmdW5jdGlvbiBTdHlsZUVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFN0eWxlRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICBfdGhpcy50eXBlID0gJ3N0eWxlJztcbiAgICB2YXIgY3NzID0gY29tcHJlc3NTcGFjZXMoQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpIC8vIE5FRUQgVEVTVFxuICAgIC5tYXAoZnVuY3Rpb24gKF8pIHtcbiAgICAgIHJldHVybiBfLnRleHRDb250ZW50O1xuICAgIH0pLmpvaW4oJycpLnJlcGxhY2UoLyhcXC9cXCooW14qXXxbXFxyXFxuXXwoXFwqKyhbXiovXXxbXFxyXFxuXSkpKSpcXCorXFwvKXwoXltcXHNdKlxcL1xcLy4qKS9nbSwgJycpIC8vIHJlbW92ZSBjb21tZW50c1xuICAgIC5yZXBsYWNlKC9AaW1wb3J0Lio7L2csICcnKSAvLyByZW1vdmUgaW1wb3J0c1xuICAgICk7XG4gICAgdmFyIGNzc0RlZnMgPSBjc3Muc3BsaXQoJ30nKTtcbiAgICBjc3NEZWZzLmZvckVhY2goZnVuY3Rpb24gKF8pIHtcbiAgICAgIHZhciBkZWYgPSBfLnRyaW0oKTtcblxuICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3NzUGFydHMgPSBkZWYuc3BsaXQoJ3snKTtcbiAgICAgIHZhciBjc3NDbGFzc2VzID0gY3NzUGFydHNbMF0uc3BsaXQoJywnKTtcbiAgICAgIHZhciBjc3NQcm9wcyA9IGNzc1BhcnRzWzFdLnNwbGl0KCc7Jyk7XG4gICAgICBjc3NDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgdmFyIGNzc0NsYXNzID0gXy50cmltKCk7XG5cbiAgICAgICAgaWYgKCFjc3NDbGFzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wcyA9IGRvY3VtZW50LnN0eWxlc1tjc3NDbGFzc10gfHwge307XG4gICAgICAgIGNzc1Byb3BzLmZvckVhY2goZnVuY3Rpb24gKGNzc1Byb3ApIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IGNzc1Byb3AuaW5kZXhPZignOicpO1xuICAgICAgICAgIHZhciBuYW1lID0gY3NzUHJvcC5zdWJzdHIoMCwgcHJvcCkudHJpbSgpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNzc1Byb3Auc3Vic3RyKHByb3AgKyAxLCBjc3NQcm9wLmxlbmd0aCAtIHByb3ApLnRyaW0oKTtcblxuICAgICAgICAgIGlmIChuYW1lICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBwcm9wc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LnN0eWxlc1tjc3NDbGFzc10gPSBwcm9wcztcbiAgICAgICAgZG9jdW1lbnQuc3R5bGVzU3BlY2lmaWNpdHlbY3NzQ2xhc3NdID0gZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eShjc3NDbGFzcyk7XG5cbiAgICAgICAgaWYgKGNzc0NsYXNzID09PSAnQGZvbnQtZmFjZScpIHtcbiAgICAgICAgICAvLyAgJiYgIW5vZGVFbnZcbiAgICAgICAgICB2YXIgZm9udEZhbWlseSA9IHByb3BzWydmb250LWZhbWlseSddLmdldFN0cmluZygpLnJlcGxhY2UoL1wifCcvZywgJycpO1xuICAgICAgICAgIHZhciBzcmNzID0gcHJvcHMuc3JjLmdldFN0cmluZygpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgc3Jjcy5mb3JFYWNoKGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIGlmIChzcmMuaW5kZXhPZignZm9ybWF0KFwic3ZnXCIpJykgPiAwKSB7XG4gICAgICAgICAgICAgIHZhciB1cmwgPSBwYXJzZUV4dGVybmFsVXJsKHNyYyk7XG5cbiAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgIHZvaWQgbmV3IFNWR0ZvbnRMb2FkZXIoZG9jdW1lbnQpLmxvYWQoZm9udEZhbWlseSwgdXJsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gU3R5bGVFbGVtZW50O1xufShFbGVtZW50KTtcblN0eWxlRWxlbWVudC5wYXJzZUV4dGVybmFsVXJsID0gcGFyc2VFeHRlcm5hbFVybDtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGEoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBVc2VFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVuZGVyZWRFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVXNlRWxlbWVudCwgX1JlbmRlcmVkRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRhKFVzZUVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFVzZUVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBVc2VFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICd1c2UnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVXNlRWxlbWVudCwgW3tcbiAgICBrZXk6IFwic2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb250ZXh0KGN0eCkge1xuICAgICAgX2dldF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShVc2VFbGVtZW50LnByb3RvdHlwZSksIFwic2V0Q29udGV4dFwiLCB0aGlzKS5jYWxsKHRoaXMsIGN0eCk7XG5cbiAgICAgIHZhciB4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgICB2YXIgeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpO1xuXG4gICAgICBpZiAoeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBjdHgudHJhbnNsYXRlKHhBdHRyLmdldFBpeGVscygneCcpLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB5QXR0ci5nZXRQaXhlbHMoJ3knKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aChjdHgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnBhdGgoY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQ2hpbGRyZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHZhciB0ZW1wU3ZnID0gZWxlbWVudDtcblxuICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudCBpbiBzeW1ib2wgY2FzZXMgKGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNVc2VFbGVtZW50KVxuICAgICAgICAgIHRlbXBTdmcgPSBuZXcgU1ZHRWxlbWVudChkb2N1bWVudCwgbnVsbCk7XG4gICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLnZpZXdCb3ggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd2aWV3Qm94JywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLnByZXNlcnZlQXNwZWN0UmF0aW8gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLm92ZXJmbG93ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnb3ZlcmZsb3cnLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgdGVtcFN2Zy5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47IC8vIGVsZW1lbnQgaXMgc3RpbGwgdGhlIHBhcmVudCBvZiB0aGUgY2hpbGRyZW5cblxuICAgICAgICAgIGVsZW1lbnQuc3R5bGVzLm9wYWNpdHkgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdvcGFjaXR5JywgdGhpcy5jYWxjdWxhdGVPcGFjaXR5KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRlbXBTdmcudHlwZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICB2YXIgd2lkdGhTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIHZhciBoZWlnaHRTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcsIGZhbHNlLCB0cnVlKTsgLy8gaWYgc3ltYm9sIG9yIHN2ZywgaW5oZXJpdCB3aWR0aC9oZWlnaHQgZnJvbSBtZVxuXG4gICAgICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCB3aWR0aFN0eWxlLmdldFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIGhlaWdodFN0eWxlLmdldFN0cmluZygpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2xkUGFyZW50ID0gdGVtcFN2Zy5wYXJlbnQ7XG4gICAgICAgIHRlbXBTdmcucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGVtcFN2Zy5yZW5kZXIoY3R4KTtcbiAgICAgICAgdGVtcFN2Zy5wYXJlbnQgPSBvbGRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbGVtZW50VHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVsZW1lbnRUcmFuc2Zvcm0oKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICByZXR1cm4gVHJhbnNmb3JtLmZyb21FbGVtZW50KGRvY3VtZW50LCBlbGVtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWxlbWVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLmNhY2hlZEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jYWNoZWRFbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZWRFbGVtZW50O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBVc2VFbGVtZW50O1xufShSZW5kZXJlZEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkOShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ5KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ5KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gaW1HZXQoaW1nLCB4LCB5LCB3aWR0aCwgX2hlaWdodCwgcmdiYSkge1xuICByZXR1cm4gaW1nW3kgKiB3aWR0aCAqIDQgKyB4ICogNCArIHJnYmFdO1xufVxuXG5mdW5jdGlvbiBpbVNldChpbWcsIHgsIHksIHdpZHRoLCBfaGVpZ2h0LCByZ2JhLCB2YWwpIHtcbiAgaW1nW3kgKiB3aWR0aCAqIDQgKyB4ICogNCArIHJnYmFdID0gdmFsO1xufVxuXG5mdW5jdGlvbiBtKG1hdHJpeCwgaSwgdikge1xuICB2YXIgbWkgPSBtYXRyaXhbaV07XG4gIHJldHVybiBtaSAqIHY7XG59XG5cbmZ1bmN0aW9uIGMoYSwgbTEsIG0yLCBtMykge1xuICByZXR1cm4gbTEgKyBNYXRoLmNvcyhhKSAqIG0yICsgTWF0aC5zaW4oYSkgKiBtMztcbn1cblxudmFyIEZlQ29sb3JNYXRyaXhFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEZlQ29sb3JNYXRyaXhFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ5KEZlQ29sb3JNYXRyaXhFbGVtZW50KTtcblxuICBmdW5jdGlvbiBGZUNvbG9yTWF0cml4RWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgRmVDb2xvck1hdHJpeEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdmZUNvbG9yTWF0cml4JztcbiAgICB2YXIgbWF0cml4ID0gdG9OdW1iZXJzKF90aGlzLmdldEF0dHJpYnV0ZSgndmFsdWVzJykuZ2V0U3RyaW5nKCkpO1xuXG4gICAgc3dpdGNoIChfdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKS5nZXRTdHJpbmcoJ21hdHJpeCcpKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvZmlsdGVycy5odG1sI2ZlQ29sb3JNYXRyaXhFbGVtZW50XG4gICAgICBjYXNlICdzYXR1cmF0ZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcyA9IG1hdHJpeFswXTtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICAgIG1hdHJpeCA9IFswLjIxMyArIDAuNzg3ICogcywgMC43MTUgLSAwLjcxNSAqIHMsIDAuMDcyIC0gMC4wNzIgKiBzLCAwLCAwLCAwLjIxMyAtIDAuMjEzICogcywgMC43MTUgKyAwLjI4NSAqIHMsIDAuMDcyIC0gMC4wNzIgKiBzLCAwLCAwLCAwLjIxMyAtIDAuMjEzICogcywgMC43MTUgLSAwLjcxNSAqIHMsIDAuMDcyICsgMC45MjggKiBzLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxXTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaHVlUm90YXRlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBhID0gbWF0cml4WzBdICogTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgbWF0cml4ID0gW2MoYSwgMC4yMTMsIDAuNzg3LCAtMC4yMTMpLCBjKGEsIDAuNzE1LCAtMC43MTUsIC0wLjcxNSksIGMoYSwgMC4wNzIsIC0wLjA3MiwgMC45MjgpLCAwLCAwLCBjKGEsIDAuMjEzLCAtMC4yMTMsIDAuMTQzKSwgYyhhLCAwLjcxNSwgMC4yODUsIDAuMTQwKSwgYyhhLCAwLjA3MiwgLTAuMDcyLCAtMC4yODMpLCAwLCAwLCBjKGEsIDAuMjEzLCAtMC4yMTMsIC0wLjc4NyksIGMoYSwgMC43MTUsIC0wLjcxNSwgMC43MTUpLCBjKGEsIDAuMDcyLCAwLjkyOCwgMC4wNzIpLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxXTtcbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnbHVtaW5hbmNlVG9BbHBoYSc6XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuICAgICAgICBtYXRyaXggPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMC4yMTI1LCAwLjcxNTQsIDAuMDcyMSwgMCwgMCwgMCwgMCwgMCwgMCwgMV07XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgX3RoaXMubWF0cml4ID0gbWF0cml4O1xuICAgIF90aGlzLmluY2x1ZGVPcGFjaXR5ID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdpbmNsdWRlT3BhY2l0eScpLmhhc1ZhbHVlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGZUNvbG9yTWF0cml4RWxlbWVudCwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoY3R4LCBfeCwgX3ksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIC8vIGFzc3VtaW5nIHg9PTAgJiYgeT09MCBmb3Igbm93XG4gICAgICB2YXIgaW5jbHVkZU9wYWNpdHkgPSB0aGlzLmluY2x1ZGVPcGFjaXR5LFxuICAgICAgICAgIG1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgICAgdmFyIHNyY0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgIHZhciByID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwKTtcbiAgICAgICAgICB2YXIgZyA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSk7XG4gICAgICAgICAgdmFyIGIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIpO1xuICAgICAgICAgIHZhciBhID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzKTtcbiAgICAgICAgICB2YXIgbnIgPSBtKG1hdHJpeCwgMCwgcikgKyBtKG1hdHJpeCwgMSwgZykgKyBtKG1hdHJpeCwgMiwgYikgKyBtKG1hdHJpeCwgMywgYSkgKyBtKG1hdHJpeCwgNCwgMSk7XG4gICAgICAgICAgdmFyIG5nID0gbShtYXRyaXgsIDUsIHIpICsgbShtYXRyaXgsIDYsIGcpICsgbShtYXRyaXgsIDcsIGIpICsgbShtYXRyaXgsIDgsIGEpICsgbShtYXRyaXgsIDksIDEpO1xuICAgICAgICAgIHZhciBuYiA9IG0obWF0cml4LCAxMCwgcikgKyBtKG1hdHJpeCwgMTEsIGcpICsgbShtYXRyaXgsIDEyLCBiKSArIG0obWF0cml4LCAxMywgYSkgKyBtKG1hdHJpeCwgMTQsIDEpO1xuICAgICAgICAgIHZhciBuYSA9IG0obWF0cml4LCAxNSwgcikgKyBtKG1hdHJpeCwgMTYsIGcpICsgbShtYXRyaXgsIDE3LCBiKSArIG0obWF0cml4LCAxOCwgYSkgKyBtKG1hdHJpeCwgMTksIDEpO1xuXG4gICAgICAgICAgaWYgKGluY2x1ZGVPcGFjaXR5KSB7XG4gICAgICAgICAgICBuciA9IDA7XG4gICAgICAgICAgICBuZyA9IDA7XG4gICAgICAgICAgICBuYiA9IDA7XG4gICAgICAgICAgICBuYSAqPSBhIC8gMjU1O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgbnIpO1xuICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSwgbmcpO1xuICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMiwgbmIpO1xuICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMywgbmEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKHNyY0RhdGEsIDAsIDApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGZUNvbG9yTWF0cml4RWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ4KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDgoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDgoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgTWFza0VsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oTWFza0VsZW1lbnQsIF9FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDgoTWFza0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIE1hc2tFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgTWFza0VsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ21hc2snO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oTWFza0VsZW1lbnQsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGN0eCwgZWxlbWVudCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudDsgLy8gcmVuZGVyIGFzIHRlbXAgc3ZnXG5cbiAgICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICAgIGlmICghd2lkdGggJiYgIWhlaWdodCkge1xuICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkLmdldEJvdW5kaW5nQm94KGN0eCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgeCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueDEpO1xuICAgICAgICB5ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC55MSk7XG4gICAgICAgIHdpZHRoID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC53aWR0aCk7XG4gICAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3guaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlnbm9yZWRTdHlsZXMgPSB0aGlzLnJlbW92ZVN0eWxlcyhlbGVtZW50LCBNYXNrRWxlbWVudC5pZ25vcmVTdHlsZXMpO1xuICAgICAgdmFyIG1hc2tDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXMoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgIHZhciBtYXNrQ3R4ID0gbWFza0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKG1hc2tDdHgpO1xuICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihtYXNrQ3R4KTsgLy8gY29udmVydCBtYXNrIHRvIGFscGhhIHdpdGggYSBmYWtlIG5vZGVcbiAgICAgIC8vIFRPRE86IHJlZmFjdG9yIG91dCBhcHBseSBmcm9tIGZlQ29sb3JNYXRyaXhcblxuICAgICAgbmV3IEZlQ29sb3JNYXRyaXhFbGVtZW50KGRvY3VtZW50LCB7XG4gICAgICAgIG5vZGVUeXBlOiAxLFxuICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgYXR0cmlidXRlczogW3tcbiAgICAgICAgICBub2RlTmFtZTogJ3R5cGUnLFxuICAgICAgICAgIHZhbHVlOiAnbHVtaW5hbmNlVG9BbHBoYSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5vZGVOYW1lOiAnaW5jbHVkZU9wYWNpdHknLFxuICAgICAgICAgIHZhbHVlOiAndHJ1ZSdcbiAgICAgICAgfV1cbiAgICAgIH0pLmFwcGx5KG1hc2tDdHgsIDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICB2YXIgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBkb2N1bWVudC5zY3JlZW4uc2V0RGVmYXVsdHModG1wQ3R4KTtcbiAgICAgIGVsZW1lbnQucmVuZGVyKHRtcEN0eCk7XG4gICAgICB0bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgIHRtcEN0eC5maWxsU3R5bGUgPSBtYXNrQ3R4LmNyZWF0ZVBhdHRlcm4obWFza0NhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgICAgdG1wQ3R4LmZpbGxSZWN0KDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdG1wQ3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTsgLy8gcmVhc3NpZ24gbWFza1xuXG4gICAgICB0aGlzLnJlc3RvcmVTdHlsZXMoZWxlbWVudCwgaWdub3JlZFN0eWxlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoXykgey8vIE5PIFJFTkRFUlxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXNrRWxlbWVudDtcbn0oRWxlbWVudCk7XG5NYXNrRWxlbWVudC5pZ25vcmVTdHlsZXMgPSBbJ21hc2snLCAndHJhbnNmb3JtJywgJ2NsaXAtcGF0aCddO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ3KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ3KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkgey8vIE5PT1Bcbn07XG5cbnZhciBDbGlwUGF0aEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oQ2xpcFBhdGhFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ3KENsaXBQYXRoRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gQ2xpcFBhdGhFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgQ2xpcFBhdGhFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdjbGlwUGF0aCc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShDbGlwUGF0aEVsZW1lbnQsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGN0eCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudDtcbiAgICAgIHZhciBjb250ZXh0UHJvdG8gPSBSZWZsZWN0LmdldFByb3RvdHlwZU9mKGN0eCk7XG4gICAgICB2YXIgYmVnaW5QYXRoID0gY3R4LmJlZ2luUGF0aCxcbiAgICAgICAgICBjbG9zZVBhdGggPSBjdHguY2xvc2VQYXRoO1xuXG4gICAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICAgIGNvbnRleHRQcm90by5iZWdpblBhdGggPSBub29wO1xuICAgICAgICBjb250ZXh0UHJvdG8uY2xvc2VQYXRoID0gbm9vcDtcbiAgICAgIH1cblxuICAgICAgUmVmbGVjdC5hcHBseShiZWdpblBhdGgsIGN0eCwgW10pO1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnBhdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHR5cGVvZiBjaGlsZC5lbGVtZW50VHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJyA/IGNoaWxkLmVsZW1lbnRUcmFuc2Zvcm0oKSA6IG51bGw7IC8vIGhhbmRsZSA8dXNlIC8+XG5cbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm0uZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICB0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkLnBhdGgoY3R4KTtcblxuICAgICAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICAgICAgY29udGV4dFByb3RvLmNsb3NlUGF0aCA9IGNsb3NlUGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICB0cmFuc2Zvcm0udW5hcHBseShjdHgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFJlZmxlY3QuYXBwbHkoY2xvc2VQYXRoLCBjdHgsIFtdKTtcbiAgICAgIGN0eC5jbGlwKCk7XG5cbiAgICAgIGlmIChjb250ZXh0UHJvdG8pIHtcbiAgICAgICAgY29udGV4dFByb3RvLmJlZ2luUGF0aCA9IGJlZ2luUGF0aDtcbiAgICAgICAgY29udGV4dFByb3RvLmNsb3NlUGF0aCA9IGNsb3NlUGF0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENsaXBQYXRoRWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ2KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDYoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDYoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRmlsdGVyRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGaWx0ZXJFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ2KEZpbHRlckVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEZpbHRlckVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBGaWx0ZXJFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdmaWx0ZXInO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRmlsdGVyRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoY3R4LCBlbGVtZW50KSB7XG4gICAgICAvLyByZW5kZXIgYXMgdGVtcCBzdmdcbiAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQsXG4gICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgdmFyIGJvdW5kaW5nQm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpO1xuXG4gICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHB4ID0gMDtcbiAgICAgIHZhciBweSA9IDA7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIgZWZkID0gY2hpbGQuZXh0cmFGaWx0ZXJEaXN0YW5jZSB8fCAwO1xuICAgICAgICBweCA9IE1hdGgubWF4KHB4LCBlZmQpO1xuICAgICAgICBweSA9IE1hdGgubWF4KHB5LCBlZmQpO1xuICAgICAgfSk7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LndpZHRoKTtcbiAgICAgIHZhciBoZWlnaHQgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgICB2YXIgdG1wQ2FudmFzV2lkdGggPSB3aWR0aCArIDIgKiBweDtcbiAgICAgIHZhciB0bXBDYW52YXNIZWlnaHQgPSBoZWlnaHQgKyAyICogcHk7XG5cbiAgICAgIGlmICh0bXBDYW52YXNXaWR0aCA8IDEgfHwgdG1wQ2FudmFzSGVpZ2h0IDwgMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC54KTtcbiAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC55KTtcbiAgICAgIHZhciBpZ25vcmVkU3R5bGVzID0gdGhpcy5yZW1vdmVTdHlsZXMoZWxlbWVudCwgRmlsdGVyRWxlbWVudC5pZ25vcmVTdHlsZXMpO1xuICAgICAgdmFyIHRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyh0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0KTtcbiAgICAgIHZhciB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRvY3VtZW50LnNjcmVlbi5zZXREZWZhdWx0cyh0bXBDdHgpO1xuICAgICAgdG1wQ3R4LnRyYW5zbGF0ZSgteCArIHB4LCAteSArIHB5KTtcbiAgICAgIGVsZW1lbnQucmVuZGVyKHRtcEN0eCk7IC8vIGFwcGx5IGZpbHRlcnNcblxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC5hcHBseSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNoaWxkLmFwcGx5KHRtcEN0eCwgMCwgMCwgdG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyByZW5kZXIgb24gbWVcblxuICAgICAgY3R4LmRyYXdJbWFnZSh0bXBDYW52YXMsIDAsIDAsIHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQsIHggLSBweCwgeSAtIHB5LCB0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0KTtcbiAgICAgIHRoaXMucmVzdG9yZVN0eWxlcyhlbGVtZW50LCBpZ25vcmVkU3R5bGVzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbHRlckVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuRmlsdGVyRWxlbWVudC5pZ25vcmVTdHlsZXMgPSBbJ2ZpbHRlcicsICd0cmFuc2Zvcm0nLCAnY2xpcC1wYXRoJ107XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ1KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDUoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDUoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRmVEcm9wU2hhZG93RWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGZURyb3BTaGFkb3dFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ1KEZlRHJvcFNoYWRvd0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEZlRHJvcFNoYWRvd0VsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEZlRHJvcFNoYWRvd0VsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdmZURyb3BTaGFkb3cnO1xuXG4gICAgX3RoaXMuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGZURyb3BTaGFkb3dFbGVtZW50LCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkgey8vIFRPRE86IGltcGxlbWVudFxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGZURyb3BTaGFkb3dFbGVtZW50O1xufShFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDQoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBGZU1vcnBob2xvZ3lFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEZlTW9ycGhvbG9neUVsZW1lbnQsIF9FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDQoRmVNb3JwaG9sb2d5RWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gRmVNb3JwaG9sb2d5RWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEZlTW9ycGhvbG9neUVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ2ZlTW9ycGhvbG9neSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGZU1vcnBob2xvZ3lFbGVtZW50LCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkgey8vIFRPRE86IGltcGxlbWVudFxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGZU1vcnBob2xvZ3lFbGVtZW50O1xufShFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDMoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBGZUNvbXBvc2l0ZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRmVDb21wb3NpdGVFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQzKEZlQ29tcG9zaXRlRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gRmVDb21wb3NpdGVFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgRmVDb21wb3NpdGVFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdmZUNvbXBvc2l0ZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGZUNvbXBvc2l0ZUVsZW1lbnQsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KF8sIF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KSB7Ly8gVE9ETzogaW1wbGVtZW50XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZlQ29tcG9zaXRlRWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDIoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDIoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRmVHYXVzc2lhbkJsdXJFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEZlR2F1c3NpYW5CbHVyRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMihGZUdhdXNzaWFuQmx1ckVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEZlR2F1c3NpYW5CbHVyRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgRmVHYXVzc2lhbkJsdXJFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAnZmVHYXVzc2lhbkJsdXInO1xuICAgIF90aGlzLmJsdXJSYWRpdXMgPSBNYXRoLmZsb29yKF90aGlzLmdldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJykuZ2V0TnVtYmVyKCkpO1xuICAgIF90aGlzLmV4dHJhRmlsdGVyRGlzdGFuY2UgPSBfdGhpcy5ibHVyUmFkaXVzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRmVHYXVzc2lhbkJsdXJFbGVtZW50LCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQsXG4gICAgICAgICAgYmx1clJhZGl1cyA9IHRoaXMuYmx1clJhZGl1cztcbiAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQud2luZG93ID8gZG9jdW1lbnQud2luZG93LmRvY3VtZW50LmJvZHkgOiBudWxsO1xuICAgICAgdmFyIGNhbnZhcyA9IGN0eC5jYW52YXM7IC8vIFN0YWNrQmx1ciByZXF1aXJlcyBjYW52YXMgYmUgb24gZG9jdW1lbnRcblxuICAgICAgY2FudmFzLmlkID0gZG9jdW1lbnQuZ2V0VW5pcXVlSWQoKTtcblxuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgc3RhY2tibHVyQ2FudmFzLmNhbnZhc1JHQkEoY2FudmFzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBibHVyUmFkaXVzKTtcblxuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgYm9keS5yZW1vdmVDaGlsZChjYW52YXMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGZUdhdXNzaWFuQmx1ckVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkMShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFRpdGxlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUaXRsZUVsZW1lbnQsIF9FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDEoVGl0bGVFbGVtZW50KTtcblxuICBmdW5jdGlvbiBUaXRsZUVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBUaXRsZUVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ3RpdGxlJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gVGl0bGVFbGVtZW50O1xufShFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBEZXNjRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXNjRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGVzY0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIERlc2NFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgRGVzY0VsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ2Rlc2MnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBEZXNjRWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbnZhciBlbGVtZW50cyA9IHtcbiAgJ3N2Zyc6IFNWR0VsZW1lbnQsXG4gICdyZWN0JzogUmVjdEVsZW1lbnQsXG4gICdjaXJjbGUnOiBDaXJjbGVFbGVtZW50LFxuICAnZWxsaXBzZSc6IEVsbGlwc2VFbGVtZW50LFxuICAnbGluZSc6IExpbmVFbGVtZW50LFxuICAncG9seWxpbmUnOiBQb2x5bGluZUVsZW1lbnQsXG4gICdwb2x5Z29uJzogUG9seWdvbkVsZW1lbnQsXG4gICdwYXRoJzogUGF0aEVsZW1lbnQsXG4gICdwYXR0ZXJuJzogUGF0dGVybkVsZW1lbnQsXG4gICdtYXJrZXInOiBNYXJrZXJFbGVtZW50LFxuICAnZGVmcyc6IERlZnNFbGVtZW50LFxuICAnbGluZWFyR3JhZGllbnQnOiBMaW5lYXJHcmFkaWVudEVsZW1lbnQsXG4gICdyYWRpYWxHcmFkaWVudCc6IFJhZGlhbEdyYWRpZW50RWxlbWVudCxcbiAgJ3N0b3AnOiBTdG9wRWxlbWVudCxcbiAgJ2FuaW1hdGUnOiBBbmltYXRlRWxlbWVudCxcbiAgJ2FuaW1hdGVDb2xvcic6IEFuaW1hdGVDb2xvckVsZW1lbnQsXG4gICdhbmltYXRlVHJhbnNmb3JtJzogQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQsXG4gICdmb250JzogRm9udEVsZW1lbnQsXG4gICdmb250LWZhY2UnOiBGb250RmFjZUVsZW1lbnQsXG4gICdtaXNzaW5nLWdseXBoJzogTWlzc2luZ0dseXBoRWxlbWVudCxcbiAgJ2dseXBoJzogR2x5cGhFbGVtZW50LFxuICAndGV4dCc6IFRleHRFbGVtZW50LFxuICAndHNwYW4nOiBUU3BhbkVsZW1lbnQsXG4gICd0cmVmJzogVFJlZkVsZW1lbnQsXG4gICdhJzogQUVsZW1lbnQsXG4gICd0ZXh0UGF0aCc6IFRleHRQYXRoRWxlbWVudCxcbiAgJ2ltYWdlJzogSW1hZ2VFbGVtZW50LFxuICAnZyc6IEdFbGVtZW50LFxuICAnc3ltYm9sJzogU3ltYm9sRWxlbWVudCxcbiAgJ3N0eWxlJzogU3R5bGVFbGVtZW50LFxuICAndXNlJzogVXNlRWxlbWVudCxcbiAgJ21hc2snOiBNYXNrRWxlbWVudCxcbiAgJ2NsaXBQYXRoJzogQ2xpcFBhdGhFbGVtZW50LFxuICAnZmlsdGVyJzogRmlsdGVyRWxlbWVudCxcbiAgJ2ZlRHJvcFNoYWRvdyc6IEZlRHJvcFNoYWRvd0VsZW1lbnQsXG4gICdmZU1vcnBob2xvZ3knOiBGZU1vcnBob2xvZ3lFbGVtZW50LFxuICAnZmVDb21wb3NpdGUnOiBGZUNvbXBvc2l0ZUVsZW1lbnQsXG4gICdmZUNvbG9yTWF0cml4JzogRmVDb2xvck1hdHJpeEVsZW1lbnQsXG4gICdmZUdhdXNzaWFuQmx1cic6IEZlR2F1c3NpYW5CbHVyRWxlbWVudCxcbiAgJ3RpdGxlJzogVGl0bGVFbGVtZW50LFxuICAnZGVzYyc6IERlc2NFbGVtZW50XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5X19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUltYWdlKF94KSB7XG4gIHJldHVybiBfY3JlYXRlSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUltYWdlKCkge1xuICBfY3JlYXRlSW1hZ2UgPSBfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoc3JjKSB7XG4gICAgdmFyIGFub255bW91c0Nyb3NzT3JpZ2luLFxuICAgICAgICBpbWFnZSxcbiAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBhbm9ueW1vdXNDcm9zc09yaWdpbiA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDogZmFsc2U7XG4gICAgICAgICAgICBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXG4gICAgICAgICAgICBpZiAoYW5vbnltb3VzQ3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGltYWdlKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKF9ldmVudCwgX3NvdXJjZSwgX2xpbmVubywgX2NvbG5vLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX2NyZWF0ZUltYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBEb2N1bWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERvY3VtZW50KGNhbnZnKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBfcmVmJHJvb3RFbVNpemUgPSBfcmVmLnJvb3RFbVNpemUsXG4gICAgICAgIHJvb3RFbVNpemUgPSBfcmVmJHJvb3RFbVNpemUgPT09IHZvaWQgMCA/IDEyIDogX3JlZiRyb290RW1TaXplLFxuICAgICAgICBfcmVmJGVtU2l6ZSA9IF9yZWYuZW1TaXplLFxuICAgICAgICBlbVNpemUgPSBfcmVmJGVtU2l6ZSA9PT0gdm9pZCAwID8gMTIgOiBfcmVmJGVtU2l6ZSxcbiAgICAgICAgX3JlZiRjcmVhdGVDYW52YXMgPSBfcmVmLmNyZWF0ZUNhbnZhcyxcbiAgICAgICAgY3JlYXRlQ2FudmFzID0gX3JlZiRjcmVhdGVDYW52YXMgPT09IHZvaWQgMCA/IERvY3VtZW50LmNyZWF0ZUNhbnZhcyA6IF9yZWYkY3JlYXRlQ2FudmFzLFxuICAgICAgICBfcmVmJGNyZWF0ZUltYWdlID0gX3JlZi5jcmVhdGVJbWFnZSxcbiAgICAgICAgY3JlYXRlSW1hZ2UgPSBfcmVmJGNyZWF0ZUltYWdlID09PSB2b2lkIDAgPyBEb2N1bWVudC5jcmVhdGVJbWFnZSA6IF9yZWYkY3JlYXRlSW1hZ2UsXG4gICAgICAgIGFub255bW91c0Nyb3NzT3JpZ2luID0gX3JlZi5hbm9ueW1vdXNDcm9zc09yaWdpbjtcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgRG9jdW1lbnQpO1xuXG4gICAgdGhpcy5jYW52ZyA9IGNhbnZnO1xuICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3R5bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmltYWdlcyA9IFtdO1xuICAgIHRoaXMuZm9udHMgPSBbXTtcbiAgICB0aGlzLmVtU2l6ZVN0YWNrID0gW107XG4gICAgdGhpcy51bmlxdWVJZCA9IDA7XG4gICAgdGhpcy5zY3JlZW4gPSBjYW52Zy5zY3JlZW47XG4gICAgdGhpcy5yb290RW1TaXplID0gcm9vdEVtU2l6ZTtcbiAgICB0aGlzLmVtU2l6ZSA9IGVtU2l6ZTtcbiAgICB0aGlzLmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbiAgICB0aGlzLmNyZWF0ZUltYWdlID0gdGhpcy5iaW5kQ3JlYXRlSW1hZ2UoY3JlYXRlSW1hZ2UsIGFub255bW91c0Nyb3NzT3JpZ2luKTtcbiAgICB0aGlzLnNjcmVlbi53YWl0KHRoaXMuaXNJbWFnZXNMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zY3JlZW4ud2FpdCh0aGlzLmlzRm9udHNMb2FkZWQuYmluZCh0aGlzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERvY3VtZW50LCBbe1xuICAgIGtleTogXCJiaW5kQ3JlYXRlSW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZENyZWF0ZUltYWdlKGNyZWF0ZUltYWdlLCBhbm9ueW1vdXNDcm9zc09yaWdpbikge1xuICAgICAgaWYgKHR5cGVvZiBhbm9ueW1vdXNDcm9zc09yaWdpbiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlLCBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlKHNvdXJjZSwgdHlwZW9mIGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4gPT09ICdib29sZWFuJyA/IGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4gOiBhbm9ueW1vdXNDcm9zc09yaWdpbik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVJbWFnZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9wRW1TaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcEVtU2l6ZSgpIHtcbiAgICAgIHZhciBlbVNpemVTdGFjayA9IHRoaXMuZW1TaXplU3RhY2s7XG4gICAgICBlbVNpemVTdGFjay5wb3AoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VW5pcXVlSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VW5pcXVlSWQoKSB7XG4gICAgICByZXR1cm4gXCJjYW52Z1wiLmNvbmNhdCgrK3RoaXMudW5pcXVlSWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ltYWdlc0xvYWRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ltYWdlc0xvYWRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlcy5ldmVyeShmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gXy5sb2FkZWQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGb250c0xvYWRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZvbnRzTG9hZGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9udHMuZXZlcnkoZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIF8ubG9hZGVkO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZURvY3VtZW50RWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudEVsZW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgIGRvY3VtZW50RWxlbWVudC5yb290ID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50RWxlbWVudC5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XG4gICAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50RWxlbWVudDtcbiAgICAgIHJldHVybiBkb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRWxlbWVudChub2RlKSB7XG4gICAgICB2YXIgZWxlbWVudFR5cGUgPSBub2RlLm5vZGVOYW1lLnJlcGxhY2UoL15bXjpdKzovLCAnJyk7XG4gICAgICB2YXIgRWxlbWVudFR5cGUgPSBEb2N1bWVudC5lbGVtZW50VHlwZXNbZWxlbWVudFR5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIEVsZW1lbnRUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRUeXBlKHRoaXMsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFVua25vd25FbGVtZW50KHRoaXMsIG5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVUZXh0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZShub2RlKSB7XG4gICAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMsIG5vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWaWV3Qm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZpZXdCb3goY29uZmlnKSB7XG4gICAgICB0aGlzLnNjcmVlbi5zZXRWaWV3Qm94KF9vYmplY3RTcHJlYWQkMSh7XG4gICAgICAgIGRvY3VtZW50OiB0aGlzXG4gICAgICB9LCBjb25maWcpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2luZG93XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JlZW4ud2luZG93O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmZXRjaFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmZldGNoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdHhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5jdHg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVtU2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGVtU2l6ZVN0YWNrID0gdGhpcy5lbVNpemVTdGFjaztcbiAgICAgIHJldHVybiBlbVNpemVTdGFja1tlbVNpemVTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgZW1TaXplU3RhY2sgPSB0aGlzLmVtU2l6ZVN0YWNrO1xuICAgICAgZW1TaXplU3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERvY3VtZW50O1xufSgpO1xuRG9jdW1lbnQuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuRG9jdW1lbnQuY3JlYXRlSW1hZ2UgPSBjcmVhdGVJbWFnZTtcbkRvY3VtZW50LmVsZW1lbnRUeXBlcyA9IGVsZW1lbnRzO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5X19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuLyoqXHJcbiAqIFNWRyByZW5kZXJlciBvbiBjYW52YXMuXHJcbiAqL1xuXG52YXIgQ2FudmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBNYWluIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIERvY3VtZW50LlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICovXG4gIGZ1bmN0aW9uIENhbnZnKGN0eCwgc3ZnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBDYW52Zyk7XG5cbiAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgdGhpcy5zY3JlZW4gPSBuZXcgU2NyZWVuKGN0eCwgb3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB2YXIgZG9jdW1lbnQgPSBuZXcgRG9jdW1lbnQodGhpcywgb3B0aW9ucyk7XG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RWxlbWVudChzdmcpO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50RWxlbWVudDtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgQ2FudmcgaW5zdGFuY2UgZnJvbSBTVkcgc291cmNlIHN0cmluZyBvciBVUkwuXHJcbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZyBvciBVUkwuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oQ2FudmcsIFt7XG4gICAga2V5OiBcImZvcmtcIixcblxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIG5ldyBDYW52ZyBpbnN0YW5jZSB3aXRoIGluaGVyaXRlZCBvcHRpb25zLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nIG9yIFVSTC5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JrKGN0eCwgc3ZnKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gQ2FudmcuZnJvbShjdHgsIHN2ZywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIG5ldyBDYW52ZyBpbnN0YW5jZSB3aXRoIGluaGVyaXRlZCBvcHRpb25zLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmb3JrU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmtTdHJpbmcoY3R4LCBzdmcpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHJldHVybiBDYW52Zy5mcm9tU3RyaW5nKGN0eCwgc3ZnLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEb2N1bWVudCBpcyByZWFkeSBwcm9taXNlLlxyXG4gICAgICogQHJldHVybnMgUmVhZHkgcHJvbWlzZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JlZW4ucmVhZHkoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEb2N1bWVudCBpcyByZWFkeSB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIElzIHJlYWR5IG9yIG5vdC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNSZWFkeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1JlYWR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmlzUmVhZHkoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgb25seSBmaXJzdCBmcmFtZSwgaWdub3JpbmcgYW5pbWF0aW9ucyBhbmQgbW91c2UuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW5kZXIgPSBfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBvcHRpb25zLFxuICAgICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJncy5sZW5ndGggPiAwICYmIF9hcmdzWzBdICE9PSB1bmRlZmluZWQgPyBfYXJnc1swXSA6IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICAgICAgICBlbmFibGVSZWRyYXc6IHRydWUsXG4gICAgICAgICAgICAgICAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkeSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9yZW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbmRlcjtcbiAgICB9KClcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyIG9wdGlvbnMuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IHRoaXMuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgIHNjcmVlbiA9IHRoaXMuc2NyZWVuLFxuICAgICAgICAgIGJhc2VPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgc2NyZWVuLnN0YXJ0KGRvY3VtZW50RWxlbWVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgZW5hYmxlUmVkcmF3OiB0cnVlXG4gICAgICB9LCBiYXNlT3B0aW9ucyksIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHJlbmRlcmluZy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5zY3JlZW4uc3RvcCgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlc2l6ZSBTVkcgdG8gZml0IGluIGdpdmVuIHNpemUuXHJcbiAgICAgKiBAcGFyYW0gd2lkdGhcclxuICAgICAqIEBwYXJhbSBoZWlnaHRcclxuICAgICAqIEBwYXJhbSBwcmVzZXJ2ZUFzcGVjdFJhdGlvXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUod2lkdGgpIHtcbiAgICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHdpZHRoO1xuICAgICAgdmFyIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdGhpcy5kb2N1bWVudEVsZW1lbnQucmVzaXplKHdpZHRoLCBoZWlnaHQsIHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9mcm9tID0gX2FzeW5jVG9HZW5lcmF0b3JfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihjdHgsIHN2Zykge1xuICAgICAgICB2YXIgb3B0aW9ucyxcbiAgICAgICAgICAgIHBhcnNlcixcbiAgICAgICAgICAgIHN2Z0RvY3VtZW50LFxuICAgICAgICAgICAgX2FyZ3MyID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzMi5sZW5ndGggPiAyICYmIF9hcmdzMlsyXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyWzJdIDoge307XG4gICAgICAgICAgICAgICAgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZShzdmcpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBzdmdEb2N1bWVudCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBDYW52ZyhjdHgsIHN2Z0RvY3VtZW50LCBvcHRpb25zKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGZyb20oX3gsIF94Mikge1xuICAgICAgICByZXR1cm4gX2Zyb20uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZyb207XG4gICAgfSgpXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgQ2FudmcgaW5zdGFuY2UgZnJvbSBTVkcgc291cmNlIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nKGN0eCwgc3ZnKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgIHZhciBzdmdEb2N1bWVudCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnKTtcbiAgICAgIHJldHVybiBuZXcgQ2FudmcoY3R4LCBzdmdEb2N1bWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbnZnO1xufSgpO1xuXG5leHBvcnRzLkFFbGVtZW50ID0gQUVsZW1lbnQ7XG5leHBvcnRzLkFuaW1hdGVDb2xvckVsZW1lbnQgPSBBbmltYXRlQ29sb3JFbGVtZW50O1xuZXhwb3J0cy5BbmltYXRlRWxlbWVudCA9IEFuaW1hdGVFbGVtZW50O1xuZXhwb3J0cy5BbmltYXRlVHJhbnNmb3JtRWxlbWVudCA9IEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50O1xuZXhwb3J0cy5Cb3VuZGluZ0JveCA9IEJvdW5kaW5nQm94O1xuZXhwb3J0cy5DQjEgPSBDQjE7XG5leHBvcnRzLkNCMiA9IENCMjtcbmV4cG9ydHMuQ0IzID0gQ0IzO1xuZXhwb3J0cy5DQjQgPSBDQjQ7XG5leHBvcnRzLkNhbnZnID0gQ2Fudmc7XG5leHBvcnRzLkNpcmNsZUVsZW1lbnQgPSBDaXJjbGVFbGVtZW50O1xuZXhwb3J0cy5DbGlwUGF0aEVsZW1lbnQgPSBDbGlwUGF0aEVsZW1lbnQ7XG5leHBvcnRzLkRlZnNFbGVtZW50ID0gRGVmc0VsZW1lbnQ7XG5leHBvcnRzLkRlc2NFbGVtZW50ID0gRGVzY0VsZW1lbnQ7XG5leHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQ7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5FbGxpcHNlRWxlbWVudCA9IEVsbGlwc2VFbGVtZW50O1xuZXhwb3J0cy5GZUNvbG9yTWF0cml4RWxlbWVudCA9IEZlQ29sb3JNYXRyaXhFbGVtZW50O1xuZXhwb3J0cy5GZUNvbXBvc2l0ZUVsZW1lbnQgPSBGZUNvbXBvc2l0ZUVsZW1lbnQ7XG5leHBvcnRzLkZlRHJvcFNoYWRvd0VsZW1lbnQgPSBGZURyb3BTaGFkb3dFbGVtZW50O1xuZXhwb3J0cy5GZUdhdXNzaWFuQmx1ckVsZW1lbnQgPSBGZUdhdXNzaWFuQmx1ckVsZW1lbnQ7XG5leHBvcnRzLkZlTW9ycGhvbG9neUVsZW1lbnQgPSBGZU1vcnBob2xvZ3lFbGVtZW50O1xuZXhwb3J0cy5GaWx0ZXJFbGVtZW50ID0gRmlsdGVyRWxlbWVudDtcbmV4cG9ydHMuRm9udCA9IEZvbnQ7XG5leHBvcnRzLkZvbnRFbGVtZW50ID0gRm9udEVsZW1lbnQ7XG5leHBvcnRzLkZvbnRGYWNlRWxlbWVudCA9IEZvbnRGYWNlRWxlbWVudDtcbmV4cG9ydHMuR0VsZW1lbnQgPSBHRWxlbWVudDtcbmV4cG9ydHMuR2x5cGhFbGVtZW50ID0gR2x5cGhFbGVtZW50O1xuZXhwb3J0cy5HcmFkaWVudEVsZW1lbnQgPSBHcmFkaWVudEVsZW1lbnQ7XG5leHBvcnRzLkltYWdlRWxlbWVudCA9IEltYWdlRWxlbWVudDtcbmV4cG9ydHMuTGluZUVsZW1lbnQgPSBMaW5lRWxlbWVudDtcbmV4cG9ydHMuTGluZWFyR3JhZGllbnRFbGVtZW50ID0gTGluZWFyR3JhZGllbnRFbGVtZW50O1xuZXhwb3J0cy5NYXJrZXJFbGVtZW50ID0gTWFya2VyRWxlbWVudDtcbmV4cG9ydHMuTWFza0VsZW1lbnQgPSBNYXNrRWxlbWVudDtcbmV4cG9ydHMuTWF0cml4ID0gTWF0cml4O1xuZXhwb3J0cy5NaXNzaW5nR2x5cGhFbGVtZW50ID0gTWlzc2luZ0dseXBoRWxlbWVudDtcbmV4cG9ydHMuTW91c2UgPSBNb3VzZTtcbmV4cG9ydHMuUFNFVURPX1pFUk8gPSBQU0VVRE9fWkVSTztcbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuZXhwb3J0cy5QYXRoRWxlbWVudCA9IFBhdGhFbGVtZW50O1xuZXhwb3J0cy5QYXRoUGFyc2VyID0gUGF0aFBhcnNlcjtcbmV4cG9ydHMuUGF0dGVybkVsZW1lbnQgPSBQYXR0ZXJuRWxlbWVudDtcbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbmV4cG9ydHMuUG9seWdvbkVsZW1lbnQgPSBQb2x5Z29uRWxlbWVudDtcbmV4cG9ydHMuUG9seWxpbmVFbGVtZW50ID0gUG9seWxpbmVFbGVtZW50O1xuZXhwb3J0cy5Qcm9wZXJ0eSA9IFByb3BlcnR5O1xuZXhwb3J0cy5RQjEgPSBRQjE7XG5leHBvcnRzLlFCMiA9IFFCMjtcbmV4cG9ydHMuUUIzID0gUUIzO1xuZXhwb3J0cy5SYWRpYWxHcmFkaWVudEVsZW1lbnQgPSBSYWRpYWxHcmFkaWVudEVsZW1lbnQ7XG5leHBvcnRzLlJlY3RFbGVtZW50ID0gUmVjdEVsZW1lbnQ7XG5leHBvcnRzLlJlbmRlcmVkRWxlbWVudCA9IFJlbmRlcmVkRWxlbWVudDtcbmV4cG9ydHMuUm90YXRlID0gUm90YXRlO1xuZXhwb3J0cy5TVkdFbGVtZW50ID0gU1ZHRWxlbWVudDtcbmV4cG9ydHMuU1ZHRm9udExvYWRlciA9IFNWR0ZvbnRMb2FkZXI7XG5leHBvcnRzLlNjYWxlID0gU2NhbGU7XG5leHBvcnRzLlNjcmVlbiA9IFNjcmVlbjtcbmV4cG9ydHMuU2tldyA9IFNrZXc7XG5leHBvcnRzLlNrZXdYID0gU2tld1g7XG5leHBvcnRzLlNrZXdZID0gU2tld1k7XG5leHBvcnRzLlN0b3BFbGVtZW50ID0gU3RvcEVsZW1lbnQ7XG5leHBvcnRzLlN0eWxlRWxlbWVudCA9IFN0eWxlRWxlbWVudDtcbmV4cG9ydHMuU3ltYm9sRWxlbWVudCA9IFN5bWJvbEVsZW1lbnQ7XG5leHBvcnRzLlRSZWZFbGVtZW50ID0gVFJlZkVsZW1lbnQ7XG5leHBvcnRzLlRTcGFuRWxlbWVudCA9IFRTcGFuRWxlbWVudDtcbmV4cG9ydHMuVGV4dEVsZW1lbnQgPSBUZXh0RWxlbWVudDtcbmV4cG9ydHMuVGV4dFBhdGhFbGVtZW50ID0gVGV4dFBhdGhFbGVtZW50O1xuZXhwb3J0cy5UaXRsZUVsZW1lbnQgPSBUaXRsZUVsZW1lbnQ7XG5leHBvcnRzLlRyYW5zZm9ybSA9IFRyYW5zZm9ybTtcbmV4cG9ydHMuVHJhbnNsYXRlID0gVHJhbnNsYXRlO1xuZXhwb3J0cy5Vbmtub3duRWxlbWVudCA9IFVua25vd25FbGVtZW50O1xuZXhwb3J0cy5Vc2VFbGVtZW50ID0gVXNlRWxlbWVudDtcbmV4cG9ydHMuVmlld1BvcnQgPSBWaWV3UG9ydDtcbmV4cG9ydHMuY29tcHJlc3NTcGFjZXMgPSBjb21wcmVzc1NwYWNlcztcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2Fudmc7XG5leHBvcnRzLmdldFNlbGVjdG9yU3BlY2lmaWNpdHkgPSBnZXRTZWxlY3RvclNwZWNpZmljaXR5O1xuZXhwb3J0cy5ub3JtYWxpemVBdHRyaWJ1dGVOYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZTtcbmV4cG9ydHMubm9ybWFsaXplQ29sb3IgPSBub3JtYWxpemVDb2xvcjtcbmV4cG9ydHMucGFyc2VFeHRlcm5hbFVybCA9IHBhcnNlRXh0ZXJuYWxVcmw7XG5leHBvcnRzLnByZXNldHMgPSBpbmRleDtcbmV4cG9ydHMudG9OdW1iZXJzID0gdG9OdW1iZXJzO1xuZXhwb3J0cy50cmltTGVmdCA9IHRyaW1MZWZ0O1xuZXhwb3J0cy50cmltUmlnaHQgPSB0cmltUmlnaHQ7XG5leHBvcnRzLnZlY3Rvck1hZ25pdHVkZSA9IHZlY3Rvck1hZ25pdHVkZTtcbmV4cG9ydHMudmVjdG9yc0FuZ2xlID0gdmVjdG9yc0FuZ2xlO1xuZXhwb3J0cy52ZWN0b3JzUmF0aW8gPSB2ZWN0b3JzUmF0aW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1WTJweklpd2ljMjkxY21ObGN5STZXMTBzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenNpZlE9PVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVxdWlyZSIsIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJfYXN5bmNUb0dlbmVyYXRvciIsIl9zbGljZWRUb0FycmF5IiwiX2RlZmluZVByb3BlcnR5IiwiX2NsYXNzQ2FsbENoZWNrIiwiX2NyZWF0ZUNsYXNzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiUkdCQ29sb3IiLCJfaW5oZXJpdHMiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9nZXRQcm90b3R5cGVPZiIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9nZXQiLCJzdmdQYXRoZGF0YSIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzdGFja2JsdXJDYW52YXMiLCJfaW50ZXJvcERlZmF1bHRMZWdhY3kiLCJlIiwiX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdCIsIl9hc3luY1RvR2VuZXJhdG9yX19kZWZhdWx0IiwiX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHQiLCJfZGVmaW5lUHJvcGVydHlfX2RlZmF1bHQiLCJfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHQiLCJfY3JlYXRlQ2xhc3NfX2RlZmF1bHQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVfX2RlZmF1bHQiLCJSR0JDb2xvcl9fZGVmYXVsdCIsIl9pbmhlcml0c19fZGVmYXVsdCIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0IiwiX2dldFByb3RvdHlwZU9mX19kZWZhdWx0IiwiX3RvQ29uc3VtYWJsZUFycmF5X19kZWZhdWx0IiwiX2dldF9fZGVmYXVsdCIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRfX2RlZmF1bHQiLCJvZmZzY3JlZW4iLCJfcmVmIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiRE9NUGFyc2VyRmFsbGJhY2siLCJET01QYXJzZXIiLCJwcmVzZXQiLCJ3aW5kb3ciLCJpZ25vcmVBbmltYXRpb24iLCJpZ25vcmVNb3VzZSIsImNyZWF0ZUNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwiT2Zmc2NyZWVuQ2FudmFzIiwiY3JlYXRlSW1hZ2UiLCJ1cmwiLCJtYXJrIiwiX2NhbGxlZSIsInJlc3BvbnNlIiwiYmxvYiIsImltZyIsIndyYXAiLCJfY2FsbGVlJCIsIl9jb250ZXh0IiwicHJldiIsIm5leHQiLCJmZXRjaCIsInNlbnQiLCJjcmVhdGVJbWFnZUJpdG1hcCIsImFicnVwdCIsInN0b3AiLCJSZWZsZWN0IiwiZGVsZXRlUHJvcGVydHkiLCJub2RlIiwiY2FudmFzIiwibG9hZEltYWdlIiwiaW5kZXgiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJjb21wcmVzc1NwYWNlcyIsInN0ciIsInJlcGxhY2UiLCJ0cmltTGVmdCIsInRyaW1SaWdodCIsInRvTnVtYmVycyIsIm1hdGNoZXMiLCJtYXRjaCIsIm1hcCIsInBhcnNlRmxvYXQiLCJhbGxVcHBlcmNhc2UiLCJub3JtYWxpemVBdHRyaWJ1dGVOYW1lIiwibmFtZSIsInRlc3QiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlRXh0ZXJuYWxVcmwiLCJ1cmxNYXRjaCIsImV4ZWMiLCJub3JtYWxpemVDb2xvciIsImNvbG9yIiwic3RhcnRzV2l0aCIsInJnYlBhcnRzIiwibm9ybWFsaXplZENvbG9yIiwibnVtIiwiaXNGbG9hdCIsIlN0cmluZyIsIk1hdGgiLCJyb3VuZCIsImF0dHJpYnV0ZVJlZ2V4IiwiaWRSZWdleCIsImNsYXNzUmVnZXgiLCJwc2V1ZG9FbGVtZW50UmVnZXgiLCJwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4IiwicHNldWRvQ2xhc3NSZWdleCIsImVsZW1lbnRSZWdleCIsImZpbmRTZWxlY3Rvck1hdGNoIiwic2VsZWN0b3IiLCJyZWdleCIsImdldFNlbGVjdG9yU3BlY2lmaWNpdHkiLCJzcGVjaWZpY2l0eSIsImN1cnJlbnRTZWxlY3RvciIsImRlbHRhIiwiX2ZpbmRTZWxlY3Rvck1hdGNoIiwiX2ZpbmRTZWxlY3Rvck1hdGNoMiIsIl9maW5kU2VsZWN0b3JNYXRjaDMiLCJfZmluZFNlbGVjdG9yTWF0Y2g0IiwiX2ZpbmRTZWxlY3Rvck1hdGNoNSIsIl9maW5kU2VsZWN0b3JNYXRjaDYiLCJfZmluZFNlbGVjdG9yTWF0Y2g3IiwiX2ZpbmRTZWxlY3Rvck1hdGNoOCIsIl9maW5kU2VsZWN0b3JNYXRjaDkiLCJfZmluZFNlbGVjdG9yTWF0Y2gxMCIsIl9maW5kU2VsZWN0b3JNYXRjaDExIiwiX2ZpbmRTZWxlY3Rvck1hdGNoMTIiLCJfZmluZFNlbGVjdG9yTWF0Y2gxMyIsIl9maW5kU2VsZWN0b3JNYXRjaDE0Iiwiam9pbiIsIlBTRVVET19aRVJPIiwidmVjdG9yTWFnbml0dWRlIiwidiIsInNxcnQiLCJwb3ciLCJ2ZWN0b3JzUmF0aW8iLCJ1IiwidmVjdG9yc0FuZ2xlIiwiYWNvcyIsIkNCMSIsInQiLCJDQjIiLCJDQjMiLCJDQjQiLCJRQjEiLCJRQjIiLCJRQjMiLCJQcm9wZXJ0eSIsImRvY3VtZW50IiwiaXNOb3JtYWxpemVkQ29sb3IiLCJrZXkiLCJzcGxpdCIsInNlcGFyYXRvciIsImdldFN0cmluZyIsInRyaW0iLCJoYXNWYWx1ZSIsInplcm9Jc1ZhbHVlIiwiaXNTdHJpbmciLCJyZWdleHAiLCJyZXN1bHQiLCJpc1VybERlZmluaXRpb24iLCJpc1BpeGVscyIsImFzU3RyaW5nIiwiZW5kc1dpdGgiLCJzZXRWYWx1ZSIsImdldFZhbHVlIiwiZGVmIiwiZ2V0TnVtYmVyIiwibiIsImdldENvbG9yIiwiZ2V0RHBpIiwiZ2V0UmVtIiwicm9vdEVtU2l6ZSIsImdldEVtIiwiZW1TaXplIiwiZ2V0VW5pdHMiLCJnZXRQaXhlbHMiLCJheGlzT3JJc0ZvbnRTaXplIiwicHJvY2Vzc1BlcmNlbnQiLCJfcmVmMiIsImF4aXMiLCJpc0ZvbnRTaXplIiwidmlld1BvcnQiLCJzY3JlZW4iLCJtaW4iLCJjb21wdXRlU2l6ZSIsIm1heCIsImdldE1pbGxpc2Vjb25kcyIsImdldFJhZGlhbnMiLCJQSSIsImdldERlZmluaXRpb24iLCJkZWZpbml0aW9ucyIsImdldEZpbGxTdHlsZURlZmluaXRpb24iLCJlbGVtZW50Iiwib3BhY2l0eSIsImNyZWF0ZUdyYWRpZW50IiwiY3R4IiwiY3JlYXRlUGF0dGVybiIsImdldEhyZWZBdHRyaWJ1dGUiLCJwYXR0ZXJuVHJhbnNmb3JtIiwiZ2V0QXR0cmlidXRlIiwiZ2V0VGV4dEJhc2VsaW5lIiwidGV4dEJhc2VsaW5lTWFwcGluZyIsImFkZE9wYWNpdHkiLCJsZW4iLCJjb21tYXMiLCJpIiwib2siLCJhbHBoYSIsInRvUkdCQSIsImVtcHR5IiwiVmlld1BvcnQiLCJ2aWV3UG9ydHMiLCJjbGVhciIsInNldEN1cnJlbnQiLCJwdXNoIiwicmVtb3ZlQ3VycmVudCIsInBvcCIsImdldEN1cnJlbnQiLCJkIiwiZ2V0IiwiUG9pbnQiLCJ4IiwieSIsImFuZ2xlVG8iLCJwb2ludCIsImF0YW4yIiwiYXBwbHlUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJ4cCIsInlwIiwicGFyc2UiLCJkZWZhdWx0VmFsdWUiLCJfdG9OdW1iZXJzIiwiX3RvTnVtYmVyczIiLCJfdG9OdW1iZXJzMiQiLCJfdG9OdW1iZXJzMiQyIiwicGFyc2VTY2FsZSIsInNjYWxlIiwiX3RvTnVtYmVyczMiLCJfdG9OdW1iZXJzNCIsIl90b051bWJlcnM0JCIsIl90b051bWJlcnM0JDIiLCJwYXJzZVBhdGgiLCJwYXRoIiwicG9pbnRzIiwicGF0aFBvaW50cyIsIk1vdXNlIiwid29ya2luZyIsImV2ZW50cyIsImV2ZW50RWxlbWVudHMiLCJvbkNsaWNrIiwiYmluZCIsIm9uTW91c2VNb3ZlIiwiaXNXb3JraW5nIiwic3RhcnQiLCJvbmNsaWNrIiwib25tb3VzZW1vdmUiLCJoYXNFdmVudHMiLCJydW5FdmVudHMiLCJzdHlsZSIsImN1cnNvciIsImZvckVhY2giLCJydW4iLCJwYXJlbnQiLCJjaGVja1BhdGgiLCJpc1BvaW50SW5QYXRoIiwiY2hlY2tCb3VuZGluZ0JveCIsImJvdW5kaW5nQm94IiwiX3JlZjMiLCJpc1BvaW50SW5Cb3giLCJtYXBYWSIsIl90aGlzJHNjcmVlbiIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJvZmZzZXRQYXJlbnQiLCJzY3JvbGxYIiwic2Nyb2xsWSIsImV2ZW50IiwiX3RoaXMkbWFwWFkiLCJjbGllbnRYIiwiY2xpZW50WSIsInR5cGUiLCJldmVudFRhcmdldCIsIl90aGlzJG1hcFhZMiIsImRlZmF1bHRXaW5kb3ciLCJkZWZhdWx0RmV0Y2gkMSIsIlNjcmVlbiIsIl9yZWYkZmV0Y2giLCJfcmVmJHdpbmRvdyIsIkZSQU1FUkFURSIsIk1BWF9WSVJUVUFMX1BJWEVMUyIsIkNMSUVOVF9XSURUSCIsIkNMSUVOVF9IRUlHSFQiLCJtb3VzZSIsImFuaW1hdGlvbnMiLCJ3YWl0cyIsImZyYW1lRHVyYXRpb24iLCJpc1JlYWR5TG9jayIsImlzRmlyc3RSZW5kZXIiLCJpbnRlcnZhbElkIiwid2FpdCIsImNoZWNrZXIiLCJyZWFkeSIsInJlYWR5UHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaXNSZWFkeSIsImV2ZXJ5IiwiXyIsInJlc29sdmVSZWFkeSIsInNldERlZmF1bHRzIiwic3Ryb2tlU3R5bGUiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJtaXRlckxpbWl0Iiwic2V0Vmlld0JveCIsImFzcGVjdFJhdGlvIiwiZGVzaXJlZFdpZHRoIiwiZGVzaXJlZEhlaWdodCIsIl9yZWYyJG1pblgiLCJtaW5YIiwiX3JlZjIkbWluWSIsIm1pblkiLCJyZWZYIiwicmVmWSIsIl9yZWYyJGNsaXAiLCJjbGlwIiwiX3JlZjIkY2xpcFgiLCJjbGlwWCIsIl9yZWYyJGNsaXBZIiwiY2xpcFkiLCJjbGVhbkFzcGVjdFJhdGlvIiwiX2NsZWFuQXNwZWN0UmF0aW8kc3BsIiwiX2NsZWFuQXNwZWN0UmF0aW8kc3BsMiIsImFzcGVjdFJhdGlvQWxpZ24iLCJhc3BlY3RSYXRpb01lZXRPclNsaWNlIiwiYWxpZ24iLCJtZWV0T3JTbGljZSIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlTWluIiwic2NhbGVNYXgiLCJmaW5hbERlc2lyZWRXaWR0aCIsImZpbmFsRGVzaXJlZEhlaWdodCIsInJlZlhQcm9wIiwicmVmWVByb3AiLCJoYXNSZWZzIiwidHJhbnNsYXRlIiwic2NhbGVkQ2xpcFgiLCJzY2FsZWRDbGlwWSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsImNsb3NlUGF0aCIsImlzTWVldE1pblkiLCJpc1NsaWNlTWF4WSIsImlzTWVldE1pblgiLCJpc1NsaWNlTWF4WCIsIl90aGlzIiwiX3JlZjMkZW5hYmxlUmVkcmF3IiwiZW5hYmxlUmVkcmF3IiwiX3JlZjMkaWdub3JlTW91c2UiLCJfcmVmMyRpZ25vcmVBbmltYXRpb24iLCJfcmVmMyRpZ25vcmVEaW1lbnNpb24iLCJpZ25vcmVEaW1lbnNpb25zIiwiX3JlZjMkaWdub3JlQ2xlYXIiLCJpZ25vcmVDbGVhciIsImZvcmNlUmVkcmF3Iiwic2NhbGVXaWR0aCIsInNjYWxlSGVpZ2h0Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJyZW5kZXIiLCJub3ciLCJEYXRlIiwidGhlbiIsInRpY2siLCJzaG91bGRVcGRhdGUiLCJjYW5jZWwiLCJyZWR1Y2UiLCJhbmltYXRpb24iLCJ1cGRhdGUiLCJ3aWR0aFN0eWxlIiwiZ2V0U3R5bGUiLCJoZWlnaHRTdHlsZSIsImNvbmNhdCIsImNXaWR0aCIsImNsaWVudFdpZHRoIiwiY0hlaWdodCIsImNsaWVudEhlaWdodCIsInZpZXdCb3giLCJ4UmF0aW8iLCJ5UmF0aW8iLCJfd2lkdGhTdHlsZSIsImlzTmFOIiwiX2hlaWdodFN0eWxlIiwidHJhbnNmb3JtU3R5bGUiLCJjbGVhclJlY3QiLCJkZWZhdWx0RmV0Y2giLCJEZWZhdWx0RE9NUGFyc2VyIiwiUGFyc2VyIiwiX3JlZiRET01QYXJzZXIiLCJfcGFyc2UiLCJyZXNvdXJjZSIsInBhcnNlRnJvbVN0cmluZyIsImxvYWQiLCJfeCIsImFwcGx5IiwieG1sIiwicGFyc2VyIiwiY2hlY2tEb2N1bWVudCIsImVyciIsInBhcnNlckVycm9yIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJFcnJvciIsInRleHRDb250ZW50IiwiX2xvYWQiLCJfY2FsbGVlMiIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsInRleHQiLCJfeDIiLCJUcmFuc2xhdGUiLCJfdGhpcyRwb2ludCIsInVuYXBwbHkiLCJfdGhpcyRwb2ludDIiLCJhcHBseVRvUG9pbnQiLCJfdGhpcyRwb2ludDMiLCJSb3RhdGUiLCJyb3RhdGUiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJhbmdsZSIsIm9yaWdpblgiLCJvcmlnaW5ZIiwiY3giLCJjeSIsIm51bWJlcnMiLCJ0eCIsInR5IiwicmFkIiwiY29zIiwic2luIiwiU2NhbGUiLCJzY2FsZVNpemUiLCJfdGhpcyRzY2FsZSIsIl90aGlzJHNjYWxlMiIsIl90aGlzJHNjYWxlMyIsIk1hdHJpeCIsIm1hdHJpeCIsImEiLCJiIiwiYyIsImYiLCJnIiwiaCIsImRldCIsIl9jcmVhdGVTdXBlciRNIiwiRGVyaXZlZCIsImhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JE0iLCJfY3JlYXRlU3VwZXJJbnRlcm5hbCIsIlN1cGVyIiwiTmV3VGFyZ2V0IiwiY29uc3RydWN0b3IiLCJjb25zdHJ1Y3QiLCJzaGFtIiwiUHJveHkiLCJCb29sZWFuIiwicHJvdG90eXBlIiwidmFsdWVPZiIsImNhbGwiLCJTa2V3IiwiX01hdHJpeCIsIl9zdXBlciIsInNrZXciLCJfY3JlYXRlU3VwZXIkTCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkTCIsIlNrZXdYIiwiX1NrZXciLCJ0YW4iLCJfY3JlYXRlU3VwZXIkSyIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkSyIsIlNrZXdZIiwicGFyc2VUcmFuc2Zvcm1zIiwicGFyc2VUcmFuc2Zvcm0iLCJfdHJhbnNmb3JtJHNwbGl0IiwiX3RyYW5zZm9ybSRzcGxpdDIiLCJUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1zIiwiZGF0YSIsIl9wYXJzZVRyYW5zZm9ybSIsIl9wYXJzZVRyYW5zZm9ybTIiLCJUcmFuc2Zvcm1UeXBlIiwidHJhbnNmb3JtVHlwZXMiLCJmcm9tRWxlbWVudCIsIl9lbGVtZW50JGdldFN0eWxlJHNwbCIsIl9lbGVtZW50JGdldFN0eWxlJHNwbDIiLCJ0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHkiLCJfZWxlbWVudCRnZXRTdHlsZSRzcGwzIiwidHJhbnNmb3JtT3JpZ2luWVByb3BlcnR5Iiwic2tld1giLCJza2V3WSIsIkVsZW1lbnQiLCJjYXB0dXJlVGV4dE5vZGVzIiwiYXR0cmlidXRlcyIsImNyZWF0ZSIsInN0eWxlcyIsInN0eWxlc1NwZWNpZmljaXR5IiwiYW5pbWF0aW9uRnJvemVuIiwiYW5pbWF0aW9uRnJvemVuVmFsdWUiLCJjaGlsZHJlbiIsIm5vZGVUeXBlIiwiQXJyYXkiLCJmcm9tIiwiYXR0cmlidXRlIiwibm9kZU5hbWUiLCJhZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uIiwiX3N0eWxlJHNwbGl0JG1hcCIsIl9zdHlsZSRzcGxpdCRtYXAyIiwiaWQiLCJjaGlsZE5vZGVzIiwiY2hpbGROb2RlIiwiYWRkQ2hpbGQiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwiZ2V0VGV4dCIsImNyZWF0ZUlmTm90RXhpc3RzIiwiYXR0ciIsIl9hdHRyIiwic2tpcEFuY2VzdG9ycyIsInBhcmVudFN0eWxlIiwiX3N0eWxlIiwic2F2ZSIsIm1hc2siLCJhcHBseUVmZmVjdHMiLCJmaWx0ZXIiLCJzZXRDb250ZXh0IiwicmVuZGVyQ2hpbGRyZW4iLCJjbGVhckNvbnRleHQiLCJyZXN0b3JlIiwiY2xpcFBhdGhTdHlsZVByb3AiLCJjaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJpZ25vcmVDaGlsZFR5cGVzIiwiaW5jbHVkZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJfbm9kZSRnZXRBdHRyaWJ1dGUiLCJzdHlsZUNsYXNzZXMiLCJzb21lIiwic3R5bGVDbGFzcyIsIl90aGlzJGRvY3VtZW50IiwiZXhpc3RpbmdTcGVjaWZpY2l0eSIsInJlbW92ZVN0eWxlcyIsImlnbm9yZVN0eWxlcyIsInRvUmVzdG9yZSIsInN0eWxlUHJvcCIsInJlc3RvcmVTdHlsZXMiLCJpc0ZpcnN0Q2hpbGQiLCJfdGhpcyRwYXJlbnQiLCJpbmRleE9mIiwiX2NyZWF0ZVN1cGVyJEoiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEoiLCJVbmtub3duRWxlbWVudCIsIl9FbGVtZW50Iiwid3JhcEZvbnRGYW1pbHkiLCJmb250RmFtaWx5IiwidHJpbW1lZCIsInByZXBhcmVGb250RmFtaWx5IiwicHJvY2VzcyIsInByZXBhcmVGb250U3R5bGUiLCJmb250U3R5bGUiLCJ0YXJnZXRGb250U3R5bGUiLCJwcmVwYXJlRm9udFdlaWdodCIsImZvbnRXZWlnaHQiLCJ0YXJnZXRGb250V2VpZ2h0IiwiRm9udCIsImZvbnRWYXJpYW50IiwiZm9udFNpemUiLCJpbmhlcml0IiwiaW5oZXJpdEZvbnQiLCJ0b1N0cmluZyIsImZvbnQiLCJwYXJ0cyIsInNldCIsInBhcnQiLCJ2YXJpYW50cyIsIndlaWdodHMiLCJfcGFydCRzcGxpdCIsIl9wYXJ0JHNwbGl0MiIsIkJvdW5kaW5nQm94IiwieDEiLCJOdW1iZXIiLCJOYU4iLCJ5MSIsIngyIiwieTIiLCJhZGRQb2ludCIsImFkZFgiLCJhZGRZIiwiYWRkQm91bmRpbmdCb3giLCJzdW1DdWJpYyIsInAwIiwicDEiLCJwMiIsInAzIiwiYmV6aWVyQ3VydmVBZGQiLCJmb3JYIiwiYjJhYyIsInQxIiwidDIiLCJhZGRCZXppZXJDdXJ2ZSIsInAweCIsInAweSIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsInAzeCIsInAzeSIsImFkZFF1YWRyYXRpY0N1cnZlIiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsIl9jcmVhdGVTdXBlciRJIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRJIiwiUGF0aFBhcnNlciIsIl9TVkdQYXRoRGF0YSIsImNvbnRyb2wiLCJjdXJyZW50IiwiY29tbWFuZCIsImNvbW1hbmRzIiwicHJldmlvdXNDb21tYW5kIiwiYW5nbGVzIiwicmVzZXQiLCJpc0VuZCIsImdldFBvaW50IiwieFByb3AiLCJ5UHJvcCIsIm1ha2VBYnNvbHV0ZSIsImdldEFzQ29udHJvbFBvaW50IiwiZ2V0QXNDdXJyZW50UG9pbnQiLCJnZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQiLCJTVkdQYXRoRGF0YSIsIkNVUlZFX1RPIiwiU01PT1RIX0NVUlZFX1RPIiwiUVVBRF9UTyIsIlNNT09USF9RVUFEX1RPIiwiX3RoaXMkY3VycmVudCIsIl90aGlzJGNvbnRyb2wiLCJveCIsIm95IiwicmVsYXRpdmUiLCJfdGhpcyRjdXJyZW50MiIsImFkZE1hcmtlciIsInByaW9yVG8iLCJhZGRNYXJrZXJBbmdsZSIsImdldE1hcmtlclBvaW50cyIsImdldE1hcmtlckFuZ2xlcyIsImoiLCJfY3JlYXRlU3VwZXIkSCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkSCIsIlJlbmRlcmVkRWxlbWVudCIsIm1vZGlmaWVkRW1TaXplU3RhY2siLCJjYWxjdWxhdGVPcGFjaXR5Iiwib3BhY2l0eVN0eWxlIiwiZnJvbU1lYXN1cmUiLCJmaWxsU3R5bGVQcm9wIiwiZmlsbE9wYWNpdHlTdHlsZVByb3AiLCJzdHJva2VTdHlsZVByb3AiLCJzdHJva2VPcGFjaXR5UHJvcCIsImZpbGxTdHlsZSIsIl9maWxsU3R5bGUiLCJfZmlsbFN0eWxlMiIsIl9zdHJva2VTdHlsZSIsIl9zdHJva2VTdHlsZTIiLCJzdHJva2VXaWR0aFN0eWxlUHJvcCIsIm5ld0xpbmVXaWR0aCIsImxpbmVXaWR0aCIsInN0cm9rZUxpbmVjYXBTdHlsZVByb3AiLCJzdHJva2VMaW5lam9pblN0eWxlUHJvcCIsInN0cm9rZU1pdGVybGltaXRQcm9wIiwic3Ryb2tlRGFzaGFycmF5U3R5bGVQcm9wIiwic3Ryb2tlRGFzaG9mZnNldFByb3AiLCJnYXBzIiwic2V0TGluZURhc2giLCJ3ZWJraXRMaW5lRGFzaCIsIm1vekRhc2giLCJvZmZzZXQiLCJsaW5lRGFzaE9mZnNldCIsIndlYmtpdExpbmVEYXNoT2Zmc2V0IiwibW96RGFzaE9mZnNldCIsImZvbnRTdHlsZVByb3AiLCJmb250U3R5bGVTdHlsZVByb3AiLCJmb250VmFyaWFudFN0eWxlUHJvcCIsImZvbnRXZWlnaHRTdHlsZVByb3AiLCJmb250U2l6ZVN0eWxlUHJvcCIsImZvbnRGYW1pbHlTdHlsZVByb3AiLCJnbG9iYWxBbHBoYSIsInBvcEVtU2l6ZSIsIl9jcmVhdGVTdXBlciRHIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRHIiwiUGF0aEVsZW1lbnQiLCJfUmVuZGVyZWRFbGVtZW50IiwicGF0aFBhcnNlciIsIk1PVkVfVE8iLCJwYXRoTSIsIkxJTkVfVE8iLCJwYXRoTCIsIkhPUklaX0xJTkVfVE8iLCJwYXRoSCIsIlZFUlRfTElORV9UTyIsInBhdGhWIiwicGF0aEMiLCJwYXRoUyIsInBhdGhRIiwicGF0aFQiLCJBUkMiLCJwYXRoQSIsIkNMT1NFX1BBVEgiLCJwYXRoWiIsImdldEJvdW5kaW5nQm94IiwiZ2V0TWFya2VycyIsIm1hcmtlcnMiLCJmaWxsUnVsZVN0eWxlUHJvcCIsImZpbGwiLCJzZXRUcmFuc2Zvcm0iLCJzdHJva2UiLCJtYXJrZXJzTGFzdEluZGV4IiwibWFya2VyU3RhcnRTdHlsZVByb3AiLCJtYXJrZXJNaWRTdHlsZVByb3AiLCJtYXJrZXJFbmRTdHlsZVByb3AiLCJtYXJrZXIiLCJfbWFya2VycyQiLCJfbWFya2VyIiwiX21hcmtlcnMkaSIsIl9wb2ludCIsIl9hbmdsZSIsIl9tYXJrZXIyIiwiX21hcmtlcnMkbWFya2Vyc0xhc3RJIiwiX3BvaW50MiIsIl9hbmdsZTIiLCJfUGF0aEVsZW1lbnQkcGF0aE0iLCJfUGF0aEVsZW1lbnQkcGF0aEwiLCJfUGF0aEVsZW1lbnQkcGF0aEgiLCJfUGF0aEVsZW1lbnQkcGF0aFYiLCJfUGF0aEVsZW1lbnQkcGF0aEMiLCJjb250cm9sUG9pbnQiLCJjdXJyZW50UG9pbnQiLCJiZXppZXJDdXJ2ZVRvIiwiX1BhdGhFbGVtZW50JHBhdGhTIiwiX1BhdGhFbGVtZW50JHBhdGhRIiwicXVhZHJhdGljQ3VydmVUbyIsIl9QYXRoRWxlbWVudCRwYXRoVCIsIl9QYXRoRWxlbWVudCRwYXRoQSIsInJYIiwiclkiLCJzd2VlcEZsYWciLCJ4QXhpc1JvdGF0aW9uIiwiY2VudHAiLCJhMSIsImFkIiwiZGlyIiwiYWgiLCJoYWxmV2F5IiwiciIsInN4Iiwic3kiLCJhcmMiLCJ4Um90IiwibEFyY0ZsYWciLCJjdXJycCIsImwiLCJzIiwiY3BwIiwiX2NyZWF0ZVN1cGVyJEYiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEYiLCJHbHlwaEVsZW1lbnQiLCJfUGF0aEVsZW1lbnQiLCJob3JpekFkdlgiLCJ1bmljb2RlIiwiYXJhYmljRm9ybSIsIl9jcmVhdGVTdXBlciRFIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRFIiwiVGV4dEVsZW1lbnQiLCJtZWFzdXJlQ2FjaGUiLCJ0ZXh0QmFzZWxpbmUiLCJpbml0aWFsaXplQ29vcmRpbmF0ZXMiLCJsZWFmVGV4dHMiLCJ0ZXh0Q2h1bmtTdGFydCIsIlBPU0lUSVZFX0lORklOSVRZIiwibWF4WCIsIk5FR0FUSVZFX0lORklOSVRZIiwiX3RoaXMyIiwiZ2V0VEVsZW1lbnRCb3VuZGluZ0JveCIsImFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUiLCJjaGlsZEJvdW5kaW5nQm94IiwiZ2V0Q2hpbGRCb3VuZGluZ0JveCIsImdldEZvbnRTaXplIiwiaW5oZXJpdEZvbnRTaXplIiwibWVhc3VyZVRleHQiLCJnZXRHbHlwaCIsImNoYXIiLCJnbHlwaCIsImlzQXJhYmljIiwicHJldkNoYXIiLCJuZXh0Q2hhciIsImdseXBocyIsIm1heWJlR2x5cGgiLCJtaXNzaW5nR2x5cGgiLCJnZXRUZXh0RnJvbU5vZGUiLCJwYXJlbnROb2RlIiwibGFzdEluZGV4IiwiX3RoaXMzIiwicmVuZGVyVEVsZW1lbnRDaGlsZHJlbiIsInJlbmRlckNoaWxkIiwicmVuZGVyVGV4dCIsImN1c3RvbUZvbnQiLCJ1bml0c1BlckVtIiwiZm9udEZhY2UiLCJjdHhGb250IiwiaXNSVEwiLCJyZXZlcnNlIiwiZHgiLCJsdyIsImZpbGxUZXh0Iiwic3Ryb2tlVGV4dCIsImFwcGx5QW5jaG9yaW5nIiwiZmlyc3RFbGVtZW50IiwidGV4dEFuY2hvciIsInNoaWZ0IiwiX3RoaXM0IiwiYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUiLCJ0ZXh0UGFyZW50IiwiYWRqdXN0Q2hpbGRDb29yZGluYXRlcyIsInhBdHRyIiwieUF0dHIiLCJkeEF0dHIiLCJkeUF0dHIiLCJnZXRJbmhlcml0ZWRBdHRyaWJ1dGUiLCJtZWFzdXJlIiwibWVhc3VyZVRhcmdldFRleHQiLCJ0YXJnZXRUZXh0IiwiX21lYXN1cmUiLCJfY3R4JG1lYXN1cmVUZXh0IiwicGFyZW50QXR0ciIsIl9jcmVhdGVTdXBlciREIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCREIiwiVFNwYW5FbGVtZW50IiwiX1RleHRFbGVtZW50IiwiX2NyZWF0ZVN1cGVyJEMiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEMiLCJUZXh0Tm9kZSIsIl9UU3BhbkVsZW1lbnQiLCJfY3JlYXRlU3VwZXIkQiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkQiIsIlNWR0VsZW1lbnQiLCJyb290IiwiX3RoaXMkbm9kZSRwYXJlbnROb2RlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJmb250U2l6ZVByb3AiLCJfc2NyZWVuJHZpZXdQb3J0IiwicmVmWEF0dHIiLCJyZWZZQXR0ciIsInZpZXdCb3hBdHRyIiwicmVzaXplIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsIndpZHRoQXR0ciIsImhlaWdodEF0dHIiLCJzdHlsZUF0dHIiLCJvcmlnaW5XaWR0aCIsIm9yaWdpbkhlaWdodCIsInByZXNlcnZlQXNwZWN0UmF0aW9BdHRyIiwiX2NyZWF0ZVN1cGVyJEEiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEEiLCJSZWN0RWxlbWVudCIsInJ4QXR0ciIsInJ5QXR0ciIsInJ4IiwicnkiLCJLQVBQQSIsIl9jcmVhdGVTdXBlciR6IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR6IiwiQ2lyY2xlRWxlbWVudCIsIl9jcmVhdGVTdXBlciR5IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR5IiwiRWxsaXBzZUVsZW1lbnQiLCJfY3JlYXRlU3VwZXIkeCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkeCIsIkxpbmVFbGVtZW50IiwiZ2V0UG9pbnRzIiwiX3RoaXMkZ2V0UG9pbnRzIiwiX3RoaXMkZ2V0UG9pbnRzMiIsIl90aGlzJGdldFBvaW50czIkIiwieDAiLCJ5MCIsIl90aGlzJGdldFBvaW50czIkMiIsIl90aGlzJGdldFBvaW50czMiLCJfdGhpcyRnZXRQb2ludHM0IiwiX2NyZWF0ZVN1cGVyJHciLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHciLCJQb2x5bGluZUVsZW1lbnQiLCJfcG9pbnRzIiwiX3BvaW50cyQiLCJfY3JlYXRlU3VwZXIkdiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdiIsIlBvbHlnb25FbGVtZW50IiwiX1BvbHlsaW5lRWxlbWVudCIsIl90aGlzJHBvaW50cyIsIl90aGlzJHBvaW50cyQiLCJfY3JlYXRlU3VwZXIkdSIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdSIsIlBhdHRlcm5FbGVtZW50IiwicGFyZW50T3BhY2l0eVByb3AiLCJwYXR0ZXJuU3ZnIiwicGF0dGVybkNhbnZhcyIsInBhdHRlcm5DdHgiLCJnZXRDb250ZXh0IiwicGF0dGVybiIsIl9jcmVhdGVTdXBlciR0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR0IiwiTWFya2VyRWxlbWVudCIsIm9yaWVudCIsIm1hcmtlclVuaXRzIiwibWFya2VyU3ZnIiwib3ZlcmZsb3ciLCJfY3JlYXRlU3VwZXIkcyIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcyIsIkRlZnNFbGVtZW50IiwiX2NyZWF0ZVN1cGVyJHIiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHIiLCJHRWxlbWVudCIsIl9jcmVhdGVTdXBlciRxIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRxIiwiR3JhZGllbnRFbGVtZW50IiwiYXR0cmlidXRlc1RvSW5oZXJpdCIsInN0b3BzIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplIiwiZ2V0R3JhZGllbnRVbml0cyIsInN0b3BzQ29udGFpbmVyIiwiaW5oZXJpdFN0b3BDb250YWluZXIiLCJfc3RvcHNDb250YWluZXIiLCJncmFkaWVudCIsImdldEdyYWRpZW50IiwiYWRkUGFyZW50T3BhY2l0eSIsImFkZENvbG9yU3RvcCIsIl9kb2N1bWVudCRzY3JlZW4iLCJfdmlld1BvcnQkdmlld1BvcnRzIiwicm9vdFZpZXciLCJyZWN0IiwiZ3JvdXAiLCJhdHRyaWJ1dGVUb0luaGVyaXQiLCJjb2xvclByb3AiLCJfY3JlYXRlU3VwZXIkcCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcCIsIkxpbmVhckdyYWRpZW50RWxlbWVudCIsIl9HcmFkaWVudEVsZW1lbnQiLCJpc0JvdW5kaW5nQm94VW5pdHMiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsIl9jcmVhdGVTdXBlciRvIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRvIiwiUmFkaWFsR3JhZGllbnRFbGVtZW50IiwiZngiLCJmeSIsImZyIiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJfY3JlYXRlU3VwZXIkbiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbiIsIlN0b3BFbGVtZW50Iiwic3RvcE9wYWNpdHkiLCJzdG9wQ29sb3IiLCJfY3JlYXRlU3VwZXIkbSIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbSIsIkFuaW1hdGVFbGVtZW50IiwiZHVyYXRpb24iLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsVW5pdHMiLCJyZW1vdmVkIiwiZnJvemVuIiwiYmVnaW4iLCJtYXhEdXJhdGlvbiIsInRvIiwidmFsdWVzIiwidmFsdWVzQXR0ciIsImdldFByb3BlcnR5IiwiYXR0cmlidXRlVHlwZSIsImF0dHJpYnV0ZU5hbWUiLCJjYWxjVmFsdWUiLCJfdGhpcyRnZXRQcm9ncmVzcyIsImdldFByb2dyZXNzIiwicHJvZ3Jlc3MiLCJuZXdWYWx1ZSIsInByb3AiLCJ1cGRhdGVkIiwidHlwZUF0dHIiLCJwIiwibGIiLCJmbG9vciIsInViIiwiY2VpbCIsIl9jcmVhdGVTdXBlciRsIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsIiwiQW5pbWF0ZUNvbG9yRWxlbWVudCIsIl9BbmltYXRlRWxlbWVudCIsImNvbG9yRnJvbSIsImNvbG9yVG8iLCJfY3JlYXRlU3VwZXIkayIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkayIsIkFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50IiwidHJhbnNmb3JtRnJvbSIsInRyYW5zZm9ybVRvIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMSIsIm8iLCJhbGxvd0FycmF5TGlrZSIsIml0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJpc0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEiLCJGIiwiZG9uZSIsIl9lIiwiVHlwZUVycm9yIiwibm9ybWFsQ29tcGxldGlvbiIsImRpZEVyciIsInN0ZXAiLCJfZTIiLCJyZXR1cm4iLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSQxIiwic2xpY2UiLCJhcnIiLCJhcnIyIiwiX2NyZWF0ZVN1cGVyJGoiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGoiLCJGb250RWxlbWVudCIsIl9pdGVyYXRvciIsIl9zdGVwIiwiZm9udEZhbWlseVN0eWxlIiwiX2NyZWF0ZVN1cGVyJGkiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGkiLCJGb250RmFjZUVsZW1lbnQiLCJhc2NlbnQiLCJkZXNjZW50IiwiX2NyZWF0ZVN1cGVyJGgiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGgiLCJNaXNzaW5nR2x5cGhFbGVtZW50IiwiX2NyZWF0ZVN1cGVyJGciLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGciLCJUUmVmRWxlbWVudCIsImZpcnN0Q2hpbGQiLCJfY3JlYXRlU3VwZXIkZiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZiIsIkFFbGVtZW50IiwiaGFzVGV4dCIsIm9wZW4iLCJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9hcnJheUxpa2VUb0FycmF5Iiwib3duS2V5cyQyIiwib2JqZWN0IiwiZW51bWVyYWJsZU9ubHkiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic3ltYm9scyIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJfb2JqZWN0U3ByZWFkJDIiLCJ0YXJnZXQiLCJzb3VyY2UiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9jcmVhdGVTdXBlciRlIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRlIiwiVGV4dFBhdGhFbGVtZW50IiwidGV4dFdpZHRoIiwidGV4dEhlaWdodCIsInBhdGhMZW5ndGgiLCJnbHlwaEluZm8iLCJsZXR0ZXJTcGFjaW5nQ2FjaGUiLCJtZWFzdXJlc0NhY2hlIiwiTWFwIiwicGF0aEVsZW1lbnQiLCJkYXRhQXJyYXkiLCJwYXJzZVBhdGhEYXRhIiwidGhldGEiLCJkVGhldGEiLCJwc2kiLCJmcyIsInNldFRleHREYXRhIiwidGV4dERlY29yYXRpb24iLCJyb3RhdGlvbiIsInBhcnRpYWxUZXh0IiwiZ2V0TGV0dGVyU3BhY2luZ0F0IiwiaWR4IiwiZmluZFNlZ21lbnRUb0ZpdENoYXIiLCJhbmNob3IiLCJ0ZXh0RnVsbFdpZHRoIiwiZnVsbFBhdGhXaWR0aCIsInNwYWNlc051bWJlciIsImlucHV0T2Zmc2V0IiwiZHkiLCJjaGFySSIsImdseXBoV2lkdGgiLCJzcGxpbmVTdGVwIiwiZ2V0RXF1aWRpc3RhbnRQb2ludE9uUGF0aCIsInNlZ21lbnQiLCJkeVgiLCJkeVkiLCJoYXMiLCJjaGFycyIsInRoaXNTcGFjaW5nIiwicGFyZW50U3BhY2luZyIsImxldHRlclNwYWNpbmciLCJ0ZXh0TGVuIiwiZHhTdW0iLCJhY2MiLCJjdXIiLCJnZXRQYXRoTGVuZ3RoIiwic3RhcnRPZmZzZXQiLCJfdGhpczIkZmluZFNlZ21lbnRUb0YiLCJuZXh0T2Zmc2V0IiwicGF0aENvbW1hbmRzIiwic3RhcnRYIiwic3RhcnRZIiwibmV4dENvbW1hbmRUeXBlIiwiY2FsY0xlbmd0aCIsIl9QYXRoRWxlbWVudCRwYXRoTSRwbyIsIl9QYXRoRWxlbWVudCRwYXRoTCRwbyIsIl9QYXRoRWxlbWVudCRwYXRoSCRwbyIsIl9QYXRoRWxlbWVudCRwYXRoViRwbyIsImNvbW1hbmRUeXBlIiwiZ2V0TGluZUxlbmd0aCIsImdldFBvaW50T25DdWJpY0JlemllciIsImdldFBvaW50T25RdWFkcmF0aWNCZXppZXIiLCJlbmQiLCJpbmMiLCJhYnMiLCJnZXRQb2ludE9uRWxsaXB0aWNhbEFyYyIsImdldFBvaW50T25MaW5lIiwiZGlzdCIsImZyb21YIiwiZnJvbVkiLCJtIiwicmlzZSIsInB0IiwiaXgiLCJpeSIsInBSaXNlIiwicFJ1biIsImdldFBvaW50T25QYXRoIiwiZGlzdGFuY2UiLCJmdWxsTGVuIiwiY3VtdWxhdGl2ZVBhdGhMZW5ndGgiLCJjdXJyZW50VCIsInBjdCIsInA0eCIsInA0eSIsImNvc1BzaSIsInNpblBzaSIsImJ1aWxkRXF1aWRpc3RhbnRDYWNoZSIsImlucHV0U3RlcCIsImlucHV0UHJlY2lzaW9uIiwicHJlY2lzaW9uIiwiZXF1aWRpc3RhbnRDYWNoZSIsInRhcmdldERpc3RhbmNlIiwiX2NyZWF0ZVN1cGVyJGQiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGQiLCJkYXRhVXJpUmVnZXgiLCJJbWFnZUVsZW1lbnQiLCJsb2FkZWQiLCJocmVmIiwiaXNTdmciLCJpbWFnZXMiLCJsb2FkU3ZnIiwiX2xvYWRJbWFnZSIsImltYWdlIiwidDAiLCJjb25zb2xlIiwiZXJyb3IiLCJfbG9hZFN2ZyIsInN2ZyIsImF0b2IiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzdWJEb2N1bWVudCIsImNhbnZnIiwiZm9ya1N0cmluZyIsImRvY3VtZW50RWxlbWVudCIsIl9pbWFnZSIsImNvbXBsZXRlIiwiZHJhd0ltYWdlIiwiX2NyZWF0ZVN1cGVyJGMiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGMiLCJTeW1ib2xFbGVtZW50IiwiU1ZHRm9udExvYWRlciIsImZvbnRzIiwic3ZnRG9jdW1lbnQiLCJmb250Tm9kZSIsIl9jcmVhdGVTdXBlciRiIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRiIiwiU3R5bGVFbGVtZW50IiwiY3NzIiwiY3NzRGVmcyIsImNzc1BhcnRzIiwiY3NzQ2xhc3NlcyIsImNzc1Byb3BzIiwiY3NzQ2xhc3MiLCJwcm9wcyIsImNzc1Byb3AiLCJzdWJzdHIiLCJzcmNzIiwic3JjIiwiX2NyZWF0ZVN1cGVyJGEiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGEiLCJVc2VFbGVtZW50IiwidGVtcFN2ZyIsIm9sZFBhcmVudCIsImVsZW1lbnRUcmFuc2Zvcm0iLCJjYWNoZWRFbGVtZW50IiwiX2NyZWF0ZVN1cGVyJDkiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDkiLCJpbUdldCIsIl9oZWlnaHQiLCJyZ2JhIiwiaW1TZXQiLCJ2YWwiLCJtaSIsIm0xIiwibTIiLCJtMyIsIkZlQ29sb3JNYXRyaXhFbGVtZW50IiwiaW5jbHVkZU9wYWNpdHkiLCJfeSIsInNyY0RhdGEiLCJnZXRJbWFnZURhdGEiLCJuciIsIm5nIiwibmIiLCJuYSIsInB1dEltYWdlRGF0YSIsIl9jcmVhdGVTdXBlciQ4IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ4IiwiTWFza0VsZW1lbnQiLCJpZ25vcmVkU3R5bGVzIiwibWFza0NhbnZhcyIsIm1hc2tDdHgiLCJ0bXBDYW52YXMiLCJ0bXBDdHgiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJmaWxsUmVjdCIsIl9jcmVhdGVTdXBlciQ3IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ3Iiwibm9vcCIsIkNsaXBQYXRoRWxlbWVudCIsImNvbnRleHRQcm90byIsImdldFByb3RvdHlwZU9mIiwiX2NyZWF0ZVN1cGVyJDYiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDYiLCJGaWx0ZXJFbGVtZW50IiwicHgiLCJweSIsImVmZCIsImV4dHJhRmlsdGVyRGlzdGFuY2UiLCJ0bXBDYW52YXNXaWR0aCIsInRtcENhbnZhc0hlaWdodCIsIl9jcmVhdGVTdXBlciQ1IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ1IiwiRmVEcm9wU2hhZG93RWxlbWVudCIsIl93aWR0aCIsIl9jcmVhdGVTdXBlciQ0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ0IiwiRmVNb3JwaG9sb2d5RWxlbWVudCIsIl9jcmVhdGVTdXBlciQzIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQzIiwiRmVDb21wb3NpdGVFbGVtZW50IiwiX2NyZWF0ZVN1cGVyJDIiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDIiLCJGZUdhdXNzaWFuQmx1ckVsZW1lbnQiLCJibHVyUmFkaXVzIiwiYm9keSIsImdldFVuaXF1ZUlkIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwiY2FudmFzUkdCQSIsInJlbW92ZUNoaWxkIiwiX2NyZWF0ZVN1cGVyJDEiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEiLCJUaXRsZUVsZW1lbnQiLCJfY3JlYXRlU3VwZXIiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiRGVzY0VsZW1lbnQiLCJlbGVtZW50cyIsIm93bktleXMkMSIsIl9vYmplY3RTcHJlYWQkMSIsIl9jcmVhdGVJbWFnZSIsImFub255bW91c0Nyb3NzT3JpZ2luIiwiX2FyZ3MiLCJjcm9zc09yaWdpbiIsInJlamVjdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJfZXZlbnQiLCJfc291cmNlIiwiX2xpbmVubyIsIl9jb2xubyIsIkRvY3VtZW50IiwiX3JlZiRyb290RW1TaXplIiwiX3JlZiRlbVNpemUiLCJfcmVmJGNyZWF0ZUNhbnZhcyIsIl9yZWYkY3JlYXRlSW1hZ2UiLCJlbVNpemVTdGFjayIsInVuaXF1ZUlkIiwiYmluZENyZWF0ZUltYWdlIiwiaXNJbWFnZXNMb2FkZWQiLCJpc0ZvbnRzTG9hZGVkIiwiZm9yY2VBbm9ueW1vdXNDcm9zc09yaWdpbiIsImNyZWF0ZURvY3VtZW50RWxlbWVudCIsImVsZW1lbnRUeXBlIiwiRWxlbWVudFR5cGUiLCJlbGVtZW50VHlwZXMiLCJjb25maWciLCJvd25LZXlzIiwiX29iamVjdFNwcmVhZCIsIkNhbnZnIiwib3B0aW9ucyIsImZvcmsiLCJmcm9tU3RyaW5nIiwiX3JlbmRlciIsImJhc2VPcHRpb25zIiwiX2Zyb20iLCJfYXJnczIiLCJwcmVzZXRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvg/lib/index.cjs\n");

/***/ })

};
;