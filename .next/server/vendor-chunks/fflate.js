"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fflate";
exports.ids = ["vendor-chunks/fflate"];
exports.modules = {

/***/ "(ssr)/./node_modules/fflate/lib/node.cjs":
/*!******************************************!*\
  !*** ./node_modules/fflate/lib/node.cjs ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\n// Mediocre shim\nvar Worker;\nvar workerAdd = \";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global\";\ntry {\n    Worker = (__webpack_require__(/*! worker_threads */ \"worker_threads\").Worker);\n} catch (e) {}\nvar node_worker_1 = {};\nnode_worker_1[\"default\"] = Worker ? function(c, _, msg, transfer, cb) {\n    var done = false;\n    var w = new Worker(c + workerAdd, {\n        eval: true\n    }).on(\"error\", function(e) {\n        return cb(e, null);\n    }).on(\"message\", function(m) {\n        return cb(null, m);\n    }).on(\"exit\", function(c) {\n        if (c && !done) cb(new Error(\"exited with code \" + c), null);\n    });\n    w.postMessage(msg, transfer);\n    w.terminate = function() {\n        done = true;\n        return Worker.prototype.terminate.call(w);\n    };\n    return w;\n} : function(_, __, ___, ____, cb) {\n    setImmediate(function() {\n        return cb(new Error(\"async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)\"), null);\n    });\n    var NOP = function() {};\n    return {\n        terminate: NOP,\n        postMessage: NOP\n    };\n};\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */ 0,\n    0,\n    /* impossible */ 0\n]);\n// fixed distance extra bits\nvar fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */ 0,\n    0\n]);\n// code length index map\nvar clim = new u8([\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n]);\n// get base, reverse index map from extra bits\nvar freb = function(eb, start) {\n    var b = new u16(31);\n    for(var i = 0; i < 31; ++i){\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for(var i = 1; i < 30; ++i){\n        for(var j = b[i]; j < b[i + 1]; ++j){\n            r[j] = j - b[i] << 5 | i;\n        }\n    }\n    return {\n        b: b,\n        r: r\n    };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor(var i = 0; i < 32768; ++i){\n    // reverse table algorithm from SO\n    var x = (i & 0xAAAA) >> 1 | (i & 0x5555) << 1;\n    x = (x & 0xCCCC) >> 2 | (x & 0x3333) << 2;\n    x = (x & 0xF0F0) >> 4 | (x & 0x0F0F) << 4;\n    rev[i] = ((x & 0xFF00) >> 8 | (x & 0x00FF) << 8) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = function(cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for(; i < s; ++i){\n        if (cd[i]) ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for(i = 1; i < mb; ++i){\n        le[i] = le[i - 1] + l[i - 1] << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for(i = 0; i < s; ++i){\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = i << 4 | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for(var m = v | (1 << r_1) - 1; v <= m; ++v){\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    } else {\n        co = new u16(s);\n        for(i = 0; i < s; ++i){\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];\n            }\n        }\n    }\n    return co;\n};\n// fixed length tree\nvar flt = new u8(288);\nfor(var i = 0; i < 144; ++i)flt[i] = 8;\nfor(var i = 144; i < 256; ++i)flt[i] = 9;\nfor(var i = 256; i < 280; ++i)flt[i] = 7;\nfor(var i = 280; i < 288; ++i)flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor(var i = 0; i < 32; ++i)fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function(a) {\n    var m = a[0];\n    for(var i = 1; i < a.length; ++i){\n        if (a[i] > m) m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\n// get end of byte\nvar shft = function(p) {\n    return (p + 7) / 8 | 0;\n};\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function(v, s, e) {\n    if (s == null || s < 0) s = 0;\n    if (e == null || e > v.length) e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */ exports.FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    \"unexpected EOF\",\n    \"invalid block type\",\n    \"invalid length/literal\",\n    \"invalid distance\",\n    \"stream finished\",\n    \"no stream handler\",\n    ,\n    \"no callback\",\n    \"invalid UTF-8 data\",\n    \"extra field too long\",\n    \"date not in range 1980-2099\",\n    \"filename too long\",\n    \"stream finishing\",\n    \"invalid zip data\"\n];\nvar err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace) Error.captureStackTrace(e, err);\n    if (!nt) throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function(dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l) return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf) buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function(l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n                if (t > sl) {\n                    if (noSt) err(0);\n                    break;\n                }\n                // ensure size\n                if (resize) cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for(var i = 0; i < hcLen; ++i){\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for(var i = 0; i < tl;){\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    } else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n                        while(n--)ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            } else err(1);\n            if (pos > tbts) {\n                if (noSt) err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize) cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for(;; lpos = pos){\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt) err(0);\n                break;\n            }\n            if (!c) err(2);\n            if (sym < 256) buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            } else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d) err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt) err(0);\n                    break;\n                }\n                if (resize) cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0) err(3);\n                    for(; bt < dend; ++bt)buf[bt] = dict[shift + bt];\n                }\n                for(; bt < end; ++bt)buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    }while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function(d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for(var i = 0; i < d.length; ++i){\n        if (d[i]) t.push({\n            s: i,\n            f: d[i]\n        });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s) return {\n        t: et,\n        l: 0\n    };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return {\n            t: v,\n            l: 1\n        };\n    }\n    t.sort(function(a, b) {\n        return a.f - b.f;\n    });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({\n        s: -1,\n        f: 25001\n    });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = {\n        s: -1,\n        f: l.f + r.f,\n        l: l,\n        r: r\n    };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while(i1 != s - 1){\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = {\n            s: -1,\n            f: l.f + r.f,\n            l: l,\n            r: r\n        };\n    }\n    var maxSym = t2[0].s;\n    for(var i = 1; i < s; ++i){\n        if (t2[i].s > maxSym) maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function(a, b) {\n            return tr[b.s] - tr[a.s] || a.f - b.f;\n        });\n        for(; i < s; ++i){\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << mbt - tr[i2_1]);\n                tr[i2_1] = mb;\n            } else break;\n        }\n        dt >>= lft;\n        while(dt > 0){\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;\n            else ++i;\n        }\n        for(; i >= 0 && dt; --i){\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return {\n        t: new u8(tr),\n        l: mbt\n    };\n};\n// get the max length and assign length codes\nvar ln = function(n, l, d) {\n    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;\n};\n// length codes generation\nvar lc = function(c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while(s && !c[--s]);\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function(v) {\n        cl[cli++] = v;\n    };\n    for(var i = 1; i <= s; ++i){\n        if (c[i] == cln && i != s) ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for(; cls > 138; cls -= 138)w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n                    cls = 0;\n                }\n            } else if (cls > 3) {\n                w(cln), --cls;\n                for(; cls > 6; cls -= 6)w(8304);\n                if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n            }\n            while(cls--)w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return {\n        c: cl.subarray(0, cli),\n        n: s\n    };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function(cf, cl) {\n    var l = 0;\n    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function(out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for(var i = 0; i < lclt.length; ++i)++lcfreq[lclt[i] & 31];\n    for(var i = 0; i < lcdt.length; ++i)++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n    var flen = bl + 5 << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [\n            lclt,\n            lcdt\n        ];\n        for(var it = 0; it < 2; ++it){\n            var clct = lcts[it];\n            for(var i = 0; i < clct.length; ++i){\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15) wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;\n            }\n        }\n    } else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for(var i = 0; i < li; ++i){\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = sym >> 18 & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7) wbits(out, p, sym >> 23 & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3) wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];\n        } else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([\n    65540,\n    131080,\n    131088,\n    131104,\n    262176,\n    1048704,\n    1048832,\n    2114560,\n    2117632\n]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function(dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos) w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function(i) {\n            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;\n        };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for(; i + 2 < s; ++i){\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for(var j = 0; j < 286; ++j)lf[j] = 0;\n                    for(var j = 0; j < 30; ++j)df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while(dif <= maxd && --ch_1 && imod != pimod){\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn) break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for(var j = 0; j < mmd; ++j){\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md) md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                } else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for(i = Math.max(i, wi); i < s; ++i){\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = pos & 7 | w[pos / 8 | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    } else {\n        for(var i = st.w || 0; i < s + lst; i += 65535){\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[pos / 8 | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ function() {\n    var t = new Int32Array(256);\n    for(var i = 0; i < 256; ++i){\n        var c = i, k = 9;\n        while(--k)c = (c & 1 && -306674912) ^ c >>> 1;\n        t[i] = c;\n    }\n    return t;\n}();\n// CRC32\nvar crc = function() {\n    var c = -1;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var cr = c;\n            for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;\n            c = cr;\n        },\n        d: function() {\n            return ~c;\n        }\n    };\n};\n// Adler32\nvar adler = function() {\n    var a = 1, b = 0;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for(var i = 0; i != l;){\n                var e = Math.min(i + 2655, l);\n                for(; i < e; ++i)m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function() {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | b >> 8;\n        }\n    };\n};\n// deflate with opts\nvar dopt = function(dat, opt, pre, post, st) {\n    if (!st) {\n        st = {\n            l: 1\n        };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);\n};\n// Walmart object spread\nvar mrg = function(a, b) {\n    var o = {};\n    for(var k in a)o[k] = a[k];\n    for(var k in b)o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function(fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/\\s+/g, \"\").split(\",\");\n    for(var i = 0; i < dt.length; ++i){\n        var v = dt[i], k = ks[i];\n        if (typeof v == \"function\") {\n            fnStr += \";\" + k + \"=\";\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf(\"[native code]\") != -1) {\n                    var spInd = st_1.indexOf(\" \", 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\n                } else {\n                    fnStr += st_1;\n                    for(var t in v.prototype)fnStr += \";\" + k + \".prototype.\" + t + \"=\" + v.prototype[t].toString();\n                }\n            } else fnStr += st_1;\n        } else td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function(v) {\n    var tl = [];\n    for(var k in v){\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function(fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = \"\", td_1 = {}, m = fns.length - 1;\n        for(var i = 0; i < m; ++i)fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = {\n            c: wcln(fns[m], fnStr, td_1),\n            e: td_1\n        };\n    }\n    var td = mrg({}, ch[id].e);\n    return (0, node_worker_1.default)(ch[id].c + \";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function() {\n    return [\n        u8,\n        u16,\n        i32,\n        fleb,\n        fdeb,\n        clim,\n        fl,\n        fd,\n        flrm,\n        fdrm,\n        rev,\n        ec,\n        hMap,\n        max,\n        bits,\n        bits16,\n        shft,\n        slc,\n        err,\n        inflt,\n        inflateSync,\n        pbf,\n        gopt\n    ];\n};\nvar bDflt = function() {\n    return [\n        u8,\n        u16,\n        i32,\n        fleb,\n        fdeb,\n        clim,\n        revfl,\n        revfd,\n        flm,\n        flt,\n        fdm,\n        fdt,\n        rev,\n        deo,\n        et,\n        hMap,\n        wbits,\n        wbits16,\n        hTree,\n        ln,\n        lc,\n        clen,\n        wfblk,\n        wblk,\n        shft,\n        slc,\n        dflt,\n        dopt,\n        deflateSync,\n        pbf\n    ];\n};\n// gzip extra\nvar gze = function() {\n    return [\n        gzh,\n        gzhl,\n        wbytes,\n        crc,\n        crct\n    ];\n};\n// gunzip extra\nvar guze = function() {\n    return [\n        gzs,\n        gzl\n    ];\n};\n// zlib extra\nvar zle = function() {\n    return [\n        zlh,\n        wbytes,\n        adler\n    ];\n};\n// unzlib extra\nvar zule = function() {\n    return [\n        zls\n    ];\n};\n// post buf\nvar pbf = function(msg) {\n    return postMessage(msg, [\n        msg.buffer\n    ]);\n};\n// get opts\nvar gopt = function(o) {\n    return o && {\n        out: o.size && new u8(o.size),\n        dictionary: o.dictionary\n    };\n};\n// async helper\nvar cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([\n        dat,\n        opts\n    ], opts.consume ? [\n        dat.buffer\n    ] : []);\n    return function() {\n        w.terminate();\n    };\n};\n// auto stream\nvar astrm = function(strm) {\n    strm.ondata = function(dat, final) {\n        return postMessage([\n            dat,\n            final\n        ], [\n            dat.buffer\n        ]);\n    };\n    return function(ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([\n                ev.data[0].length\n            ]);\n        } else strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function(fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function(err, dat) {\n        if (err) w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat)) ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain) strm.ondrain(dat[0]);\n        } else {\n            if (dat[1]) w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function(d, f) {\n        if (!strm.ondata) err(5);\n        if (t) strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([\n            d,\n            t = f\n        ], [\n            d.buffer\n        ]);\n    };\n    strm.terminate = function() {\n        w.terminate();\n    };\n    if (flush) {\n        strm.flush = function() {\n            w.postMessage([]);\n        };\n    }\n};\n// read 2 bytes\nvar b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n};\n// read 4 bytes\nvar b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n};\n// write bytes\nvar wbytes = function(d, b, v) {\n    for(; v; ++b)d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function(c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8) err(6, \"invalid gzip data\");\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4) st += (d[10] | d[11] << 8) + 2;\n    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function(d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function(o) {\n    return 10 + (o.filename ? o.filename.length + 1 : 0);\n};\n// zlib header\nvar zlh = function(c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = fl << 6 | (o.dictionary && 32);\n    c[1] |= 31 - (c[0] << 8 | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function(d, dict) {\n    if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31) err(6, \"invalid zlib data\");\n    if ((d[1] >> 5 & 1) == +!dict) err(6, \"invalid zlib data: \" + (d[1] & 32 ? \"need\" : \"unexpected\") + \" dictionary\");\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == \"function\") cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */ var Deflate = /*#__PURE__*/ function() {\n    function Deflate(opts, cb) {\n        if (typeof opts == \"function\") cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = {\n            l: 0,\n            i: 32768,\n            w: 32768,\n            z: 32768\n        };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function(c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Deflate.prototype.push = function(chunk, final) {\n        if (!this.ondata) err(5);\n        if (this.s.l) err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        } else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */ Deflate.prototype.flush = function() {\n        if (!this.ondata) err(5);\n        if (this.s.l) err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}();\nexports.Deflate = Deflate;\n/**\n * Asynchronous streaming DEFLATE compression\n */ var AsyncDeflate = /*#__PURE__*/ function() {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function() {\n                return [\n                    astrm,\n                    Deflate\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}();\nexports.AsyncDeflate = AsyncDeflate;\nfunction deflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bDflt\n    ], function(ev) {\n        return pbf(deflateSync(ev.data[0], ev.data[1]));\n    }, 0, cb);\n}\nexports.deflate = deflate;\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */ function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\nexports.deflateSync = deflateSync;\n/**\n * Streaming DEFLATE decompression\n */ var Inflate = /*#__PURE__*/ function() {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == \"function\") cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = {\n            i: 0,\n            b: dict ? dict.length : 0\n        };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict) this.o.set(dict);\n    }\n    Inflate.prototype.e = function(c) {\n        if (!this.ondata) err(5);\n        if (this.d) err(4);\n        if (!this.p.length) this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function(final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */ Inflate.prototype.push = function(chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}();\nexports.Inflate = Inflate;\n/**\n * Asynchronous streaming DEFLATE decompression\n */ var AsyncInflate = /*#__PURE__*/ function() {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function() {\n                return [\n                    astrm,\n                    Inflate\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}();\nexports.AsyncInflate = AsyncInflate;\nfunction inflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function(ev) {\n        return pbf(inflateSync(ev.data[0], gopt(ev.data[1])));\n    }, 1, cb);\n}\nexports.inflate = inflate;\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */ function inflateSync(data, opts) {\n    return inflt(data, {\n        i: 2\n    }, opts && opts.out, opts && opts.dictionary);\n}\nexports.inflateSync = inflateSync;\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */ var Gzip = /*#__PURE__*/ function() {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gzip.prototype.push = function(chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function(c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v) gzh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */ Gzip.prototype.flush = function() {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}();\nexports.Gzip = Gzip;\nexports.Compress = Gzip;\n/**\n * Asynchronous streaming GZIP compression\n */ var AsyncGzip = /*#__PURE__*/ function() {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Gzip\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}();\nexports.AsyncGzip = AsyncGzip;\nexports.AsyncCompress = AsyncGzip;\nfunction gzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function() {\n            return [\n                gzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gzipSync(ev.data[0], ev.data[1]));\n    }, 2, cb);\n}\nexports.gzip = gzip;\nexports.compress = gzip;\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */ function gzipSync(data, opts) {\n    if (!opts) opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\nexports.gzipSync = gzipSync;\nexports.compressSync = gzipSync;\n/**\n * Streaming single or multi-member GZIP decompression\n */ var Gunzip = /*#__PURE__*/ function() {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gunzip.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final) return;\n            } else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = {\n                i: 0\n            };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}();\nexports.Gunzip = Gunzip;\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */ var AsyncGunzip = /*#__PURE__*/ function() {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Gunzip\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function(offset) {\n                return postMessage(offset);\n            };\n            onmessage = astrm(strm);\n        }, 9, 0, function(offset) {\n            return _this.onmember && _this.onmember(offset);\n        });\n    }\n    return AsyncGunzip;\n}();\nexports.AsyncGunzip = AsyncGunzip;\nfunction gunzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function() {\n            return [\n                gunzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gunzipSync(ev.data[0], ev.data[1]));\n    }, 3, cb);\n}\nexports.gunzip = gunzip;\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */ function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length) err(6, \"invalid gzip data\");\n    return inflt(data.subarray(st, -8), {\n        i: 2\n    }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\nexports.gunzipSync = gunzipSync;\n/**\n * Streaming Zlib compression\n */ var Zlib = /*#__PURE__*/ function() {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Zlib.prototype.push = function(chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function(c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v) zlh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */ Zlib.prototype.flush = function() {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}();\nexports.Zlib = Zlib;\n/**\n * Asynchronous streaming Zlib compression\n */ var AsyncZlib = /*#__PURE__*/ function() {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Zlib\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}();\nexports.AsyncZlib = AsyncZlib;\nfunction zlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function() {\n            return [\n                zlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(zlibSync(ev.data[0], ev.data[1]));\n    }, 4, cb);\n}\nexports.zlib = zlib;\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */ function zlibSync(data, opts) {\n    if (!opts) opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\nexports.zlibSync = zlibSync;\n/**\n * Streaming Zlib decompression\n */ var Unzlib = /*#__PURE__*/ function() {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzlib.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final) return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4) err(6, \"invalid zlib data\");\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}();\nexports.Unzlib = Unzlib;\n/**\n * Asynchronous streaming Zlib decompression\n */ var AsyncUnzlib = /*#__PURE__*/ function() {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Unzlib\n                ];\n            }\n        ], this, StrmOpt.call(this, opts, cb), function(ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}();\nexports.AsyncUnzlib = AsyncUnzlib;\nfunction unzlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function() {\n            return [\n                unzlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(unzlibSync(ev.data[0], gopt(ev.data[1])));\n    }, 5, cb);\n}\nexports.unzlib = unzlib;\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */ function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), {\n        i: 2\n    }, opts && opts.out, opts && opts.dictionary);\n}\nexports.unzlibSync = unzlibSync;\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var Decompress = /*#__PURE__*/ function() {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function() {\n        var _this = this;\n        this.s.ondata = function(dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Decompress.prototype.push = function(chunk, final) {\n        if (!this.ondata) err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            } else this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        } else this.s.push(chunk, final);\n    };\n    return Decompress;\n}();\nexports.Decompress = Decompress;\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var AsyncDecompress = /*#__PURE__*/ function() {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function() {\n        var _this = this;\n        this.s.ondata = function(err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function(size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain) _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncDecompress.prototype.push = function(chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}();\nexports.AsyncDecompress = AsyncDecompress;\nfunction decompress(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);\n}\nexports.decompress = decompress;\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */ function decompressSync(data, opts) {\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);\n}\nexports.decompressSync = decompressSync;\n// flatten a directory structure\nvar fltn = function(d, p, t, o) {\n    for(var k in d){\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val)) op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8) t[n] = [\n            val,\n            op\n        ];\n        else {\n            t[n += \"/\"] = [\n                new u8(0),\n                op\n            ];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != \"undefined\" && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != \"undefined\" && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, {\n        stream: true\n    });\n    tds = 1;\n} catch (e) {}\n// decode UTF8\nvar dutf8 = function(d) {\n    for(var r = \"\", i = 0;;){\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length) return {\n            s: r,\n            r: slc(d, i - 1)\n        };\n        if (!eb) r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n        } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */ var DecodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */ function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds) this.t = new TextDecoder();\n        else this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ DecodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, {\n                stream: true\n            }), final);\n            if (final) {\n                if (this.t.decode().length) err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p) err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length) err(8);\n            this.p = null;\n        } else this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}();\nexports.DecodeUTF8 = DecodeUTF8;\n/**\n * Streaming UTF-8 encoding\n */ var EncodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */ function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */ EncodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) err(5);\n        if (this.d) err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}();\nexports.EncodeUTF8 = EncodeUTF8;\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */ function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te) return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function(v) {\n        ar[ai++] = v;\n    };\n    for(var i = 0; i < l; ++i){\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + (l - i << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1) w(c);\n        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);\n        else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);\n        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);\n    }\n    return slc(ar, 0, ai);\n}\nexports.strToU8 = strToU8;\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */ function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = \"\";\n        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    } else if (td) {\n        return td.decode(dat);\n    } else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length) err(8);\n        return s;\n    }\n}\nexports.strFromU8 = strFromU8;\n// deflate bit flag\nvar dbf = function(l) {\n    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;\n};\n// skip local zip header\nvar slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n};\n// read zip header\nvar zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [\n        bs,\n        b4(d, b + 24),\n        b4(d, b + 42)\n    ], sc = _a[0], su = _a[1], off = _a[2];\n    return [\n        b2(d, b + 10),\n        sc,\n        su,\n        fn,\n        es + b2(d, b + 30) + b2(d, b + 32),\n        off\n    ];\n};\n// read zip64 extra field\nvar z64e = function(d, b) {\n    for(; b2(d, b) != 1; b += 4 + b2(d, b + 2));\n    return [\n        b8(d, b + 12),\n        b8(d, b + 4),\n        b8(d, b + 20)\n    ];\n};\n// extra field length\nvar exfl = function(ex) {\n    var le = 0;\n    if (ex) {\n        for(var k in ex){\n            var l = ex[k].length;\n            if (l > 65535) err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function(d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null) d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119) err(10);\n    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for(var k in ex){\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col) d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function(o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */ var ZipPassThrough = /*#__PURE__*/ function() {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */ function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.process = function(chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.push = function(chunk, final) {\n        if (!this.ondata) err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final) this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}();\nexports.ZipPassThrough = ZipPassThrough;\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */ var ZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function(dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function(chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        } catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}();\nexports.ZipDeflate = ZipDeflate;\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */ var AsyncZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function(err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function(chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}();\nexports.AsyncZipDeflate = AsyncZipDeflate;\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */ var Zip = /*#__PURE__*/ function() {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */ function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */ Zip.prototype.add = function(file) {\n        var _this = this;\n        if (!this.ondata) err(5);\n        // finishing or finished\n        if (this.d & 2) this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || o && com.length != o.length;\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535) this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [\n                header\n            ];\n            var pAll_1 = function() {\n                for(var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++){\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function() {\n                    if (file.terminate) file.terminate();\n                },\n                r: function() {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt) nxt.r();\n                        else _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function(err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                } else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1) uf_1.r();\n                        tr_1 = 1;\n                    } else if (tr_1) pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */ Zip.prototype.end = function() {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d) this.e();\n        else this.u.push({\n            r: function() {\n                if (!(_this.d & 1)) return;\n                _this.u.splice(-1, 1);\n                _this.e();\n            },\n            t: function() {}\n        });\n        this.d = 3;\n    };\n    Zip.prototype.e = function() {\n        var bt = 0, l = 0, tl = 0;\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for(var _b = 0, _c = this.u; _b < _c.length; _b++){\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */ Zip.prototype.terminate = function() {\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}();\nexports.Zip = Zip;\nfunction zip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    var r = {};\n    fltn(data, \"\", r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var cbd = function(a, b) {\n        mt(function() {\n            cb(a, b);\n        });\n    };\n    mt(function() {\n        cbd = cb;\n    });\n    var cbf = function() {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for(var i = 0; i < slft; ++i){\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            } catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft) cbf();\n    var _loop_1 = function(i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            } else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || m && com.length != ms,\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft) cbf();\n            }\n        };\n        if (s > 65535) cbl(err(11, 0, 1), null);\n        if (!compression) cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            } catch (e) {\n                cbl(e, null);\n            }\n        } else term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for(var i = 0; i < slft; ++i){\n        _loop_1(i);\n    }\n    return tAll;\n}\nexports.zip = zip;\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */ function zipSync(data, opts) {\n    if (!opts) opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, \"\", r, opts);\n    var o = 0;\n    var tot = 0;\n    for(var fn in r){\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535) err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || m && com.length != ms,\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for(var i = 0; i < files.length; ++i){\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\nexports.zipSync = zipSync;\n/**\n * Streaming pass-through decompression for ZIP archives\n */ var UnzipPassThrough = /*#__PURE__*/ function() {\n    function UnzipPassThrough() {}\n    UnzipPassThrough.prototype.push = function(data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}();\nexports.UnzipPassThrough = UnzipPassThrough;\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */ var UnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function(dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function(data, final) {\n        try {\n            this.i.push(data, final);\n        } catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}();\nexports.UnzipInflate = UnzipInflate;\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */ var AsyncUnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function(dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        } else {\n            this.i = new AsyncInflate(function(err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function(data, final) {\n        if (this.i.terminate) data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}();\nexports.AsyncUnzipInflate = AsyncUnzipInflate;\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */ var Unzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */ function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzip.prototype.push = function(chunk, final) {\n        var _this = this;\n        if (!this.onfile) err(5);\n        if (!this.p) err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d) this.d.push(toAdd, !this.c);\n            else this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length) return this.push(chunk, final);\n        } else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length) buf = chunk;\n            else if (!chunk.length) buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function() {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [\n                                -2\n                            ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        } else if (dd) sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function() {\n                                if (!file_1.ondata) err(5);\n                                if (!sc_1) file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr) file_1.ondata(err(14, \"unknown compression type \" + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function(err, dat, final) {\n                                        file_1.ondata(err, dat, final);\n                                    };\n                                    for(var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++){\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c) _this.d = d_1;\n                                    else d_1.push(et, true);\n                                }\n                            },\n                            terminate: function() {\n                                if (d_1 && d_1.terminate) d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                } else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    } else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for(; i < l - 4; ++i){\n                var state_1 = _loop_2();\n                if (state_1 === \"break\") break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add) add.push(dat, !!f);\n                else this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2) return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c) err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */ Unzip.prototype.register = function(decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}();\nexports.Unzip = Unzip;\nvar mt = typeof queueMicrotask == \"function\" ? queueMicrotask : typeof setTimeout == \"function\" ? setTimeout : function(fn) {\n    fn();\n};\nfunction unzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") err(7);\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var files = {};\n    var cbd = function(a, b) {\n        mt(function() {\n            cb(a, b);\n        });\n    };\n    mt(function() {\n        cbd = cb;\n    });\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function(i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function(e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                } else {\n                    if (d) files[fn] = d;\n                    if (!--lft) cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1) cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, {\n                                out: new u8(su)\n                            }));\n                        } catch (e) {\n                            cbl(e, null);\n                        }\n                    } else term.push(inflate(infl, {\n                        size: su\n                    }, cbl));\n                } else cbl(err(14, \"unknown compression type \" + c_1, 1), null);\n            } else cbl(null, null);\n        };\n        for(var i = 0; i < c; ++i){\n            _loop_3(i);\n        }\n    } else cbd(null, {});\n    return tAll;\n}\nexports.unzip = unzip;\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */ function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c) return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for(var i = 0; i < c; ++i){\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2) files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), {\n                out: new u8(su)\n            });\n            else err(14, \"unknown compression type \" + c_2);\n        }\n    }\n    return files;\n}\nexports.unzipSync = unzipSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmZsYXRlL2xpYi9ub2RlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDJGQUEyRjtBQUMzRixzQ0FBc0M7QUFDdEMsMkVBQTJFO0FBQzNFLHFFQUFxRTtBQUNyRSw0REFBNEQ7QUFDNUQsc0NBQXNDO0FBQ3RDLHVIQUF1SDtBQUN2SCwyRkFBMkY7QUFDM0Ysb0RBQW9EO0FBQ3BELGdCQUFnQjtBQUNoQixJQUFJQTtBQUNKLElBQUlDLFlBQVk7QUFDaEIsSUFBSTtJQUNBRCxTQUFTRSxvRUFBZ0M7QUFDN0MsRUFDQSxPQUFPQyxHQUFHLENBQ1Y7QUFDQSxJQUFJQyxnQkFBZ0IsQ0FBQztBQUNyQkEsYUFBYSxDQUFDLFVBQVUsR0FBR0osU0FBUyxTQUFVSyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLEVBQUU7SUFDakUsSUFBSUMsT0FBTztJQUNYLElBQUlDLElBQUksSUFBSVgsT0FBT0ssSUFBSUosV0FBVztRQUFFVyxNQUFNO0lBQUssR0FDMUNDLEVBQUUsQ0FBQyxTQUFTLFNBQVVWLENBQUM7UUFBSSxPQUFPTSxHQUFHTixHQUFHO0lBQU8sR0FDL0NVLEVBQUUsQ0FBQyxXQUFXLFNBQVVDLENBQUM7UUFBSSxPQUFPTCxHQUFHLE1BQU1LO0lBQUksR0FDakRELEVBQUUsQ0FBQyxRQUFRLFNBQVVSLENBQUM7UUFDdkIsSUFBSUEsS0FBSyxDQUFDSyxNQUNORCxHQUFHLElBQUlNLE1BQU0sc0JBQXNCVixJQUFJO0lBQy9DO0lBQ0FNLEVBQUVLLFdBQVcsQ0FBQ1QsS0FBS0M7SUFDbkJHLEVBQUVNLFNBQVMsR0FBRztRQUNWUCxPQUFPO1FBQ1AsT0FBT1YsT0FBT2tCLFNBQVMsQ0FBQ0QsU0FBUyxDQUFDRSxJQUFJLENBQUNSO0lBQzNDO0lBQ0EsT0FBT0E7QUFDWCxJQUFJLFNBQVVMLENBQUMsRUFBRWMsRUFBRSxFQUFFQyxHQUFHLEVBQUVDLElBQUksRUFBRWIsRUFBRTtJQUM5QmMsYUFB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Q04wRixjQUFjekY7WUFDZFksYUFBYTRGO1FBQ2pCLElBQUk7WUFDQSxJQUFJLENBQUNBLEtBQ0RyRCxLQUFLLENBQUM5TCxHQUFHLEdBQUdwTCxJQUFJa08sTUFBTXhRLEdBQUdBLElBQUlvVztpQkFDNUIsSUFBSXlHLE9BQU8sR0FDWnJELEtBQUssQ0FBQzlMLEdBQUcsR0FBR3NCLFlBQVl3QixLQUFLak8sUUFBUSxDQUFDdkMsR0FBR0EsSUFBSW9XLEtBQUs7Z0JBQUUxTixLQUFLLElBQUl0SixHQUFHaVg7WUFBSTtpQkFFcEUzUyxJQUFJLElBQUksOEJBQThCbVo7UUFDOUM7SUFDSjtJQUNBLE9BQU9yRDtBQUNYO0FBQ0FoWCxpQkFBaUIsR0FBR29hIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3R1ZGlvZmxvdy8uL25vZGVfbW9kdWxlcy9mZmxhdGUvbGliL25vZGUuY2pzP2Q5MTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBERUZMQVRFIGlzIGEgY29tcGxleCBmb3JtYXQ7IHRvIHJlYWQgdGhpcyBjb2RlLCB5b3Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoZSBSRkMgZmlyc3Q6XG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTk1MVxuLy8gWW91IG1heSBhbHNvIHdpc2ggdG8gdGFrZSBhIGxvb2sgYXQgdGhlIGd1aWRlIEkgbWFkZSBhYm91dCB0aGlzIHByb2dyYW06XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDFhcnJvd3ovMjUzZjMxZWI1YWJjM2Q5Mjc1YWI5NDMwMDNmZmVjYWRcbi8vIFNvbWUgb2YgdGhlIGZvbGxvd2luZyBjb2RlIGlzIHNpbWlsYXIgdG8gdGhhdCBvZiBVWklQLmpzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvcGVhL1VaSVAuanNcbi8vIEhvd2V2ZXIsIHRoZSB2YXN0IG1ham9yaXR5IG9mIHRoZSBjb2RlYmFzZSBoYXMgZGl2ZXJnZWQgZnJvbSBVWklQLmpzIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlIGFuZCByZWR1Y2UgYnVuZGxlIHNpemUuXG4vLyBTb21ldGltZXMgMCB3aWxsIGFwcGVhciB3aGVyZSAtMSB3b3VsZCBiZSBtb3JlIGFwcHJvcHJpYXRlLiBUaGlzIGlzIGJlY2F1c2UgdXNpbmcgYSB1aW50XG4vLyBpcyBiZXR0ZXIgZm9yIG1lbW9yeSBpbiBtb3N0IGVuZ2luZXMgKEkgKnRoaW5rKikuXG4vLyBNZWRpb2NyZSBzaGltXG52YXIgV29ya2VyO1xudmFyIHdvcmtlckFkZCA9IFwiO3ZhciBfX3c9cmVxdWlyZSgnd29ya2VyX3RocmVhZHMnKTtfX3cucGFyZW50UG9ydC5vbignbWVzc2FnZScsZnVuY3Rpb24obSl7b25tZXNzYWdlKHtkYXRhOm19KX0pLHBvc3RNZXNzYWdlPWZ1bmN0aW9uKG0sdCl7X193LnBhcmVudFBvcnQucG9zdE1lc3NhZ2UobSx0KX0sY2xvc2U9cHJvY2Vzcy5leGl0O3NlbGY9Z2xvYmFsXCI7XG50cnkge1xuICAgIFdvcmtlciA9IHJlcXVpcmUoJ3dvcmtlcl90aHJlYWRzJykuV29ya2VyO1xufVxuY2F0Y2ggKGUpIHtcbn1cbnZhciBub2RlX3dvcmtlcl8xID0ge307XG5ub2RlX3dvcmtlcl8xW1wiZGVmYXVsdFwiXSA9IFdvcmtlciA/IGZ1bmN0aW9uIChjLCBfLCBtc2csIHRyYW5zZmVyLCBjYikge1xuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdmFyIHcgPSBuZXcgV29ya2VyKGMgKyB3b3JrZXJBZGQsIHsgZXZhbDogdHJ1ZSB9KVxuICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNiKGUsIG51bGwpOyB9KVxuICAgICAgICAub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gY2IobnVsbCwgbSk7IH0pXG4gICAgICAgIC5vbignZXhpdCcsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjICYmICFkb25lKVxuICAgICAgICAgICAgY2IobmV3IEVycm9yKCdleGl0ZWQgd2l0aCBjb2RlICcgKyBjKSwgbnVsbCk7XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcbiAgICB3LnRlcm1pbmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBXb3JrZXIucHJvdG90eXBlLnRlcm1pbmF0ZS5jYWxsKHcpO1xuICAgIH07XG4gICAgcmV0dXJuIHc7XG59IDogZnVuY3Rpb24gKF8sIF9fLCBfX18sIF9fX18sIGNiKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNiKG5ldyBFcnJvcignYXN5bmMgb3BlcmF0aW9ucyB1bnN1cHBvcnRlZCAtIHVwZGF0ZSB0byBOb2RlIDEyKyAob3IgTm9kZSAxMC0xMSB3aXRoIHRoZSAtLWV4cGVyaW1lbnRhbC13b3JrZXIgQ0xJIGZsYWcpJyksIG51bGwpOyB9KTtcbiAgICB2YXIgTk9QID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHRlcm1pbmF0ZTogTk9QLFxuICAgICAgICBwb3N0TWVzc2FnZTogTk9QXG4gICAgfTtcbn07XG5cbi8vIGFsaWFzZXMgZm9yIHNob3J0ZXIgY29tcHJlc3NlZCBjb2RlIChtb3N0IG1pbmlmZXJzIGRvbid0IGRvIHRoaXMpXG52YXIgdTggPSBVaW50OEFycmF5LCB1MTYgPSBVaW50MTZBcnJheSwgaTMyID0gSW50MzJBcnJheTtcbi8vIGZpeGVkIGxlbmd0aCBleHRyYSBiaXRzXG52YXIgZmxlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMCwgLyogdW51c2VkICovIDAsIDAsIC8qIGltcG9zc2libGUgKi8gMF0pO1xuLy8gZml4ZWQgZGlzdGFuY2UgZXh0cmEgYml0c1xudmFyIGZkZWIgPSBuZXcgdTgoWzAsIDAsIDAsIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDQsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDgsIDgsIDksIDksIDEwLCAxMCwgMTEsIDExLCAxMiwgMTIsIDEzLCAxMywgLyogdW51c2VkICovIDAsIDBdKTtcbi8vIGNvZGUgbGVuZ3RoIGluZGV4IG1hcFxudmFyIGNsaW0gPSBuZXcgdTgoWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdKTtcbi8vIGdldCBiYXNlLCByZXZlcnNlIGluZGV4IG1hcCBmcm9tIGV4dHJhIGJpdHNcbnZhciBmcmViID0gZnVuY3Rpb24gKGViLCBzdGFydCkge1xuICAgIHZhciBiID0gbmV3IHUxNigzMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMTsgKytpKSB7XG4gICAgICAgIGJbaV0gPSBzdGFydCArPSAxIDw8IGViW2kgLSAxXTtcbiAgICB9XG4gICAgLy8gbnVtYmVycyBoZXJlIGFyZSBhdCBtYXggMTggYml0c1xuICAgIHZhciByID0gbmV3IGkzMihiWzMwXSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAzMDsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBiW2ldOyBqIDwgYltpICsgMV07ICsraikge1xuICAgICAgICAgICAgcltqXSA9ICgoaiAtIGJbaV0pIDw8IDUpIHwgaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBiOiBiLCByOiByIH07XG59O1xudmFyIF9hID0gZnJlYihmbGViLCAyKSwgZmwgPSBfYS5iLCByZXZmbCA9IF9hLnI7XG4vLyB3ZSBjYW4gaWdub3JlIHRoZSBmYWN0IHRoYXQgdGhlIG90aGVyIG51bWJlcnMgYXJlIHdyb25nOyB0aGV5IG5ldmVyIGhhcHBlbiBhbnl3YXlcbmZsWzI4XSA9IDI1OCwgcmV2ZmxbMjU4XSA9IDI4O1xudmFyIF9iID0gZnJlYihmZGViLCAwKSwgZmQgPSBfYi5iLCByZXZmZCA9IF9iLnI7XG4vLyBtYXAgb2YgdmFsdWUgdG8gcmV2ZXJzZSAoYXNzdW1pbmcgMTYgYml0cylcbnZhciByZXYgPSBuZXcgdTE2KDMyNzY4KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMzI3Njg7ICsraSkge1xuICAgIC8vIHJldmVyc2UgdGFibGUgYWxnb3JpdGhtIGZyb20gU09cbiAgICB2YXIgeCA9ICgoaSAmIDB4QUFBQSkgPj4gMSkgfCAoKGkgJiAweDU1NTUpIDw8IDEpO1xuICAgIHggPSAoKHggJiAweENDQ0MpID4+IDIpIHwgKCh4ICYgMHgzMzMzKSA8PCAyKTtcbiAgICB4ID0gKCh4ICYgMHhGMEYwKSA+PiA0KSB8ICgoeCAmIDB4MEYwRikgPDwgNCk7XG4gICAgcmV2W2ldID0gKCgoeCAmIDB4RkYwMCkgPj4gOCkgfCAoKHggJiAweDAwRkYpIDw8IDgpKSA+PiAxO1xufVxuLy8gY3JlYXRlIGh1ZmZtYW4gdHJlZSBmcm9tIHU4IFwibWFwXCI6IGluZGV4IC0+IGNvZGUgbGVuZ3RoIGZvciBjb2RlIGluZGV4XG4vLyBtYiAobWF4IGJpdHMpIG11c3QgYmUgYXQgbW9zdCAxNVxuLy8gVE9ETzogb3B0aW1pemUvc3BsaXQgdXA/XG52YXIgaE1hcCA9IChmdW5jdGlvbiAoY2QsIG1iLCByKSB7XG4gICAgdmFyIHMgPSBjZC5sZW5ndGg7XG4gICAgLy8gaW5kZXhcbiAgICB2YXIgaSA9IDA7XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+ICMgb2YgY29kZXMgd2l0aCBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbCA9IG5ldyB1MTYobWIpO1xuICAgIC8vIGxlbmd0aCBvZiBjZCBtdXN0IGJlIDI4OCAodG90YWwgIyBvZiBjb2RlcylcbiAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICBpZiAoY2RbaV0pXG4gICAgICAgICAgICArK2xbY2RbaV0gLSAxXTtcbiAgICB9XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG1pbmltdW0gY29kZSBmb3IgYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGxlID0gbmV3IHUxNihtYik7XG4gICAgZm9yIChpID0gMTsgaSA8IG1iOyArK2kpIHtcbiAgICAgICAgbGVbaV0gPSAobGVbaSAtIDFdICsgbFtpIC0gMV0pIDw8IDE7XG4gICAgfVxuICAgIHZhciBjbztcbiAgICBpZiAocikge1xuICAgICAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbnVtYmVyIG9mIGFjdHVhbCBiaXRzLCBzeW1ib2wgZm9yIGNvZGVcbiAgICAgICAgY28gPSBuZXcgdTE2KDEgPDwgbWIpO1xuICAgICAgICAvLyBiaXRzIHRvIHJlbW92ZSBmb3IgcmV2ZXJzZXJcbiAgICAgICAgdmFyIHJ2YiA9IDE1IC0gbWI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSAwIGxlbmd0aHNcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIC8vIG51bSBlbmNvZGluZyBib3RoIHN5bWJvbCBhbmQgYml0cyByZWFkXG4gICAgICAgICAgICAgICAgdmFyIHN2ID0gKGkgPDwgNCkgfCBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBmcmVlIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgcl8xID0gbWIgLSBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciB2ID0gbGVbY2RbaV0gLSAxXSsrIDw8IHJfMTtcbiAgICAgICAgICAgICAgICAvLyBtIGlzIGVuZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSB2IHwgKCgxIDw8IHJfMSkgLSAxKTsgdiA8PSBtOyArK3YpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnkgMTYgYml0IHZhbHVlIHN0YXJ0aW5nIHdpdGggdGhlIGNvZGUgeWllbGRzIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBjb1tyZXZbdl0gPj4gcnZiXSA9IHN2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY28gPSBuZXcgdTE2KHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICBpZiAoY2RbaV0pIHtcbiAgICAgICAgICAgICAgICBjb1tpXSA9IHJldltsZVtjZFtpXSAtIDFdKytdID4+ICgxNSAtIGNkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY287XG59KTtcbi8vIGZpeGVkIGxlbmd0aCB0cmVlXG52YXIgZmx0ID0gbmV3IHU4KDI4OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDE0NDsgKytpKVxuICAgIGZsdFtpXSA9IDg7XG5mb3IgKHZhciBpID0gMTQ0OyBpIDwgMjU2OyArK2kpXG4gICAgZmx0W2ldID0gOTtcbmZvciAodmFyIGkgPSAyNTY7IGkgPCAyODA7ICsraSlcbiAgICBmbHRbaV0gPSA3O1xuZm9yICh2YXIgaSA9IDI4MDsgaSA8IDI4ODsgKytpKVxuICAgIGZsdFtpXSA9IDg7XG4vLyBmaXhlZCBkaXN0YW5jZSB0cmVlXG52YXIgZmR0ID0gbmV3IHU4KDMyKTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMzI7ICsraSlcbiAgICBmZHRbaV0gPSA1O1xuLy8gZml4ZWQgbGVuZ3RoIG1hcFxudmFyIGZsbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmbHQsIDksIDApLCBmbHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBtYXBcbnZhciBmZG0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmR0LCA1LCAwKSwgZmRybSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDEpO1xuLy8gZmluZCBtYXggb2YgYXJyYXlcbnZhciBtYXggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBtID0gYVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gPiBtKVxuICAgICAgICAgICAgbSA9IGFbaV07XG4gICAgfVxuICAgIHJldHVybiBtO1xufTtcbi8vIHJlYWQgZCwgc3RhcnRpbmcgYXQgYml0IHAgYW5kIG1hc2sgd2l0aCBtXG52YXIgYml0cyA9IGZ1bmN0aW9uIChkLCBwLCBtKSB7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICByZXR1cm4gKChkW29dIHwgKGRbbyArIDFdIDw8IDgpKSA+PiAocCAmIDcpKSAmIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBjb250aW51aW5nIGZvciBhdCBsZWFzdCAxNiBiaXRzXG52YXIgYml0czE2ID0gZnVuY3Rpb24gKGQsIHApIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkgfCAoZFtvICsgMl0gPDwgMTYpKSA+PiAocCAmIDcpKTtcbn07XG4vLyBnZXQgZW5kIG9mIGJ5dGVcbnZhciBzaGZ0ID0gZnVuY3Rpb24gKHApIHsgcmV0dXJuICgocCArIDcpIC8gOCkgfCAwOyB9O1xuLy8gdHlwZWQgYXJyYXkgc2xpY2UgLSBhbGxvd3MgZ2FyYmFnZSBjb2xsZWN0b3IgdG8gZnJlZSBvcmlnaW5hbCByZWZlcmVuY2UsXG4vLyB3aGlsZSBiZWluZyBtb3JlIGNvbXBhdGlibGUgdGhhbiAuc2xpY2VcbnZhciBzbGMgPSBmdW5jdGlvbiAodiwgcywgZSkge1xuICAgIGlmIChzID09IG51bGwgfHwgcyA8IDApXG4gICAgICAgIHMgPSAwO1xuICAgIGlmIChlID09IG51bGwgfHwgZSA+IHYubGVuZ3RoKVxuICAgICAgICBlID0gdi5sZW5ndGg7XG4gICAgLy8gY2FuJ3QgdXNlIC5jb25zdHJ1Y3RvciBpbiBjYXNlIHVzZXItc3VwcGxpZWRcbiAgICByZXR1cm4gbmV3IHU4KHYuc3ViYXJyYXkocywgZSkpO1xufTtcbi8qKlxuICogQ29kZXMgZm9yIGVycm9ycyBnZW5lcmF0ZWQgd2l0aGluIHRoaXMgbGlicmFyeVxuICovXG5leHBvcnRzLkZsYXRlRXJyb3JDb2RlID0ge1xuICAgIFVuZXhwZWN0ZWRFT0Y6IDAsXG4gICAgSW52YWxpZEJsb2NrVHlwZTogMSxcbiAgICBJbnZhbGlkTGVuZ3RoTGl0ZXJhbDogMixcbiAgICBJbnZhbGlkRGlzdGFuY2U6IDMsXG4gICAgU3RyZWFtRmluaXNoZWQ6IDQsXG4gICAgTm9TdHJlYW1IYW5kbGVyOiA1LFxuICAgIEludmFsaWRIZWFkZXI6IDYsXG4gICAgTm9DYWxsYmFjazogNyxcbiAgICBJbnZhbGlkVVRGODogOCxcbiAgICBFeHRyYUZpZWxkVG9vTG9uZzogOSxcbiAgICBJbnZhbGlkRGF0ZTogMTAsXG4gICAgRmlsZW5hbWVUb29Mb25nOiAxMSxcbiAgICBTdHJlYW1GaW5pc2hpbmc6IDEyLFxuICAgIEludmFsaWRaaXBEYXRhOiAxMyxcbiAgICBVbmtub3duQ29tcHJlc3Npb25NZXRob2Q6IDE0XG59O1xuLy8gZXJyb3IgY29kZXNcbnZhciBlYyA9IFtcbiAgICAndW5leHBlY3RlZCBFT0YnLFxuICAgICdpbnZhbGlkIGJsb2NrIHR5cGUnLFxuICAgICdpbnZhbGlkIGxlbmd0aC9saXRlcmFsJyxcbiAgICAnaW52YWxpZCBkaXN0YW5jZScsXG4gICAgJ3N0cmVhbSBmaW5pc2hlZCcsXG4gICAgJ25vIHN0cmVhbSBoYW5kbGVyJyxcbiAgICAsXG4gICAgJ25vIGNhbGxiYWNrJyxcbiAgICAnaW52YWxpZCBVVEYtOCBkYXRhJyxcbiAgICAnZXh0cmEgZmllbGQgdG9vIGxvbmcnLFxuICAgICdkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTknLFxuICAgICdmaWxlbmFtZSB0b28gbG9uZycsXG4gICAgJ3N0cmVhbSBmaW5pc2hpbmcnLFxuICAgICdpbnZhbGlkIHppcCBkYXRhJ1xuICAgIC8vIGRldGVybWluZWQgYnkgdW5rbm93biBjb21wcmVzc2lvbiBtZXRob2Rcbl07XG47XG52YXIgZXJyID0gZnVuY3Rpb24gKGluZCwgbXNnLCBudCkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1zZyB8fCBlY1tpbmRdKTtcbiAgICBlLmNvZGUgPSBpbmQ7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlLCBlcnIpO1xuICAgIGlmICghbnQpXG4gICAgICAgIHRocm93IGU7XG4gICAgcmV0dXJuIGU7XG59O1xuLy8gZXhwYW5kcyByYXcgREVGTEFURSBkYXRhXG52YXIgaW5mbHQgPSBmdW5jdGlvbiAoZGF0LCBzdCwgYnVmLCBkaWN0KSB7XG4gICAgLy8gc291cmNlIGxlbmd0aCAgICAgICBkaWN0IGxlbmd0aFxuICAgIHZhciBzbCA9IGRhdC5sZW5ndGgsIGRsID0gZGljdCA/IGRpY3QubGVuZ3RoIDogMDtcbiAgICBpZiAoIXNsIHx8IHN0LmYgJiYgIXN0LmwpXG4gICAgICAgIHJldHVybiBidWYgfHwgbmV3IHU4KDApO1xuICAgIHZhciBub0J1ZiA9ICFidWY7XG4gICAgLy8gaGF2ZSB0byBlc3RpbWF0ZSBzaXplXG4gICAgdmFyIHJlc2l6ZSA9IG5vQnVmIHx8IHN0LmkgIT0gMjtcbiAgICAvLyBubyBzdGF0ZVxuICAgIHZhciBub1N0ID0gc3QuaTtcbiAgICAvLyBBc3N1bWVzIHJvdWdobHkgMzMlIGNvbXByZXNzaW9uIHJhdGlvIGF2ZXJhZ2VcbiAgICBpZiAobm9CdWYpXG4gICAgICAgIGJ1ZiA9IG5ldyB1OChzbCAqIDMpO1xuICAgIC8vIGVuc3VyZSBidWZmZXIgY2FuIGZpdCBhdCBsZWFzdCBsIGVsZW1lbnRzXG4gICAgdmFyIGNidWYgPSBmdW5jdGlvbiAobCkge1xuICAgICAgICB2YXIgYmwgPSBidWYubGVuZ3RoO1xuICAgICAgICAvLyBuZWVkIHRvIGluY3JlYXNlIHNpemUgdG8gZml0XG4gICAgICAgIGlmIChsID4gYmwpIHtcbiAgICAgICAgICAgIC8vIERvdWJsZSBvciBzZXQgdG8gbmVjZXNzYXJ5LCB3aGljaGV2ZXIgaXMgZ3JlYXRlclxuICAgICAgICAgICAgdmFyIG5idWYgPSBuZXcgdTgoTWF0aC5tYXgoYmwgKiAyLCBsKSk7XG4gICAgICAgICAgICBuYnVmLnNldChidWYpO1xuICAgICAgICAgICAgYnVmID0gbmJ1ZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gIGxhc3QgY2h1bmsgICAgICAgICBiaXRwb3MgICAgICAgICAgIGJ5dGVzXG4gICAgdmFyIGZpbmFsID0gc3QuZiB8fCAwLCBwb3MgPSBzdC5wIHx8IDAsIGJ0ID0gc3QuYiB8fCAwLCBsbSA9IHN0LmwsIGRtID0gc3QuZCwgbGJ0ID0gc3QubSwgZGJ0ID0gc3QubjtcbiAgICAvLyB0b3RhbCBiaXRzXG4gICAgdmFyIHRidHMgPSBzbCAqIDg7XG4gICAgZG8ge1xuICAgICAgICBpZiAoIWxtKSB7XG4gICAgICAgICAgICAvLyBCRklOQUwgLSB0aGlzIGlzIG9ubHkgMSB3aGVuIGxhc3QgY2h1bmsgaXMgbmV4dFxuICAgICAgICAgICAgZmluYWwgPSBiaXRzKGRhdCwgcG9zLCAxKTtcbiAgICAgICAgICAgIC8vIHR5cGU6IDAgPSBubyBjb21wcmVzc2lvbiwgMSA9IGZpeGVkIGh1ZmZtYW4sIDIgPSBkeW5hbWljIGh1ZmZtYW5cbiAgICAgICAgICAgIHZhciB0eXBlID0gYml0cyhkYXQsIHBvcyArIDEsIDMpO1xuICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBnbyB0byBlbmQgb2YgYnl0ZSBib3VuZGFyeVxuICAgICAgICAgICAgICAgIHZhciBzID0gc2hmdChwb3MpICsgNCwgbCA9IGRhdFtzIC0gNF0gfCAoZGF0W3MgLSAzXSA8PCA4KSwgdCA9IHMgKyBsO1xuICAgICAgICAgICAgICAgIGlmICh0ID4gc2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc2l6ZVxuICAgICAgICAgICAgICAgIGlmIChyZXNpemUpXG4gICAgICAgICAgICAgICAgICAgIGNidWYoYnQgKyBsKTtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IG92ZXIgdW5jb21wcmVzc2VkIGRhdGFcbiAgICAgICAgICAgICAgICBidWYuc2V0KGRhdC5zdWJhcnJheShzLCB0KSwgYnQpO1xuICAgICAgICAgICAgICAgIC8vIEdldCBuZXcgYml0cG9zLCB1cGRhdGUgYnl0ZSBjb3VudFxuICAgICAgICAgICAgICAgIHN0LmIgPSBidCArPSBsLCBzdC5wID0gcG9zID0gdCAqIDgsIHN0LmYgPSBmaW5hbDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBsbSA9IGZscm0sIGRtID0gZmRybSwgbGJ0ID0gOSwgZGJ0ID0gNTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMikge1xuICAgICAgICAgICAgICAgIC8vICBsaXRlcmFsICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHNcbiAgICAgICAgICAgICAgICB2YXIgaExpdCA9IGJpdHMoZGF0LCBwb3MsIDMxKSArIDI1NywgaGNMZW4gPSBiaXRzKGRhdCwgcG9zICsgMTAsIDE1KSArIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHRsID0gaExpdCArIGJpdHMoZGF0LCBwb3MgKyA1LCAzMSkgKyAxO1xuICAgICAgICAgICAgICAgIHBvcyArPSAxNDtcbiAgICAgICAgICAgICAgICAvLyBsZW5ndGgrZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsZHQgPSBuZXcgdTgodGwpO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RoIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgY2x0ID0gbmV3IHU4KDE5KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhjTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGluZGV4IG1hcCB0byBnZXQgcmVhbCBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGNsdFtjbGltW2ldXSA9IGJpdHMoZGF0LCBwb3MgKyBpICogMywgNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBoY0xlbiAqIDM7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGhzIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgY2xiID0gbWF4KGNsdCksIGNsYm1zayA9ICgxIDw8IGNsYikgLSAxO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBtYXBcbiAgICAgICAgICAgICAgICB2YXIgY2xtID0gaE1hcChjbHQsIGNsYiwgMSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjbG1bYml0cyhkYXQsIHBvcywgY2xibXNrKV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gciAmIDE1O1xuICAgICAgICAgICAgICAgICAgICAvLyBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByID4+IDQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RoIHRvIGNvcHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPCAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGR0W2krK10gPSBzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNvcHkgICBjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSAwLCBuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09IDE2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAzICsgYml0cyhkYXQsIHBvcywgMyksIHBvcyArPSAyLCBjID0gbGR0W2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gMTcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDMgKyBiaXRzKGRhdCwgcG9zLCA3KSwgcG9zICs9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDE4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAxMSArIGJpdHMoZGF0LCBwb3MsIDEyNyksIHBvcyArPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG4tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZHRbaSsrXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgbGVuZ3RoIHRyZWUgICAgICAgICAgICAgICAgIGRpc3RhbmNlIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgbHQgPSBsZHQuc3ViYXJyYXkoMCwgaExpdCksIGR0ID0gbGR0LnN1YmFycmF5KGhMaXQpO1xuICAgICAgICAgICAgICAgIC8vIG1heCBsZW5ndGggYml0c1xuICAgICAgICAgICAgICAgIGxidCA9IG1heChsdCk7XG4gICAgICAgICAgICAgICAgLy8gbWF4IGRpc3QgYml0c1xuICAgICAgICAgICAgICAgIGRidCA9IG1heChkdCk7XG4gICAgICAgICAgICAgICAgbG0gPSBoTWFwKGx0LCBsYnQsIDEpO1xuICAgICAgICAgICAgICAgIGRtID0gaE1hcChkdCwgZGJ0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlcnIoMSk7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBidWZmZXIgY2FuIGhvbGQgdGhpcyArIHRoZSBsYXJnZXN0IHBvc3NpYmxlIGFkZGl0aW9uXG4gICAgICAgIC8vIE1heGltdW0gY2h1bmsgc2l6ZSAocHJhY3RpY2FsbHksIHRoZW9yZXRpY2FsbHkgaW5maW5pdGUpIGlzIDJeMTdcbiAgICAgICAgaWYgKHJlc2l6ZSlcbiAgICAgICAgICAgIGNidWYoYnQgKyAxMzEwNzIpO1xuICAgICAgICB2YXIgbG1zID0gKDEgPDwgbGJ0KSAtIDEsIGRtcyA9ICgxIDw8IGRidCkgLSAxO1xuICAgICAgICB2YXIgbHBvcyA9IHBvcztcbiAgICAgICAgZm9yICg7OyBscG9zID0gcG9zKSB7XG4gICAgICAgICAgICAvLyBiaXRzIHJlYWQsIGNvZGVcbiAgICAgICAgICAgIHZhciBjID0gbG1bYml0czE2KGRhdCwgcG9zKSAmIGxtc10sIHN5bSA9IGMgPj4gNDtcbiAgICAgICAgICAgIHBvcyArPSBjICYgMTU7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICBlcnIoMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICAgICAgZXJyKDIpO1xuICAgICAgICAgICAgaWYgKHN5bSA8IDI1NilcbiAgICAgICAgICAgICAgICBidWZbYnQrK10gPSBzeW07XG4gICAgICAgICAgICBlbHNlIGlmIChzeW0gPT0gMjU2KSB7XG4gICAgICAgICAgICAgICAgbHBvcyA9IHBvcywgbG0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IHN5bSAtIDI1NDtcbiAgICAgICAgICAgICAgICAvLyBubyBleHRyYSBiaXRzIG5lZWRlZCBpZiBsZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN5bSA+IDI2NCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHN5bSAtIDI1NywgYiA9IGZsZWJbaV07XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9IGJpdHMoZGF0LCBwb3MsICgxIDw8IGIpIC0gMSkgKyBmbFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRpc3RcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRtW2JpdHMxNihkYXQsIHBvcykgJiBkbXNdLCBkc3ltID0gZCA+PiA0O1xuICAgICAgICAgICAgICAgIGlmICghZClcbiAgICAgICAgICAgICAgICAgICAgZXJyKDMpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBkICYgMTU7XG4gICAgICAgICAgICAgICAgdmFyIGR0ID0gZmRbZHN5bV07XG4gICAgICAgICAgICAgICAgaWYgKGRzeW0gPiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gZmRlYltkc3ltXTtcbiAgICAgICAgICAgICAgICAgICAgZHQgKz0gYml0czE2KGRhdCwgcG9zKSAmICgxIDw8IGIpIC0gMSwgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyKDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGJ0ICsgYWRkO1xuICAgICAgICAgICAgICAgIGlmIChidCA8IGR0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGlmdCA9IGRsIC0gZHQsIGRlbmQgPSBNYXRoLm1pbihkdCwgZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoaWZ0ICsgYnQgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyKDMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgYnQgPCBkZW5kOyArK2J0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmW2J0XSA9IGRpY3Rbc2hpZnQgKyBidF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoOyBidCA8IGVuZDsgKytidClcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0XSA9IGJ1ZltidCAtIGR0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdC5sID0gbG0sIHN0LnAgPSBscG9zLCBzdC5iID0gYnQsIHN0LmYgPSBmaW5hbDtcbiAgICAgICAgaWYgKGxtKVxuICAgICAgICAgICAgZmluYWwgPSAxLCBzdC5tID0gbGJ0LCBzdC5kID0gZG0sIHN0Lm4gPSBkYnQ7XG4gICAgfSB3aGlsZSAoIWZpbmFsKTtcbiAgICAvLyBkb24ndCByZWFsbG9jYXRlIGZvciBzdHJlYW1zIG9yIHVzZXIgYnVmZmVyc1xuICAgIHJldHVybiBidCAhPSBidWYubGVuZ3RoICYmIG5vQnVmID8gc2xjKGJ1ZiwgMCwgYnQpIDogYnVmLnN1YmFycmF5KDAsIGJ0KTtcbn07XG4vLyBzdGFydGluZyBhdCBwLCB3cml0ZSB0aGUgbWluaW11bSBudW1iZXIgb2YgYml0cyB0aGF0IGNhbiBob2xkIHYgdG8gZFxudmFyIHdiaXRzID0gZnVuY3Rpb24gKGQsIHAsIHYpIHtcbiAgICB2IDw8PSBwICYgNztcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIGRbb10gfD0gdjtcbiAgICBkW28gKyAxXSB8PSB2ID4+IDg7XG59O1xuLy8gc3RhcnRpbmcgYXQgcCwgd3JpdGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJpdHMgKD44KSB0aGF0IGNhbiBob2xkIHYgdG8gZFxudmFyIHdiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCwgdikge1xuICAgIHYgPDw9IHAgJiA3O1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgZFtvXSB8PSB2O1xuICAgIGRbbyArIDFdIHw9IHYgPj4gODtcbiAgICBkW28gKyAyXSB8PSB2ID4+IDE2O1xufTtcbi8vIGNyZWF0ZXMgY29kZSBsZW5ndGhzIGZyb20gYSBmcmVxdWVuY3kgdGFibGVcbnZhciBoVHJlZSA9IGZ1bmN0aW9uIChkLCBtYikge1xuICAgIC8vIE5lZWQgZXh0cmEgaW5mbyB0byBtYWtlIGEgdHJlZVxuICAgIHZhciB0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChkW2ldKVxuICAgICAgICAgICAgdC5wdXNoKHsgczogaSwgZjogZFtpXSB9KTtcbiAgICB9XG4gICAgdmFyIHMgPSB0Lmxlbmd0aDtcbiAgICB2YXIgdDIgPSB0LnNsaWNlKCk7XG4gICAgaWYgKCFzKVxuICAgICAgICByZXR1cm4geyB0OiBldCwgbDogMCB9O1xuICAgIGlmIChzID09IDEpIHtcbiAgICAgICAgdmFyIHYgPSBuZXcgdTgodFswXS5zICsgMSk7XG4gICAgICAgIHZbdFswXS5zXSA9IDE7XG4gICAgICAgIHJldHVybiB7IHQ6IHYsIGw6IDEgfTtcbiAgICB9XG4gICAgdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmYgLSBiLmY7IH0pO1xuICAgIC8vIGFmdGVyIGkyIHJlYWNoZXMgbGFzdCBpbmQsIHdpbGwgYmUgc3RvcHBlZFxuICAgIC8vIGZyZXEgbXVzdCBiZSBncmVhdGVyIHRoYW4gbGFyZ2VzdCBwb3NzaWJsZSBudW1iZXIgb2Ygc3ltYm9sc1xuICAgIHQucHVzaCh7IHM6IC0xLCBmOiAyNTAwMSB9KTtcbiAgICB2YXIgbCA9IHRbMF0sIHIgPSB0WzFdLCBpMCA9IDAsIGkxID0gMSwgaTIgPSAyO1xuICAgIHRbMF0gPSB7IHM6IC0xLCBmOiBsLmYgKyByLmYsIGw6IGwsIHI6IHIgfTtcbiAgICAvLyBlZmZpY2llbnQgYWxnb3JpdGhtIGZyb20gVVpJUC5qc1xuICAgIC8vIGkwIGlzIGxvb2tiZWhpbmQsIGkyIGlzIGxvb2thaGVhZCAtIGFmdGVyIHByb2Nlc3NpbmcgdHdvIGxvdy1mcmVxXG4gICAgLy8gc3ltYm9scyB0aGF0IGNvbWJpbmVkIGhhdmUgaGlnaCBmcmVxLCB3aWxsIHN0YXJ0IHByb2Nlc3NpbmcgaTIgKGhpZ2gtZnJlcSxcbiAgICAvLyBub24tY29tcG9zaXRlKSBzeW1ib2xzIGluc3RlYWRcbiAgICAvLyBzZWUgaHR0cHM6Ly9yZWRkaXQuY29tL3IvcGhvdG9wZWEvY29tbWVudHMvaWtla2h0L3V6aXBqc19xdWVzdGlvbnMvXG4gICAgd2hpbGUgKGkxICE9IHMgLSAxKSB7XG4gICAgICAgIGwgPSB0W3RbaTBdLmYgPCB0W2kyXS5mID8gaTArKyA6IGkyKytdO1xuICAgICAgICByID0gdFtpMCAhPSBpMSAmJiB0W2kwXS5mIDwgdFtpMl0uZiA/IGkwKysgOiBpMisrXTtcbiAgICAgICAgdFtpMSsrXSA9IHsgczogLTEsIGY6IGwuZiArIHIuZiwgbDogbCwgcjogciB9O1xuICAgIH1cbiAgICB2YXIgbWF4U3ltID0gdDJbMF0ucztcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7ICsraSkge1xuICAgICAgICBpZiAodDJbaV0ucyA+IG1heFN5bSlcbiAgICAgICAgICAgIG1heFN5bSA9IHQyW2ldLnM7XG4gICAgfVxuICAgIC8vIGNvZGUgbGVuZ3Roc1xuICAgIHZhciB0ciA9IG5ldyB1MTYobWF4U3ltICsgMSk7XG4gICAgLy8gbWF4IGJpdHMgaW4gdHJlZVxuICAgIHZhciBtYnQgPSBsbih0W2kxIC0gMV0sIHRyLCAwKTtcbiAgICBpZiAobWJ0ID4gbWIpIHtcbiAgICAgICAgLy8gbW9yZSBhbGdvcml0aG1zIGZyb20gVVpJUC5qc1xuICAgICAgICAvLyBUT0RPOiBmaW5kIG91dCBob3cgdGhpcyBjb2RlIHdvcmtzIChkZWJ0KVxuICAgICAgICAvLyAgaW5kICAgIGRlYnRcbiAgICAgICAgdmFyIGkgPSAwLCBkdCA9IDA7XG4gICAgICAgIC8vICAgIGxlZnQgICAgICAgICAgICBjb3N0XG4gICAgICAgIHZhciBsZnQgPSBtYnQgLSBtYiwgY3N0ID0gMSA8PCBsZnQ7XG4gICAgICAgIHQyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHRyW2Iuc10gLSB0clthLnNdIHx8IGEuZiAtIGIuZjsgfSk7XG4gICAgICAgIGZvciAoOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaTJfMSA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfMV0gPiBtYikge1xuICAgICAgICAgICAgICAgIGR0ICs9IGNzdCAtICgxIDw8IChtYnQgLSB0cltpMl8xXSkpO1xuICAgICAgICAgICAgICAgIHRyW2kyXzFdID0gbWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZHQgPj49IGxmdDtcbiAgICAgICAgd2hpbGUgKGR0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGkyXzIgPSB0MltpXS5zO1xuICAgICAgICAgICAgaWYgKHRyW2kyXzJdIDwgbWIpXG4gICAgICAgICAgICAgICAgZHQgLT0gMSA8PCAobWIgLSB0cltpMl8yXSsrIC0gMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpID49IDAgJiYgZHQ7IC0taSkge1xuICAgICAgICAgICAgdmFyIGkyXzMgPSB0MltpXS5zO1xuICAgICAgICAgICAgaWYgKHRyW2kyXzNdID09IG1iKSB7XG4gICAgICAgICAgICAgICAgLS10cltpMl8zXTtcbiAgICAgICAgICAgICAgICArK2R0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1idCA9IG1iO1xuICAgIH1cbiAgICByZXR1cm4geyB0OiBuZXcgdTgodHIpLCBsOiBtYnQgfTtcbn07XG4vLyBnZXQgdGhlIG1heCBsZW5ndGggYW5kIGFzc2lnbiBsZW5ndGggY29kZXNcbnZhciBsbiA9IGZ1bmN0aW9uIChuLCBsLCBkKSB7XG4gICAgcmV0dXJuIG4ucyA9PSAtMVxuICAgICAgICA/IE1hdGgubWF4KGxuKG4ubCwgbCwgZCArIDEpLCBsbihuLnIsIGwsIGQgKyAxKSlcbiAgICAgICAgOiAobFtuLnNdID0gZCk7XG59O1xuLy8gbGVuZ3RoIGNvZGVzIGdlbmVyYXRpb25cbnZhciBsYyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIHMgPSBjLmxlbmd0aDtcbiAgICAvLyBOb3RlIHRoYXQgdGhlIHNlbWljb2xvbiB3YXMgaW50ZW50aW9uYWxcbiAgICB3aGlsZSAocyAmJiAhY1stLXNdKVxuICAgICAgICA7XG4gICAgdmFyIGNsID0gbmV3IHUxNigrK3MpO1xuICAgIC8vICBpbmQgICAgICBudW0gICAgICAgICBzdHJlYWtcbiAgICB2YXIgY2xpID0gMCwgY2xuID0gY1swXSwgY2xzID0gMTtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGNsW2NsaSsrXSA9IHY7IH07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gczsgKytpKSB7XG4gICAgICAgIGlmIChjW2ldID09IGNsbiAmJiBpICE9IHMpXG4gICAgICAgICAgICArK2NscztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWNsbiAmJiBjbHMgPiAyKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGNscyA+IDEzODsgY2xzIC09IDEzOClcbiAgICAgICAgICAgICAgICAgICAgdygzMjc1NCk7XG4gICAgICAgICAgICAgICAgaWYgKGNscyA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdyhjbHMgPiAxMCA/ICgoY2xzIC0gMTEpIDw8IDUpIHwgMjg2OTAgOiAoKGNscyAtIDMpIDw8IDUpIHwgMTIzMDUpO1xuICAgICAgICAgICAgICAgICAgICBjbHMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNscyA+IDMpIHtcbiAgICAgICAgICAgICAgICB3KGNsbiksIC0tY2xzO1xuICAgICAgICAgICAgICAgIGZvciAoOyBjbHMgPiA2OyBjbHMgLT0gNilcbiAgICAgICAgICAgICAgICAgICAgdyg4MzA0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzID4gMilcbiAgICAgICAgICAgICAgICAgICAgdygoKGNscyAtIDMpIDw8IDUpIHwgODIwOCksIGNscyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2xzLS0pXG4gICAgICAgICAgICAgICAgdyhjbG4pO1xuICAgICAgICAgICAgY2xzID0gMTtcbiAgICAgICAgICAgIGNsbiA9IGNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYzogY2wuc3ViYXJyYXkoMCwgY2xpKSwgbjogcyB9O1xufTtcbi8vIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIG91dHB1dCBmcm9tIHRyZWUsIGNvZGUgbGVuZ3Roc1xudmFyIGNsZW4gPSBmdW5jdGlvbiAoY2YsIGNsKSB7XG4gICAgdmFyIGwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2wubGVuZ3RoOyArK2kpXG4gICAgICAgIGwgKz0gY2ZbaV0gKiBjbFtpXTtcbiAgICByZXR1cm4gbDtcbn07XG4vLyB3cml0ZXMgYSBmaXhlZCBibG9ja1xuLy8gcmV0dXJucyB0aGUgbmV3IGJpdCBwb3NcbnZhciB3ZmJsayA9IGZ1bmN0aW9uIChvdXQsIHBvcywgZGF0KSB7XG4gICAgLy8gbm8gbmVlZCB0byB3cml0ZSAwMCBhcyB0eXBlOiBUeXBlZEFycmF5IGRlZmF1bHRzIHRvIDBcbiAgICB2YXIgcyA9IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBzaGZ0KHBvcyArIDIpO1xuICAgIG91dFtvXSA9IHMgJiAyNTU7XG4gICAgb3V0W28gKyAxXSA9IHMgPj4gODtcbiAgICBvdXRbbyArIDJdID0gb3V0W29dIF4gMjU1O1xuICAgIG91dFtvICsgM10gPSBvdXRbbyArIDFdIF4gMjU1O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgKytpKVxuICAgICAgICBvdXRbbyArIGkgKyA0XSA9IGRhdFtpXTtcbiAgICByZXR1cm4gKG8gKyA0ICsgcykgKiA4O1xufTtcbi8vIHdyaXRlcyBhIGJsb2NrXG52YXIgd2JsayA9IGZ1bmN0aW9uIChkYXQsIG91dCwgZmluYWwsIHN5bXMsIGxmLCBkZiwgZWIsIGxpLCBicywgYmwsIHApIHtcbiAgICB3Yml0cyhvdXQsIHArKywgZmluYWwpO1xuICAgICsrbGZbMjU2XTtcbiAgICB2YXIgX2EgPSBoVHJlZShsZiwgMTUpLCBkbHQgPSBfYS50LCBtbGIgPSBfYS5sO1xuICAgIHZhciBfYiA9IGhUcmVlKGRmLCAxNSksIGRkdCA9IF9iLnQsIG1kYiA9IF9iLmw7XG4gICAgdmFyIF9jID0gbGMoZGx0KSwgbGNsdCA9IF9jLmMsIG5sYyA9IF9jLm47XG4gICAgdmFyIF9kID0gbGMoZGR0KSwgbGNkdCA9IF9kLmMsIG5kYyA9IF9kLm47XG4gICAgdmFyIGxjZnJlcSA9IG5ldyB1MTYoMTkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGNsdC5sZW5ndGg7ICsraSlcbiAgICAgICAgKytsY2ZyZXFbbGNsdFtpXSAmIDMxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxjZHQubGVuZ3RoOyArK2kpXG4gICAgICAgICsrbGNmcmVxW2xjZHRbaV0gJiAzMV07XG4gICAgdmFyIF9lID0gaFRyZWUobGNmcmVxLCA3KSwgbGN0ID0gX2UudCwgbWxjYiA9IF9lLmw7XG4gICAgdmFyIG5sY2MgPSAxOTtcbiAgICBmb3IgKDsgbmxjYyA+IDQgJiYgIWxjdFtjbGltW25sY2MgLSAxXV07IC0tbmxjYylcbiAgICAgICAgO1xuICAgIHZhciBmbGVuID0gKGJsICsgNSkgPDwgMztcbiAgICB2YXIgZnRsZW4gPSBjbGVuKGxmLCBmbHQpICsgY2xlbihkZiwgZmR0KSArIGViO1xuICAgIHZhciBkdGxlbiA9IGNsZW4obGYsIGRsdCkgKyBjbGVuKGRmLCBkZHQpICsgZWIgKyAxNCArIDMgKiBubGNjICsgY2xlbihsY2ZyZXEsIGxjdCkgKyAyICogbGNmcmVxWzE2XSArIDMgKiBsY2ZyZXFbMTddICsgNyAqIGxjZnJlcVsxOF07XG4gICAgaWYgKGJzID49IDAgJiYgZmxlbiA8PSBmdGxlbiAmJiBmbGVuIDw9IGR0bGVuKVxuICAgICAgICByZXR1cm4gd2ZibGsob3V0LCBwLCBkYXQuc3ViYXJyYXkoYnMsIGJzICsgYmwpKTtcbiAgICB2YXIgbG0sIGxsLCBkbSwgZGw7XG4gICAgd2JpdHMob3V0LCBwLCAxICsgKGR0bGVuIDwgZnRsZW4pKSwgcCArPSAyO1xuICAgIGlmIChkdGxlbiA8IGZ0bGVuKSB7XG4gICAgICAgIGxtID0gaE1hcChkbHQsIG1sYiwgMCksIGxsID0gZGx0LCBkbSA9IGhNYXAoZGR0LCBtZGIsIDApLCBkbCA9IGRkdDtcbiAgICAgICAgdmFyIGxsbSA9IGhNYXAobGN0LCBtbGNiLCAwKTtcbiAgICAgICAgd2JpdHMob3V0LCBwLCBubGMgLSAyNTcpO1xuICAgICAgICB3Yml0cyhvdXQsIHAgKyA1LCBuZGMgLSAxKTtcbiAgICAgICAgd2JpdHMob3V0LCBwICsgMTAsIG5sY2MgLSA0KTtcbiAgICAgICAgcCArPSAxNDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBubGNjOyArK2kpXG4gICAgICAgICAgICB3Yml0cyhvdXQsIHAgKyAzICogaSwgbGN0W2NsaW1baV1dKTtcbiAgICAgICAgcCArPSAzICogbmxjYztcbiAgICAgICAgdmFyIGxjdHMgPSBbbGNsdCwgbGNkdF07XG4gICAgICAgIGZvciAodmFyIGl0ID0gMDsgaXQgPCAyOyArK2l0KSB7XG4gICAgICAgICAgICB2YXIgY2xjdCA9IGxjdHNbaXRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGNsY3RbaV0gJiAzMTtcbiAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIGxsbVtsZW5dKSwgcCArPSBsY3RbbGVuXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMTUpXG4gICAgICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgKGNsY3RbaV0gPj4gNSkgJiAxMjcpLCBwICs9IGNsY3RbaV0gPj4gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxtID0gZmxtLCBsbCA9IGZsdCwgZG0gPSBmZG0sIGRsID0gZmR0O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpOyArK2kpIHtcbiAgICAgICAgdmFyIHN5bSA9IHN5bXNbaV07XG4gICAgICAgIGlmIChzeW0gPiAyNTUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSAoc3ltID4+IDE4KSAmIDMxO1xuICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIGxtW2xlbiArIDI1N10pLCBwICs9IGxsW2xlbiArIDI1N107XG4gICAgICAgICAgICBpZiAobGVuID4gNylcbiAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIChzeW0gPj4gMjMpICYgMzEpLCBwICs9IGZsZWJbbGVuXTtcbiAgICAgICAgICAgIHZhciBkc3QgPSBzeW0gJiAzMTtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBkbVtkc3RdKSwgcCArPSBkbFtkc3RdO1xuICAgICAgICAgICAgaWYgKGRzdCA+IDMpXG4gICAgICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIChzeW0gPj4gNSkgJiA4MTkxKSwgcCArPSBmZGViW2RzdF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3Yml0czE2KG91dCwgcCwgbG1bc3ltXSksIHAgKz0gbGxbc3ltXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3Yml0czE2KG91dCwgcCwgbG1bMjU2XSk7XG4gICAgcmV0dXJuIHAgKyBsbFsyNTZdO1xufTtcbi8vIGRlZmxhdGUgb3B0aW9ucyAobmljZSA8PCAxMykgfCBjaGFpblxudmFyIGRlbyA9IC8qI19fUFVSRV9fKi8gbmV3IGkzMihbNjU1NDAsIDEzMTA4MCwgMTMxMDg4LCAxMzExMDQsIDI2MjE3NiwgMTA0ODcwNCwgMTA0ODgzMiwgMjExNDU2MCwgMjExNzYzMl0pO1xuLy8gZW1wdHlcbnZhciBldCA9IC8qI19fUFVSRV9fKi8gbmV3IHU4KDApO1xuLy8gY29tcHJlc3NlcyBkYXRhIGludG8gYSByYXcgREVGTEFURSBidWZmZXJcbnZhciBkZmx0ID0gZnVuY3Rpb24gKGRhdCwgbHZsLCBwbHZsLCBwcmUsIHBvc3QsIHN0KSB7XG4gICAgdmFyIHMgPSBzdC56IHx8IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBuZXcgdTgocHJlICsgcyArIDUgKiAoMSArIE1hdGguY2VpbChzIC8gNzAwMCkpICsgcG9zdCk7XG4gICAgLy8gd3JpdGluZyB0byB0aGlzIHdyaXRlcyB0byB0aGUgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciB3ID0gby5zdWJhcnJheShwcmUsIG8ubGVuZ3RoIC0gcG9zdCk7XG4gICAgdmFyIGxzdCA9IHN0Lmw7XG4gICAgdmFyIHBvcyA9IChzdC5yIHx8IDApICYgNztcbiAgICBpZiAobHZsKSB7XG4gICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICB3WzBdID0gc3QuciA+PiAzO1xuICAgICAgICB2YXIgb3B0ID0gZGVvW2x2bCAtIDFdO1xuICAgICAgICB2YXIgbiA9IG9wdCA+PiAxMywgYyA9IG9wdCAmIDgxOTE7XG4gICAgICAgIHZhciBtc2tfMSA9ICgxIDw8IHBsdmwpIC0gMTtcbiAgICAgICAgLy8gICAgcHJldiAyLWJ5dGUgdmFsIG1hcCAgICBjdXJyIDItYnl0ZSB2YWwgbWFwXG4gICAgICAgIHZhciBwcmV2ID0gc3QucCB8fCBuZXcgdTE2KDMyNzY4KSwgaGVhZCA9IHN0LmggfHwgbmV3IHUxNihtc2tfMSArIDEpO1xuICAgICAgICB2YXIgYnMxXzEgPSBNYXRoLmNlaWwocGx2bCAvIDMpLCBiczJfMSA9IDIgKiBiczFfMTtcbiAgICAgICAgdmFyIGhzaCA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiAoZGF0W2ldIF4gKGRhdFtpICsgMV0gPDwgYnMxXzEpIF4gKGRhdFtpICsgMl0gPDwgYnMyXzEpKSAmIG1za18xOyB9O1xuICAgICAgICAvLyAyNDU3NiBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG1heGltdW0gc3ltYm9scyBwZXIgYmxvY2tcbiAgICAgICAgLy8gNDI0IGJ1ZmZlciBmb3IgbGFzdCBibG9ja1xuICAgICAgICB2YXIgc3ltcyA9IG5ldyBpMzIoMjUwMDApO1xuICAgICAgICAvLyBsZW5ndGgvbGl0ZXJhbCBmcmVxICAgZGlzdGFuY2UgZnJlcVxuICAgICAgICB2YXIgbGYgPSBuZXcgdTE2KDI4OCksIGRmID0gbmV3IHUxNigzMik7XG4gICAgICAgIC8vICBsL2xjbnQgIGV4Yml0cyAgaW5kZXggICAgICAgICAgbC9saW5kICB3YWl0ZHggICAgICAgICAgYmxrcG9zXG4gICAgICAgIHZhciBsY18xID0gMCwgZWIgPSAwLCBpID0gc3QuaSB8fCAwLCBsaSA9IDAsIHdpID0gc3QudyB8fCAwLCBicyA9IDA7XG4gICAgICAgIGZvciAoOyBpICsgMiA8IHM7ICsraSkge1xuICAgICAgICAgICAgLy8gaGFzaCB2YWx1ZVxuICAgICAgICAgICAgdmFyIGh2ID0gaHNoKGkpO1xuICAgICAgICAgICAgLy8gaW5kZXggbW9kIDMyNzY4ICAgIHByZXZpb3VzIGluZGV4IG1vZFxuICAgICAgICAgICAgdmFyIGltb2QgPSBpICYgMzI3NjcsIHBpbW9kID0gaGVhZFtodl07XG4gICAgICAgICAgICBwcmV2W2ltb2RdID0gcGltb2Q7XG4gICAgICAgICAgICBoZWFkW2h2XSA9IGltb2Q7XG4gICAgICAgICAgICAvLyBXZSBhbHdheXMgc2hvdWxkIG1vZGlmeSBoZWFkIGFuZCBwcmV2LCBidXQgb25seSBhZGQgc3ltYm9scyBpZlxuICAgICAgICAgICAgLy8gdGhpcyBkYXRhIGlzIG5vdCB5ZXQgcHJvY2Vzc2VkIChcIndhaXRcIiBmb3Igd2FpdCBpbmRleClcbiAgICAgICAgICAgIGlmICh3aSA8PSBpKSB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXMgcmVtYWluaW5nXG4gICAgICAgICAgICAgICAgdmFyIHJlbSA9IHMgLSBpO1xuICAgICAgICAgICAgICAgIGlmICgobGNfMSA+IDcwMDAgfHwgbGkgPiAyNDU3NikgJiYgKHJlbSA+IDQyMyB8fCAhbHN0KSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgMCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxpID0gbGNfMSA9IGViID0gMCwgYnMgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI4NjsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGZbal0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDMwOyArK2opXG4gICAgICAgICAgICAgICAgICAgICAgICBkZltqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICBsZW4gICAgZGlzdCAgIGNoYWluXG4gICAgICAgICAgICAgICAgdmFyIGwgPSAyLCBkID0gMCwgY2hfMSA9IGMsIGRpZiA9IGltb2QgLSBwaW1vZCAmIDMyNzY3O1xuICAgICAgICAgICAgICAgIGlmIChyZW0gPiAyICYmIGh2ID09IGhzaChpIC0gZGlmKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4biA9IE1hdGgubWluKG4sIHJlbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ZCA9IE1hdGgubWluKDMyNzY3LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF4IHBvc3NpYmxlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgY2FwcGVkIGF0IGRpZiBiZWNhdXNlIGRlY29tcHJlc3NvcnMgaW1wbGVtZW50IFwicm9sbGluZ1wiIGluZGV4IHBvcHVsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1sID0gTWF0aC5taW4oMjU4LCByZW0pO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGlmIDw9IG1heGQgJiYgLS1jaF8xICYmIGltb2QgIT0gcGltb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRbaSArIGxdID09IGRhdFtpICsgbCAtIGRpZl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBubCA8IG1sICYmIGRhdFtpICsgbmxdID09IGRhdFtpICsgbmwgLSBkaWZdOyArK25sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gbmwsIGQgPSBkaWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrIG91dCBlYXJseSB3aGVuIHdlIHJlYWNoIFwibmljZVwiICh3ZSBhcmUgc2F0aXNmaWVkIGVub3VnaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5sID4gbWF4bilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3csIGZpbmQgdGhlIHJhcmVzdCAyLWJ5dGUgc2VxdWVuY2Ugd2l0aGluIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxpdGVyYWxzIGFuZCBzZWFyY2ggZm9yIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVjaCBmYXN0ZXIgdGhhbiBqdXN0IHVzaW5nIHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW1kID0gTWF0aC5taW4oZGlmLCBubCAtIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1tZDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGkgPSBpIC0gZGlmICsgaiAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB0aSA9IHByZXZbdGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0gdGkgLSBwdGkgJiAzMjc2NztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZCA+IG1kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1kID0gY2QsIHBpbW9kID0gdGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgcHJldmlvdXMgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIGltb2QgPSBwaW1vZCwgcGltb2QgPSBwcmV2W2ltb2RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlmICs9IGltb2QgLSBwaW1vZCAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGQgd2lsbCBiZSBub256ZXJvIG9ubHkgd2hlbiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGJvdGggZGlzdCBhbmQgbGVuIGRhdGEgaW4gb25lIGludDMyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGlzIHJlY29nbml6ZWQgYXMgYSBsZW4vZGlzdCB3aXRoIDI4dGggYml0ICgyXjI4KVxuICAgICAgICAgICAgICAgICAgICBzeW1zW2xpKytdID0gMjY4NDM1NDU2IHwgKHJldmZsW2xdIDw8IDE4KSB8IHJldmZkW2RdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluID0gcmV2ZmxbbF0gJiAzMSwgZGluID0gcmV2ZmRbZF0gJiAzMTtcbiAgICAgICAgICAgICAgICAgICAgZWIgKz0gZmxlYltsaW5dICsgZmRlYltkaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2xmWzI1NyArIGxpbl07XG4gICAgICAgICAgICAgICAgICAgICsrZGZbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgd2kgPSBpICsgbDtcbiAgICAgICAgICAgICAgICAgICAgKytsY18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IGRhdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZltkYXRbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBNYXRoLm1heChpLCB3aSk7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIHN5bXNbbGkrK10gPSBkYXRbaV07XG4gICAgICAgICAgICArK2xmW2RhdFtpXV07XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gd2JsayhkYXQsIHcsIGxzdCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgIGlmICghbHN0KSB7XG4gICAgICAgICAgICBzdC5yID0gKHBvcyAmIDcpIHwgd1socG9zIC8gOCkgfCAwXSA8PCAzO1xuICAgICAgICAgICAgLy8gc2hmdChwb3MpIG5vdyAxIGxlc3MgaWYgcG9zICYgNyAhPSAwXG4gICAgICAgICAgICBwb3MgLT0gNztcbiAgICAgICAgICAgIHN0LmggPSBoZWFkLCBzdC5wID0gcHJldiwgc3QuaSA9IGksIHN0LncgPSB3aTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0LncgfHwgMDsgaSA8IHMgKyBsc3Q7IGkgKz0gNjU1MzUpIHtcbiAgICAgICAgICAgIC8vIGVuZFxuICAgICAgICAgICAgdmFyIGUgPSBpICsgNjU1MzU7XG4gICAgICAgICAgICBpZiAoZSA+PSBzKSB7XG4gICAgICAgICAgICAgICAgLy8gd3JpdGUgZmluYWwgYmxvY2tcbiAgICAgICAgICAgICAgICB3Wyhwb3MgLyA4KSB8IDBdID0gbHN0O1xuICAgICAgICAgICAgICAgIGUgPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zICsgMSwgZGF0LnN1YmFycmF5KGksIGUpKTtcbiAgICAgICAgfVxuICAgICAgICBzdC5pID0gcztcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhvLCAwLCBwcmUgKyBzaGZ0KHBvcykgKyBwb3N0KTtcbn07XG4vLyBDUkMzMiB0YWJsZVxudmFyIGNyY3QgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHQgPSBuZXcgSW50MzJBcnJheSgyNTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgdmFyIGMgPSBpLCBrID0gOTtcbiAgICAgICAgd2hpbGUgKC0taylcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxKSAmJiAtMzA2Njc0OTEyKSBeIChjID4+PiAxKTtcbiAgICAgICAgdFtpXSA9IGM7XG4gICAgfVxuICAgIHJldHVybiB0O1xufSkoKTtcbi8vIENSQzMyXG52YXIgY3JjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjID0gLTE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcDogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIC8vIGNsb3N1cmVzIGhhdmUgYXdmdWwgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIHZhciBjciA9IGM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY3IgPSBjcmN0WyhjciAmIDI1NSkgXiBkW2ldXSBeIChjciA+Pj4gOCk7XG4gICAgICAgICAgICBjID0gY3I7XG4gICAgICAgIH0sXG4gICAgICAgIGQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIH5jOyB9XG4gICAgfTtcbn07XG4vLyBBZGxlcjMyXG52YXIgYWRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSAxLCBiID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gY2xvc3VyZXMgaGF2ZSBhd2Z1bCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgdmFyIG4gPSBhLCBtID0gYjtcbiAgICAgICAgICAgIHZhciBsID0gZC5sZW5ndGggfCAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT0gbDspIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IE1hdGgubWluKGkgKyAyNjU1LCBsKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGU7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgbSArPSBuICs9IGRbaV07XG4gICAgICAgICAgICAgICAgbiA9IChuICYgNjU1MzUpICsgMTUgKiAobiA+PiAxNiksIG0gPSAobSAmIDY1NTM1KSArIDE1ICogKG0gPj4gMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IG4sIGIgPSBtO1xuICAgICAgICB9LFxuICAgICAgICBkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhICU9IDY1NTIxLCBiICU9IDY1NTIxO1xuICAgICAgICAgICAgcmV0dXJuIChhICYgMjU1KSA8PCAyNCB8IChhICYgMHhGRjAwKSA8PCA4IHwgKGIgJiAyNTUpIDw8IDggfCAoYiA+PiA4KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuO1xuLy8gZGVmbGF0ZSB3aXRoIG9wdHNcbnZhciBkb3B0ID0gZnVuY3Rpb24gKGRhdCwgb3B0LCBwcmUsIHBvc3QsIHN0KSB7XG4gICAgaWYgKCFzdCkge1xuICAgICAgICBzdCA9IHsgbDogMSB9O1xuICAgICAgICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAgICAgICAgIHZhciBkaWN0ID0gb3B0LmRpY3Rpb25hcnkuc3ViYXJyYXkoLTMyNzY4KTtcbiAgICAgICAgICAgIHZhciBuZXdEYXQgPSBuZXcgdTgoZGljdC5sZW5ndGggKyBkYXQubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0RhdC5zZXQoZGljdCk7XG4gICAgICAgICAgICBuZXdEYXQuc2V0KGRhdCwgZGljdC5sZW5ndGgpO1xuICAgICAgICAgICAgZGF0ID0gbmV3RGF0O1xuICAgICAgICAgICAgc3QudyA9IGRpY3QubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZmx0KGRhdCwgb3B0LmxldmVsID09IG51bGwgPyA2IDogb3B0LmxldmVsLCBvcHQubWVtID09IG51bGwgPyAoc3QubCA/IE1hdGguY2VpbChNYXRoLm1heCg4LCBNYXRoLm1pbigxMywgTWF0aC5sb2coZGF0Lmxlbmd0aCkpKSAqIDEuNSkgOiAyMCkgOiAoMTIgKyBvcHQubWVtKSwgcHJlLCBwb3N0LCBzdCk7XG59O1xuLy8gV2FsbWFydCBvYmplY3Qgc3ByZWFkXG52YXIgbXJnID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgbyA9IHt9O1xuICAgIGZvciAodmFyIGsgaW4gYSlcbiAgICAgICAgb1trXSA9IGFba107XG4gICAgZm9yICh2YXIgayBpbiBiKVxuICAgICAgICBvW2tdID0gYltrXTtcbiAgICByZXR1cm4gbztcbn07XG4vLyB3b3JrZXIgY2xvbmVcbi8vIFRoaXMgaXMgcG9zc2libHkgdGhlIGNyYXppZXN0IHBhcnQgb2YgdGhlIGVudGlyZSBjb2RlYmFzZSwgZGVzcGl0ZSBob3cgc2ltcGxlIGl0IG1heSBzZWVtLlxuLy8gVGhlIG9ubHkgcGFyYW1ldGVyIHRvIHRoaXMgZnVuY3Rpb24gaXMgYSBjbG9zdXJlIHRoYXQgcmV0dXJucyBhbiBhcnJheSBvZiB2YXJpYWJsZXMgb3V0c2lkZSBvZiB0aGUgZnVuY3Rpb24gc2NvcGUuXG4vLyBXZSdyZSBnb2luZyB0byB0cnkgdG8gZmlndXJlIG91dCB0aGUgdmFyaWFibGUgbmFtZXMgdXNlZCBpbiB0aGUgY2xvc3VyZSBhcyBzdHJpbmdzIGJlY2F1c2UgdGhhdCBpcyBjcnVjaWFsIGZvciB3b3JrZXJpemF0aW9uLlxuLy8gV2Ugd2lsbCByZXR1cm4gYW4gb2JqZWN0IG1hcHBpbmcgb2YgdHJ1ZSB2YXJpYWJsZSBuYW1lIHRvIHZhbHVlIChiYXNpY2FsbHksIHRoZSBjdXJyZW50IHNjb3BlIGFzIGEgSlMgb2JqZWN0KS5cbi8vIFRoZSByZWFzb24gd2UgY2FuJ3QganVzdCB1c2UgdGhlIG9yaWdpbmFsIHZhcmlhYmxlIG5hbWVzIGlzIG1pbmlmaWVycyBtYW5nbGluZyB0aGUgdG9wbGV2ZWwgc2NvcGUuXG4vLyBUaGlzIHRvb2sgbWUgdGhyZWUgd2Vla3MgdG8gZmlndXJlIG91dCBob3cgdG8gZG8uXG52YXIgd2NsbiA9IGZ1bmN0aW9uIChmbiwgZm5TdHIsIHRkKSB7XG4gICAgdmFyIGR0ID0gZm4oKTtcbiAgICB2YXIgc3QgPSBmbi50b1N0cmluZygpO1xuICAgIHZhciBrcyA9IHN0LnNsaWNlKHN0LmluZGV4T2YoJ1snKSArIDEsIHN0Lmxhc3RJbmRleE9mKCddJykpLnJlcGxhY2UoL1xccysvZywgJycpLnNwbGl0KCcsJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkdC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdiA9IGR0W2ldLCBrID0ga3NbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBmblN0ciArPSAnOycgKyBrICsgJz0nO1xuICAgICAgICAgICAgdmFyIHN0XzEgPSB2LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAodi5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgZ2xvYmFsIG9iamVjdHNcbiAgICAgICAgICAgICAgICBpZiAoc3RfMS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwSW5kID0gc3RfMS5pbmRleE9mKCcgJywgOCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xLnNsaWNlKHNwSW5kLCBzdF8xLmluZGV4T2YoJygnLCBzcEluZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCBpbiB2LnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuU3RyICs9ICc7JyArIGsgKyAnLnByb3RvdHlwZS4nICsgdCArICc9JyArIHYucHJvdG90eXBlW3RdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGRba10gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gZm5TdHI7XG59O1xudmFyIGNoID0gW107XG4vLyBjbG9uZSBidWZzXG52YXIgY2JmcyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIHRsID0gW107XG4gICAgZm9yICh2YXIgayBpbiB2KSB7XG4gICAgICAgIGlmICh2W2tdLmJ1ZmZlcikge1xuICAgICAgICAgICAgdGwucHVzaCgodltrXSA9IG5ldyB2W2tdLmNvbnN0cnVjdG9yKHZba10pKS5idWZmZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bDtcbn07XG4vLyB1c2UgYSB3b3JrZXIgdG8gZXhlY3V0ZSBjb2RlXG52YXIgd3JrciA9IGZ1bmN0aW9uIChmbnMsIGluaXQsIGlkLCBjYikge1xuICAgIGlmICghY2hbaWRdKSB7XG4gICAgICAgIHZhciBmblN0ciA9ICcnLCB0ZF8xID0ge30sIG0gPSBmbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpXG4gICAgICAgICAgICBmblN0ciA9IHdjbG4oZm5zW2ldLCBmblN0ciwgdGRfMSk7XG4gICAgICAgIGNoW2lkXSA9IHsgYzogd2NsbihmbnNbbV0sIGZuU3RyLCB0ZF8xKSwgZTogdGRfMSB9O1xuICAgIH1cbiAgICB2YXIgdGQgPSBtcmcoe30sIGNoW2lkXS5lKTtcbiAgICByZXR1cm4gKDAsIG5vZGVfd29ya2VyXzEuZGVmYXVsdCkoY2hbaWRdLmMgKyAnO29ubWVzc2FnZT1mdW5jdGlvbihlKXtmb3IodmFyIGsgaW4gZS5kYXRhKXNlbGZba109ZS5kYXRhW2tdO29ubWVzc2FnZT0nICsgaW5pdC50b1N0cmluZygpICsgJ30nLCBpZCwgdGQsIGNiZnModGQpLCBjYik7XG59O1xuLy8gYmFzZSBhc3luYyBpbmZsYXRlIGZuXG52YXIgYkluZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIGkzMiwgZmxlYiwgZmRlYiwgY2xpbSwgZmwsIGZkLCBmbHJtLCBmZHJtLCByZXYsIGVjLCBoTWFwLCBtYXgsIGJpdHMsIGJpdHMxNiwgc2hmdCwgc2xjLCBlcnIsIGluZmx0LCBpbmZsYXRlU3luYywgcGJmLCBnb3B0XTsgfTtcbnZhciBiRGZsdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt1OCwgdTE2LCBpMzIsIGZsZWIsIGZkZWIsIGNsaW0sIHJldmZsLCByZXZmZCwgZmxtLCBmbHQsIGZkbSwgZmR0LCByZXYsIGRlbywgZXQsIGhNYXAsIHdiaXRzLCB3Yml0czE2LCBoVHJlZSwgbG4sIGxjLCBjbGVuLCB3ZmJsaywgd2Jsaywgc2hmdCwgc2xjLCBkZmx0LCBkb3B0LCBkZWZsYXRlU3luYywgcGJmXTsgfTtcbi8vIGd6aXAgZXh0cmFcbnZhciBnemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3poLCBnemhsLCB3Ynl0ZXMsIGNyYywgY3JjdF07IH07XG4vLyBndW56aXAgZXh0cmFcbnZhciBndXplID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW2d6cywgZ3psXTsgfTtcbi8vIHpsaWIgZXh0cmFcbnZhciB6bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbemxoLCB3Ynl0ZXMsIGFkbGVyXTsgfTtcbi8vIHVuemxpYiBleHRyYVxudmFyIHp1bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbemxzXTsgfTtcbi8vIHBvc3QgYnVmXG52YXIgcGJmID0gZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gcG9zdE1lc3NhZ2UobXNnLCBbbXNnLmJ1ZmZlcl0pOyB9O1xuLy8gZ2V0IG9wdHNcbnZhciBnb3B0ID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYge1xuICAgIG91dDogby5zaXplICYmIG5ldyB1OChvLnNpemUpLFxuICAgIGRpY3Rpb25hcnk6IG8uZGljdGlvbmFyeVxufTsgfTtcbi8vIGFzeW5jIGhlbHBlclxudmFyIGNiaWZ5ID0gZnVuY3Rpb24gKGRhdCwgb3B0cywgZm5zLCBpbml0LCBpZCwgY2IpIHtcbiAgICB2YXIgdyA9IHdya3IoZm5zLCBpbml0LCBpZCwgZnVuY3Rpb24gKGVyciwgZGF0KSB7XG4gICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgIGNiKGVyciwgZGF0KTtcbiAgICB9KTtcbiAgICB3LnBvc3RNZXNzYWdlKFtkYXQsIG9wdHNdLCBvcHRzLmNvbnN1bWUgPyBbZGF0LmJ1ZmZlcl0gOiBbXSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdy50ZXJtaW5hdGUoKTsgfTtcbn07XG4vLyBhdXRvIHN0cmVhbVxudmFyIGFzdHJtID0gZnVuY3Rpb24gKHN0cm0pIHtcbiAgICBzdHJtLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7IHJldHVybiBwb3N0TWVzc2FnZShbZGF0LCBmaW5hbF0sIFtkYXQuYnVmZmVyXSk7IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoZXYuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cm0ucHVzaChldi5kYXRhWzBdLCBldi5kYXRhWzFdKTtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKFtldi5kYXRhWzBdLmxlbmd0aF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0cm0uZmx1c2goKTtcbiAgICB9O1xufTtcbi8vIGFzeW5jIHN0cmVhbSBhdHRhY2hcbnZhciBhc3RybWlmeSA9IGZ1bmN0aW9uIChmbnMsIHN0cm0sIG9wdHMsIGluaXQsIGlkLCBmbHVzaCwgZXh0KSB7XG4gICAgdmFyIHQ7XG4gICAgdmFyIHcgPSB3cmtyKGZucywgaW5pdCwgaWQsIGZ1bmN0aW9uIChlcnIsIGRhdCkge1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgdy50ZXJtaW5hdGUoKSwgc3RybS5vbmRhdGEuY2FsbChzdHJtLCBlcnIpO1xuICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShkYXQpKVxuICAgICAgICAgICAgZXh0KGRhdCk7XG4gICAgICAgIGVsc2UgaWYgKGRhdC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgc3RybS5xdWV1ZWRTaXplIC09IGRhdFswXTtcbiAgICAgICAgICAgIGlmIChzdHJtLm9uZHJhaW4pXG4gICAgICAgICAgICAgICAgc3RybS5vbmRyYWluKGRhdFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGF0WzFdKVxuICAgICAgICAgICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgICAgICBzdHJtLm9uZGF0YS5jYWxsKHN0cm0sIGVyciwgZGF0WzBdLCBkYXRbMV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShvcHRzKTtcbiAgICBzdHJtLnF1ZXVlZFNpemUgPSAwO1xuICAgIHN0cm0ucHVzaCA9IGZ1bmN0aW9uIChkLCBmKSB7XG4gICAgICAgIGlmICghc3RybS5vbmRhdGEpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIGlmICh0KVxuICAgICAgICAgICAgc3RybS5vbmRhdGEoZXJyKDQsIDAsIDEpLCBudWxsLCAhIWYpO1xuICAgICAgICBzdHJtLnF1ZXVlZFNpemUgKz0gZC5sZW5ndGg7XG4gICAgICAgIHcucG9zdE1lc3NhZ2UoW2QsIHQgPSBmXSwgW2QuYnVmZmVyXSk7XG4gICAgfTtcbiAgICBzdHJtLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uICgpIHsgdy50ZXJtaW5hdGUoKTsgfTtcbiAgICBpZiAoZmx1c2gpIHtcbiAgICAgICAgc3RybS5mbHVzaCA9IGZ1bmN0aW9uICgpIHsgdy5wb3N0TWVzc2FnZShbXSk7IH07XG4gICAgfVxufTtcbi8vIHJlYWQgMiBieXRlc1xudmFyIGIyID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIGRbYl0gfCAoZFtiICsgMV0gPDwgOCk7IH07XG4vLyByZWFkIDQgYnl0ZXNcbnZhciBiNCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiAoZFtiXSB8IChkW2IgKyAxXSA8PCA4KSB8IChkW2IgKyAyXSA8PCAxNikgfCAoZFtiICsgM10gPDwgMjQpKSA+Pj4gMDsgfTtcbnZhciBiOCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiNChkLCBiKSArIChiNChkLCBiICsgNCkgKiA0Mjk0OTY3Mjk2KTsgfTtcbi8vIHdyaXRlIGJ5dGVzXG52YXIgd2J5dGVzID0gZnVuY3Rpb24gKGQsIGIsIHYpIHtcbiAgICBmb3IgKDsgdjsgKytiKVxuICAgICAgICBkW2JdID0gdiwgdiA+Pj49IDg7XG59O1xuLy8gZ3ppcCBoZWFkZXJcbnZhciBnemggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBmbiA9IG8uZmlsZW5hbWU7XG4gICAgY1swXSA9IDMxLCBjWzFdID0gMTM5LCBjWzJdID0gOCwgY1s4XSA9IG8ubGV2ZWwgPCAyID8gNCA6IG8ubGV2ZWwgPT0gOSA/IDIgOiAwLCBjWzldID0gMzsgLy8gYXNzdW1lIFVuaXhcbiAgICBpZiAoby5tdGltZSAhPSAwKVxuICAgICAgICB3Ynl0ZXMoYywgNCwgTWF0aC5mbG9vcihuZXcgRGF0ZShvLm10aW1lIHx8IERhdGUubm93KCkpIC8gMTAwMCkpO1xuICAgIGlmIChmbikge1xuICAgICAgICBjWzNdID0gODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZm4ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBjW2kgKyAxMF0gPSBmbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbn07XG4vLyBnemlwIGZvb3RlcjogLTggdG8gLTQgPSBDUkMsIC00IHRvIC0wIGlzIGxlbmd0aFxuLy8gZ3ppcCBzdGFydFxudmFyIGd6cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGRbMF0gIT0gMzEgfHwgZFsxXSAhPSAxMzkgfHwgZFsyXSAhPSA4KVxuICAgICAgICBlcnIoNiwgJ2ludmFsaWQgZ3ppcCBkYXRhJyk7XG4gICAgdmFyIGZsZyA9IGRbM107XG4gICAgdmFyIHN0ID0gMTA7XG4gICAgaWYgKGZsZyAmIDQpXG4gICAgICAgIHN0ICs9IChkWzEwXSB8IGRbMTFdIDw8IDgpICsgMjtcbiAgICBmb3IgKHZhciB6cyA9IChmbGcgPj4gMyAmIDEpICsgKGZsZyA+PiA0ICYgMSk7IHpzID4gMDsgenMgLT0gIWRbc3QrK10pXG4gICAgICAgIDtcbiAgICByZXR1cm4gc3QgKyAoZmxnICYgMik7XG59O1xuLy8gZ3ppcCBsZW5ndGhcbnZhciBnemwgPSBmdW5jdGlvbiAoZCkge1xuICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgcmV0dXJuIChkW2wgLSA0XSB8IGRbbCAtIDNdIDw8IDggfCBkW2wgLSAyXSA8PCAxNiB8IGRbbCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn07XG4vLyBnemlwIGhlYWRlciBsZW5ndGhcbnZhciBnemhsID0gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIDEwICsgKG8uZmlsZW5hbWUgPyBvLmZpbGVuYW1lLmxlbmd0aCArIDEgOiAwKTsgfTtcbi8vIHpsaWIgaGVhZGVyXG52YXIgemxoID0gZnVuY3Rpb24gKGMsIG8pIHtcbiAgICB2YXIgbHYgPSBvLmxldmVsLCBmbCA9IGx2ID09IDAgPyAwIDogbHYgPCA2ID8gMSA6IGx2ID09IDkgPyAzIDogMjtcbiAgICBjWzBdID0gMTIwLCBjWzFdID0gKGZsIDw8IDYpIHwgKG8uZGljdGlvbmFyeSAmJiAzMik7XG4gICAgY1sxXSB8PSAzMSAtICgoY1swXSA8PCA4KSB8IGNbMV0pICUgMzE7XG4gICAgaWYgKG8uZGljdGlvbmFyeSkge1xuICAgICAgICB2YXIgaCA9IGFkbGVyKCk7XG4gICAgICAgIGgucChvLmRpY3Rpb25hcnkpO1xuICAgICAgICB3Ynl0ZXMoYywgMiwgaC5kKCkpO1xuICAgIH1cbn07XG4vLyB6bGliIHN0YXJ0XG52YXIgemxzID0gZnVuY3Rpb24gKGQsIGRpY3QpIHtcbiAgICBpZiAoKGRbMF0gJiAxNSkgIT0gOCB8fCAoZFswXSA+PiA0KSA+IDcgfHwgKChkWzBdIDw8IDggfCBkWzFdKSAlIDMxKSlcbiAgICAgICAgZXJyKDYsICdpbnZhbGlkIHpsaWIgZGF0YScpO1xuICAgIGlmICgoZFsxXSA+PiA1ICYgMSkgPT0gKyFkaWN0KVxuICAgICAgICBlcnIoNiwgJ2ludmFsaWQgemxpYiBkYXRhOiAnICsgKGRbMV0gJiAzMiA/ICduZWVkJyA6ICd1bmV4cGVjdGVkJykgKyAnIGRpY3Rpb25hcnknKTtcbiAgICByZXR1cm4gKGRbMV0gPj4gMyAmIDQpICsgMjtcbn07XG5mdW5jdGlvbiBTdHJtT3B0KG9wdHMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgcmV0dXJuIG9wdHM7XG59XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uXG4gKi9cbnZhciBEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlZmxhdGUob3B0cywgY2IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgdGhpcy5vID0gb3B0cyB8fCB7fTtcbiAgICAgICAgdGhpcy5zID0geyBsOiAwLCBpOiAzMjc2OCwgdzogMzI3NjgsIHo6IDMyNzY4IH07XG4gICAgICAgIC8vIEJ1ZmZlciBsZW5ndGggbXVzdCBhbHdheXMgYmUgMCBtb2QgMzI3NjggZm9yIGluZGV4IGNhbGN1bGF0aW9ucyB0byBiZSBjb3JyZWN0IHdoZW4gbW9kaWZ5aW5nIGhlYWQgYW5kIHByZXZcbiAgICAgICAgLy8gOTgzMDQgPSAzMjc2OCAobG9va2JhY2spICsgNjU1MzYgKGNvbW1vbiBjaHVuayBzaXplKVxuICAgICAgICB0aGlzLmIgPSBuZXcgdTgoOTgzMDQpO1xuICAgICAgICBpZiAodGhpcy5vLmRpY3Rpb25hcnkpIHtcbiAgICAgICAgICAgIHZhciBkaWN0ID0gdGhpcy5vLmRpY3Rpb25hcnkuc3ViYXJyYXkoLTMyNzY4KTtcbiAgICAgICAgICAgIHRoaXMuYi5zZXQoZGljdCwgMzI3NjggLSBkaWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnMuaSA9IDMyNzY4IC0gZGljdC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVmbGF0ZS5wcm90b3R5cGUucCA9IGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgIHRoaXMub25kYXRhKGRvcHQoYywgdGhpcy5vLCAwLCAwLCB0aGlzLnMpLCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIGlmICh0aGlzLnMubClcbiAgICAgICAgICAgIGVycig0KTtcbiAgICAgICAgdmFyIGVuZExlbiA9IGNodW5rLmxlbmd0aCArIHRoaXMucy56O1xuICAgICAgICBpZiAoZW5kTGVuID4gdGhpcy5iLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGVuZExlbiA+IDIgKiB0aGlzLmIubGVuZ3RoIC0gMzI3NjgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QnVmID0gbmV3IHU4KGVuZExlbiAmIC0zMjc2OCk7XG4gICAgICAgICAgICAgICAgbmV3QnVmLnNldCh0aGlzLmIuc3ViYXJyYXkoMCwgdGhpcy5zLnopKTtcbiAgICAgICAgICAgICAgICB0aGlzLmIgPSBuZXdCdWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3BsaXQgPSB0aGlzLmIubGVuZ3RoIC0gdGhpcy5zLno7XG4gICAgICAgICAgICB0aGlzLmIuc2V0KGNodW5rLnN1YmFycmF5KDAsIHNwbGl0KSwgdGhpcy5zLnopO1xuICAgICAgICAgICAgdGhpcy5zLnogPSB0aGlzLmIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5wKHRoaXMuYiwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5iLnNldCh0aGlzLmIuc3ViYXJyYXkoLTMyNzY4KSk7XG4gICAgICAgICAgICB0aGlzLmIuc2V0KGNodW5rLnN1YmFycmF5KHNwbGl0KSwgMzI3NjgpO1xuICAgICAgICAgICAgdGhpcy5zLnogPSBjaHVuay5sZW5ndGggLSBzcGxpdCArIDMyNzY4O1xuICAgICAgICAgICAgdGhpcy5zLmkgPSAzMjc2NiwgdGhpcy5zLncgPSAzMjc2ODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYi5zZXQoY2h1bmssIHRoaXMucy56KTtcbiAgICAgICAgICAgIHRoaXMucy56ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnMubCA9IGZpbmFsICYgMTtcbiAgICAgICAgaWYgKHRoaXMucy56ID4gdGhpcy5zLncgKyA4MTkxIHx8IGZpbmFsKSB7XG4gICAgICAgICAgICB0aGlzLnAodGhpcy5iLCBmaW5hbCB8fCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnMudyA9IHRoaXMucy5pLCB0aGlzLnMuaSAtPSAyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGJ1ZmZlcmVkIHVuY29tcHJlc3NlZCBkYXRhLiBVc2VmdWwgdG8gaW1tZWRpYXRlbHkgcmV0cmlldmUgdGhlXG4gICAgICogZGVmbGF0ZWQgb3V0cHV0IGZvciBzbWFsbCBpbnB1dHMuXG4gICAgICovXG4gICAgRGVmbGF0ZS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIGlmICh0aGlzLnMubClcbiAgICAgICAgICAgIGVycig0KTtcbiAgICAgICAgdGhpcy5wKHRoaXMuYiwgZmFsc2UpO1xuICAgICAgICB0aGlzLnMudyA9IHRoaXMucy5pLCB0aGlzLnMuaSAtPSAyO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmxhdGU7XG59KCkpO1xuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY0RlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNEZWZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJEZmx0LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBEZWZsYXRlXTsgfVxuICAgICAgICBdLCB0aGlzLCBTdHJtT3B0LmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IERlZmxhdGUoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNiwgMSk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0RlZmxhdGU7XG59KCkpO1xuZXhwb3J0cy5Bc3luY0RlZmxhdGUgPSBBc3luY0RlZmxhdGU7XG5mdW5jdGlvbiBkZWZsYXRlKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkRmbHQsXG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZGVmbGF0ZVN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCAwLCBjYik7XG59XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuLyoqXG4gKiBDb21wcmVzc2VzIGRhdGEgd2l0aCBERUZMQVRFIHdpdGhvdXQgYW55IHdyYXBwZXJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGRlZmxhdGVkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVN5bmMoZGF0YSwgb3B0cykge1xuICAgIHJldHVybiBkb3B0KGRhdGEsIG9wdHMgfHwge30sIDAsIDApO1xufVxuZXhwb3J0cy5kZWZsYXRlU3luYyA9IGRlZmxhdGVTeW5jO1xuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uXG4gKi9cbnZhciBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluZmxhdGUob3B0cywgY2IpIHtcbiAgICAgICAgLy8gbm8gU3RybU9wdCBoZXJlIHRvIGF2b2lkIGFkZGluZyB0byB3b3JrZXJpemVyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIHZhciBkaWN0ID0gb3B0cyAmJiBvcHRzLmRpY3Rpb25hcnkgJiYgb3B0cy5kaWN0aW9uYXJ5LnN1YmFycmF5KC0zMjc2OCk7XG4gICAgICAgIHRoaXMucyA9IHsgaTogMCwgYjogZGljdCA/IGRpY3QubGVuZ3RoIDogMCB9O1xuICAgICAgICB0aGlzLm8gPSBuZXcgdTgoMzI3NjgpO1xuICAgICAgICB0aGlzLnAgPSBuZXcgdTgoMCk7XG4gICAgICAgIGlmIChkaWN0KVxuICAgICAgICAgICAgdGhpcy5vLnNldChkaWN0KTtcbiAgICB9XG4gICAgSW5mbGF0ZS5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICBlcnIoNCk7XG4gICAgICAgIGlmICghdGhpcy5wLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMucCA9IGM7XG4gICAgICAgIGVsc2UgaWYgKGMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG5ldyB1OCh0aGlzLnAubGVuZ3RoICsgYy5sZW5ndGgpO1xuICAgICAgICAgICAgbi5zZXQodGhpcy5wKSwgbi5zZXQoYywgdGhpcy5wLmxlbmd0aCksIHRoaXMucCA9IG47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZmxhdGUucHJvdG90eXBlLmMgPSBmdW5jdGlvbiAoZmluYWwpIHtcbiAgICAgICAgdGhpcy5zLmkgPSArKHRoaXMuZCA9IGZpbmFsIHx8IGZhbHNlKTtcbiAgICAgICAgdmFyIGJ0cyA9IHRoaXMucy5iO1xuICAgICAgICB2YXIgZHQgPSBpbmZsdCh0aGlzLnAsIHRoaXMucywgdGhpcy5vKTtcbiAgICAgICAgdGhpcy5vbmRhdGEoc2xjKGR0LCBidHMsIHRoaXMucy5iKSwgdGhpcy5kKTtcbiAgICAgICAgdGhpcy5vID0gc2xjKGR0LCB0aGlzLnMuYiAtIDMyNzY4KSwgdGhpcy5zLmIgPSB0aGlzLm8ubGVuZ3RoO1xuICAgICAgICB0aGlzLnAgPSBzbGModGhpcy5wLCAodGhpcy5zLnAgLyA4KSB8IDApLCB0aGlzLnMucCAmPSA3O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgaW5mbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBmaW5hbCBjaHVua1xuICAgICAqL1xuICAgIEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMuZShjaHVuayksIHRoaXMuYyhmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jSW5mbGF0ZShvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiSW5mbHQsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGVdOyB9XG4gICAgICAgIF0sIHRoaXMsIFN0cm1PcHQuY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgSW5mbGF0ZShldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCA3LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnRzLkFzeW5jSW5mbGF0ZSA9IEFzeW5jSW5mbGF0ZTtcbmZ1bmN0aW9uIGluZmxhdGUoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIGVycig3KTtcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHRcbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihpbmZsYXRlU3luYyhldi5kYXRhWzBdLCBnb3B0KGV2LmRhdGFbMV0pKSk7IH0sIDEsIGNiKTtcbn1cbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG4vKipcbiAqIEV4cGFuZHMgREVGTEFURSBkYXRhIHdpdGggbm8gd3JhcHBlclxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGRlY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gaW5mbHQoZGF0YSwgeyBpOiAyIH0sIG9wdHMgJiYgb3B0cy5vdXQsIG9wdHMgJiYgb3B0cy5kaWN0aW9uYXJ5KTtcbn1cbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbi8vIGJlZm9yZSB5b3UgeWVsbCBhdCBtZSBmb3Igbm90IGp1c3QgdXNpbmcgZXh0ZW5kcywgbXkgcmVhc29uIGlzIHRoYXQgVFMgaW5oZXJpdGFuY2UgaXMgaGFyZCB0byB3b3JrZXJpemUuXG4vKipcbiAqIFN0cmVhbWluZyBHWklQIGNvbXByZXNzaW9uXG4gKi9cbnZhciBHemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEd6aXAob3B0cywgY2IpIHtcbiAgICAgICAgdGhpcy5jID0gY3JjKCk7XG4gICAgICAgIHRoaXMubCA9IDA7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIERlZmxhdGUuY2FsbCh0aGlzLCBvcHRzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIEdaSVBwZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgR3ppcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5jLnAoY2h1bmspO1xuICAgICAgICB0aGlzLmwgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIEd6aXAucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB2YXIgcmF3ID0gZG9wdChjLCB0aGlzLm8sIHRoaXMudiAmJiBnemhsKHRoaXMubyksIGYgJiYgOCwgdGhpcy5zKTtcbiAgICAgICAgaWYgKHRoaXMudilcbiAgICAgICAgICAgIGd6aChyYXcsIHRoaXMubyksIHRoaXMudiA9IDA7XG4gICAgICAgIGlmIChmKVxuICAgICAgICAgICAgd2J5dGVzKHJhdywgcmF3Lmxlbmd0aCAtIDgsIHRoaXMuYy5kKCkpLCB3Ynl0ZXMocmF3LCByYXcubGVuZ3RoIC0gNCwgdGhpcy5sKTtcbiAgICAgICAgdGhpcy5vbmRhdGEocmF3LCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgYnVmZmVyZWQgdW5jb21wcmVzc2VkIGRhdGEuIFVzZWZ1bCB0byBpbW1lZGlhdGVseSByZXRyaWV2ZSB0aGVcbiAgICAgKiBHWklQcGVkIG91dHB1dCBmb3Igc21hbGwgaW5wdXRzLlxuICAgICAqL1xuICAgIEd6aXAucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5mbHVzaC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEd6aXA7XG59KCkpO1xuZXhwb3J0cy5HemlwID0gR3ppcDtcbmV4cG9ydHMuQ29tcHJlc3MgPSBHemlwO1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIEdaSVAgY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jR3ppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3luY0d6aXAob3B0cywgY2IpIHtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkRmbHQsXG4gICAgICAgICAgICBnemUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIERlZmxhdGUsIEd6aXBdOyB9XG4gICAgICAgIF0sIHRoaXMsIFN0cm1PcHQuY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgR3ppcChldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCA4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jR3ppcDtcbn0oKSk7XG5leHBvcnRzLkFzeW5jR3ppcCA9IEFzeW5jR3ppcDtcbmV4cG9ydHMuQXN5bmNDb21wcmVzcyA9IEFzeW5jR3ppcDtcbmZ1bmN0aW9uIGd6aXAoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIGVycig3KTtcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICAgICAgZ3plLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3ppcFN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZ3ppcFN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCAyLCBjYik7XG59XG5leHBvcnRzLmd6aXAgPSBnemlwO1xuZXhwb3J0cy5jb21wcmVzcyA9IGd6aXA7XG4vKipcbiAqIENvbXByZXNzZXMgZGF0YSB3aXRoIEdaSVBcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGd6aXBwZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5mdW5jdGlvbiBnemlwU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKVxuICAgICAgICBvcHRzID0ge307XG4gICAgdmFyIGMgPSBjcmMoKSwgbCA9IGRhdGEubGVuZ3RoO1xuICAgIGMucChkYXRhKTtcbiAgICB2YXIgZCA9IGRvcHQoZGF0YSwgb3B0cywgZ3pobChvcHRzKSwgOCksIHMgPSBkLmxlbmd0aDtcbiAgICByZXR1cm4gZ3poKGQsIG9wdHMpLCB3Ynl0ZXMoZCwgcyAtIDgsIGMuZCgpKSwgd2J5dGVzKGQsIHMgLSA0LCBsKSwgZDtcbn1cbmV4cG9ydHMuZ3ppcFN5bmMgPSBnemlwU3luYztcbmV4cG9ydHMuY29tcHJlc3NTeW5jID0gZ3ppcFN5bmM7XG4vKipcbiAqIFN0cmVhbWluZyBzaW5nbGUgb3IgbXVsdGktbWVtYmVyIEdaSVAgZGVjb21wcmVzc2lvblxuICovXG52YXIgR3VuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEd1bnppcChvcHRzLCBjYikge1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICB0aGlzLnIgPSAwO1xuICAgICAgICBJbmZsYXRlLmNhbGwodGhpcywgb3B0cywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBHVU5aSVBwZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgR3VuemlwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5lLmNhbGwodGhpcywgY2h1bmspO1xuICAgICAgICB0aGlzLnIgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy52KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucC5zdWJhcnJheSh0aGlzLnYgLSAxKTtcbiAgICAgICAgICAgIHZhciBzID0gcC5sZW5ndGggPiAzID8gZ3pzKHApIDogNDtcbiAgICAgICAgICAgIGlmIChzID4gcC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbmFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnYgPiAxICYmIHRoaXMub25tZW1iZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubWVtYmVyKHRoaXMuciAtIHAubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucCA9IHAuc3ViYXJyYXkocyksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVjZXNzYXJ5IHRvIHByZXZlbnQgVFMgZnJvbSB1c2luZyB0aGUgY2xvc3VyZSB2YWx1ZVxuICAgICAgICAvLyBUaGlzIGFsbG93cyBmb3Igd29ya2VyaXphdGlvbiB0byBmdW5jdGlvbiBjb3JyZWN0bHlcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuYy5jYWxsKHRoaXMsIGZpbmFsKTtcbiAgICAgICAgLy8gcHJvY2VzcyBjb25jYXRlbmF0ZWQgR1pJUFxuICAgICAgICBpZiAodGhpcy5zLmYgJiYgIXRoaXMucy5sICYmICFmaW5hbCkge1xuICAgICAgICAgICAgdGhpcy52ID0gc2hmdCh0aGlzLnMucCkgKyA5O1xuICAgICAgICAgICAgdGhpcy5zID0geyBpOiAwIH07XG4gICAgICAgICAgICB0aGlzLm8gPSBuZXcgdTgoMCk7XG4gICAgICAgICAgICB0aGlzLnB1c2gobmV3IHU4KDApLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHdW56aXA7XG59KCkpO1xuZXhwb3J0cy5HdW56aXAgPSBHdW56aXA7XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgc2luZ2xlIG9yIG11bHRpLW1lbWJlciBHWklQIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jR3VuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jR3VuemlwKG9wdHMsIGNiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIGd1emUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIEd1bnppcF07IH1cbiAgICAgICAgXSwgdGhpcywgU3RybU9wdC5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBHdW56aXAoZXYuZGF0YSk7XG4gICAgICAgICAgICBzdHJtLm9ubWVtYmVyID0gZnVuY3Rpb24gKG9mZnNldCkgeyByZXR1cm4gcG9zdE1lc3NhZ2Uob2Zmc2V0KTsgfTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCA5LCAwLCBmdW5jdGlvbiAob2Zmc2V0KSB7IHJldHVybiBfdGhpcy5vbm1lbWJlciAmJiBfdGhpcy5vbm1lbWJlcihvZmZzZXQpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jR3VuemlwO1xufSgpKTtcbmV4cG9ydHMuQXN5bmNHdW56aXAgPSBBc3luY0d1bnppcDtcbmZ1bmN0aW9uIGd1bnppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJJbmZsdCxcbiAgICAgICAgZ3V6ZSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2d1bnppcFN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZ3VuemlwU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDMsIGNiKTtcbn1cbmV4cG9ydHMuZ3VuemlwID0gZ3VuemlwO1xuLyoqXG4gKiBFeHBhbmRzIEdaSVAgZGF0YVxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGRlY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGd1bnppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIHZhciBzdCA9IGd6cyhkYXRhKTtcbiAgICBpZiAoc3QgKyA4ID4gZGF0YS5sZW5ndGgpXG4gICAgICAgIGVycig2LCAnaW52YWxpZCBnemlwIGRhdGEnKTtcbiAgICByZXR1cm4gaW5mbHQoZGF0YS5zdWJhcnJheShzdCwgLTgpLCB7IGk6IDIgfSwgb3B0cyAmJiBvcHRzLm91dCB8fCBuZXcgdTgoZ3psKGRhdGEpKSwgb3B0cyAmJiBvcHRzLmRpY3Rpb25hcnkpO1xufVxuZXhwb3J0cy5ndW56aXBTeW5jID0gZ3VuemlwU3luYztcbi8qKlxuICogU3RyZWFtaW5nIFpsaWIgY29tcHJlc3Npb25cbiAqL1xudmFyIFpsaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWmxpYihvcHRzLCBjYikge1xuICAgICAgICB0aGlzLmMgPSBhZGxlcigpO1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICBEZWZsYXRlLmNhbGwodGhpcywgb3B0cywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSB6bGliYmVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFpsaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMuYy5wKGNodW5rKTtcbiAgICAgICAgRGVmbGF0ZS5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICBabGliLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdmFyIHJhdyA9IGRvcHQoYywgdGhpcy5vLCB0aGlzLnYgJiYgKHRoaXMuby5kaWN0aW9uYXJ5ID8gNiA6IDIpLCBmICYmIDQsIHRoaXMucyk7XG4gICAgICAgIGlmICh0aGlzLnYpXG4gICAgICAgICAgICB6bGgocmF3LCB0aGlzLm8pLCB0aGlzLnYgPSAwO1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA0LCB0aGlzLmMuZCgpKTtcbiAgICAgICAgdGhpcy5vbmRhdGEocmF3LCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgYnVmZmVyZWQgdW5jb21wcmVzc2VkIGRhdGEuIFVzZWZ1bCB0byBpbW1lZGlhdGVseSByZXRyaWV2ZSB0aGVcbiAgICAgKiB6bGliYmVkIG91dHB1dCBmb3Igc21hbGwgaW5wdXRzLlxuICAgICAqL1xuICAgIFpsaWIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5mbHVzaC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFpsaWI7XG59KCkpO1xuZXhwb3J0cy5abGliID0gWmxpYjtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY1psaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNabGliKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJEZmx0LFxuICAgICAgICAgICAgemxlLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBEZWZsYXRlLCBabGliXTsgfVxuICAgICAgICBdLCB0aGlzLCBTdHJtT3B0LmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IFpsaWIoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgMTAsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNabGliO1xufSgpKTtcbmV4cG9ydHMuQXN5bmNabGliID0gQXN5bmNabGliO1xuZnVuY3Rpb24gemxpYihkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHJldHVybiBjYmlmeShkYXRhLCBvcHRzLCBbXG4gICAgICAgIGJEZmx0LFxuICAgICAgICB6bGUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bGliU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZih6bGliU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDQsIGNiKTtcbn1cbmV4cG9ydHMuemxpYiA9IHpsaWI7XG4vKipcbiAqIENvbXByZXNzIGRhdGEgd2l0aCBabGliXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSB6bGliLWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5mdW5jdGlvbiB6bGliU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKVxuICAgICAgICBvcHRzID0ge307XG4gICAgdmFyIGEgPSBhZGxlcigpO1xuICAgIGEucChkYXRhKTtcbiAgICB2YXIgZCA9IGRvcHQoZGF0YSwgb3B0cywgb3B0cy5kaWN0aW9uYXJ5ID8gNiA6IDIsIDQpO1xuICAgIHJldHVybiB6bGgoZCwgb3B0cyksIHdieXRlcyhkLCBkLmxlbmd0aCAtIDQsIGEuZCgpKSwgZDtcbn1cbmV4cG9ydHMuemxpYlN5bmMgPSB6bGliU3luYztcbi8qKlxuICogU3RyZWFtaW5nIFpsaWIgZGVjb21wcmVzc2lvblxuICovXG52YXIgVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuemxpYihvcHRzLCBjYikge1xuICAgICAgICBJbmZsYXRlLmNhbGwodGhpcywgb3B0cywgY2IpO1xuICAgICAgICB0aGlzLnYgPSBvcHRzICYmIG9wdHMuZGljdGlvbmFyeSA/IDIgOiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSB1bnpsaWJiZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgVW56bGliLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5lLmNhbGwodGhpcywgY2h1bmspO1xuICAgICAgICBpZiAodGhpcy52KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDYgJiYgIWZpbmFsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucCA9IHRoaXMucC5zdWJhcnJheSh6bHModGhpcy5wLCB0aGlzLnYgLSAxKSksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDQpXG4gICAgICAgICAgICAgICAgZXJyKDYsICdpbnZhbGlkIHpsaWIgZGF0YScpO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDAsIC00KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFVuemxpYjtcbn0oKSk7XG5leHBvcnRzLlVuemxpYiA9IFVuemxpYjtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jVW56bGliKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIHp1bGUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIFVuemxpYl07IH1cbiAgICAgICAgXSwgdGhpcywgU3RybU9wdC5jYWxsKHRoaXMsIG9wdHMsIGNiKSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBVbnpsaWIoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgMTEsIDApO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNVbnpsaWI7XG59KCkpO1xuZXhwb3J0cy5Bc3luY1VuemxpYiA9IEFzeW5jVW56bGliO1xuZnVuY3Rpb24gdW56bGliKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0LFxuICAgICAgICB6dWxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbdW56bGliU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZih1bnpsaWJTeW5jKGV2LmRhdGFbMF0sIGdvcHQoZXYuZGF0YVsxXSkpKTsgfSwgNSwgY2IpO1xufVxuZXhwb3J0cy51bnpsaWIgPSB1bnpsaWI7XG4vKipcbiAqIEV4cGFuZHMgWmxpYiBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgZGVjb21wcmVzc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZnVuY3Rpb24gdW56bGliU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEuc3ViYXJyYXkoemxzKGRhdGEsIG9wdHMgJiYgb3B0cy5kaWN0aW9uYXJ5KSwgLTQpLCB7IGk6IDIgfSwgb3B0cyAmJiBvcHRzLm91dCwgb3B0cyAmJiBvcHRzLmRpY3Rpb25hcnkpO1xufVxuZXhwb3J0cy51bnpsaWJTeW5jID0gdW56bGliU3luYztcbi8qKlxuICogU3RyZWFtaW5nIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIERlY29tcHJlc3MgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVjb21wcmVzcyhvcHRzLCBjYikge1xuICAgICAgICB0aGlzLm8gPSBTdHJtT3B0LmNhbGwodGhpcywgb3B0cywgY2IpIHx8IHt9O1xuICAgICAgICB0aGlzLkcgPSBHdW56aXA7XG4gICAgICAgIHRoaXMuSSA9IEluZmxhdGU7XG4gICAgICAgIHRoaXMuWiA9IFVuemxpYjtcbiAgICB9XG4gICAgLy8gaW5pdCBzdWJzdHJlYW1cbiAgICAvLyBvdmVycmlkZW4gYnkgQXN5bmNEZWNvbXByZXNzXG4gICAgRGVjb21wcmVzcy5wcm90b3R5cGUuaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zLm9uZGF0YSA9IGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpcy5vbmRhdGEoZGF0LCBmaW5hbCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvbXByZXNzZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRGVjb21wcmVzcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgaWYgKCF0aGlzLnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAgJiYgdGhpcy5wLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG4uc2V0KHRoaXMucCksIG4uc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBjaHVuaztcbiAgICAgICAgICAgIGlmICh0aGlzLnAubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRoaXMucyA9ICh0aGlzLnBbMF0gPT0gMzEgJiYgdGhpcy5wWzFdID09IDEzOSAmJiB0aGlzLnBbMl0gPT0gOClcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgdGhpcy5HKHRoaXMubylcbiAgICAgICAgICAgICAgICAgICAgOiAoKHRoaXMucFswXSAmIDE1KSAhPSA4IHx8ICh0aGlzLnBbMF0gPj4gNCkgPiA3IHx8ICgodGhpcy5wWzBdIDw8IDggfCB0aGlzLnBbMV0pICUgMzEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgdGhpcy5JKHRoaXMubylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IHRoaXMuWih0aGlzLm8pO1xuICAgICAgICAgICAgICAgIHRoaXMuaSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucy5wdXNoKHRoaXMucCwgZmluYWwpO1xuICAgICAgICAgICAgICAgIHRoaXMucCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zLnB1c2goY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNvbXByZXNzO1xufSgpKTtcbmV4cG9ydHMuRGVjb21wcmVzcyA9IERlY29tcHJlc3M7XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNEZWNvbXByZXNzID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jRGVjb21wcmVzcyhvcHRzLCBjYikge1xuICAgICAgICBEZWNvbXByZXNzLmNhbGwodGhpcywgb3B0cywgY2IpO1xuICAgICAgICB0aGlzLnF1ZXVlZFNpemUgPSAwO1xuICAgICAgICB0aGlzLkcgPSBBc3luY0d1bnppcDtcbiAgICAgICAgdGhpcy5JID0gQXN5bmNJbmZsYXRlO1xuICAgICAgICB0aGlzLlogPSBBc3luY1VuemxpYjtcbiAgICB9XG4gICAgQXN5bmNEZWNvbXByZXNzLnByb3RvdHlwZS5pID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnMub25kYXRhID0gZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgX3RoaXMub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucy5vbmRyYWluID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgICAgIF90aGlzLnF1ZXVlZFNpemUgLT0gc2l6ZTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vbmRyYWluKVxuICAgICAgICAgICAgICAgIF90aGlzLm9uZHJhaW4oc2l6ZSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvbXByZXNzZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgQXN5bmNEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLnF1ZXVlZFNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY0RlY29tcHJlc3M7XG59KCkpO1xuZXhwb3J0cy5Bc3luY0RlY29tcHJlc3MgPSBBc3luY0RlY29tcHJlc3M7XG5mdW5jdGlvbiBkZWNvbXByZXNzKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICBlcnIoNyk7XG4gICAgcmV0dXJuIChkYXRhWzBdID09IDMxICYmIGRhdGFbMV0gPT0gMTM5ICYmIGRhdGFbMl0gPT0gOClcbiAgICAgICAgPyBndW56aXAoZGF0YSwgb3B0cywgY2IpXG4gICAgICAgIDogKChkYXRhWzBdICYgMTUpICE9IDggfHwgKGRhdGFbMF0gPj4gNCkgPiA3IHx8ICgoZGF0YVswXSA8PCA4IHwgZGF0YVsxXSkgJSAzMSkpXG4gICAgICAgICAgICA/IGluZmxhdGUoZGF0YSwgb3B0cywgY2IpXG4gICAgICAgICAgICA6IHVuemxpYihkYXRhLCBvcHRzLCBjYik7XG59XG5leHBvcnRzLmRlY29tcHJlc3MgPSBkZWNvbXByZXNzO1xuLyoqXG4gKiBFeHBhbmRzIGNvbXByZXNzZWQgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGF0YSwgYXV0b21hdGljYWxseSBkZXRlY3RpbmcgdGhlIGZvcm1hdFxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGRlY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGRlY29tcHJlc3NTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICByZXR1cm4gKGRhdGFbMF0gPT0gMzEgJiYgZGF0YVsxXSA9PSAxMzkgJiYgZGF0YVsyXSA9PSA4KVxuICAgICAgICA/IGd1bnppcFN5bmMoZGF0YSwgb3B0cylcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZVN5bmMoZGF0YSwgb3B0cylcbiAgICAgICAgICAgIDogdW56bGliU3luYyhkYXRhLCBvcHRzKTtcbn1cbmV4cG9ydHMuZGVjb21wcmVzc1N5bmMgPSBkZWNvbXByZXNzU3luYztcbi8vIGZsYXR0ZW4gYSBkaXJlY3Rvcnkgc3RydWN0dXJlXG52YXIgZmx0biA9IGZ1bmN0aW9uIChkLCBwLCB0LCBvKSB7XG4gICAgZm9yICh2YXIgayBpbiBkKSB7XG4gICAgICAgIHZhciB2YWwgPSBkW2tdLCBuID0gcCArIGssIG9wID0gbztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSlcbiAgICAgICAgICAgIG9wID0gbXJnKG8sIHZhbFsxXSksIHZhbCA9IHZhbFswXTtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIHU4KVxuICAgICAgICAgICAgdFtuXSA9IFt2YWwsIG9wXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0W24gKz0gJy8nXSA9IFtuZXcgdTgoMCksIG9wXTtcbiAgICAgICAgICAgIGZsdG4odmFsLCBuLCB0LCBvKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyB0ZXh0IGVuY29kZXJcbnZhciB0ZSA9IHR5cGVvZiBUZXh0RW5jb2RlciAhPSAndW5kZWZpbmVkJyAmJiAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RW5jb2RlcigpO1xuLy8gdGV4dCBkZWNvZGVyXG52YXIgdGQgPSB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgJiYgLyojX19QVVJFX18qLyBuZXcgVGV4dERlY29kZXIoKTtcbi8vIHRleHQgZGVjb2RlciBzdHJlYW1cbnZhciB0ZHMgPSAwO1xudHJ5IHtcbiAgICB0ZC5kZWNvZGUoZXQsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIHRkcyA9IDE7XG59XG5jYXRjaCAoZSkgeyB9XG4vLyBkZWNvZGUgVVRGOFxudmFyIGR1dGY4ID0gZnVuY3Rpb24gKGQpIHtcbiAgICBmb3IgKHZhciByID0gJycsIGkgPSAwOzspIHtcbiAgICAgICAgdmFyIGMgPSBkW2krK107XG4gICAgICAgIHZhciBlYiA9IChjID4gMTI3KSArIChjID4gMjIzKSArIChjID4gMjM5KTtcbiAgICAgICAgaWYgKGkgKyBlYiA+IGQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHsgczogciwgcjogc2xjKGQsIGkgLSAxKSB9O1xuICAgICAgICBpZiAoIWViKVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICBlbHNlIGlmIChlYiA9PSAzKSB7XG4gICAgICAgICAgICBjID0gKChjICYgMTUpIDw8IDE4IHwgKGRbaSsrXSAmIDYzKSA8PCAxMiB8IChkW2krK10gJiA2MykgPDwgNiB8IChkW2krK10gJiA2MykpIC0gNjU1MzYsXG4gICAgICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgKGMgPj4gMTApLCA1NjMyMCB8IChjICYgMTAyMykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGViICYgMSlcbiAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDMxKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChkW2krK10gJiA2MykgPDwgNiB8IChkW2krK10gJiA2MykpO1xuICAgIH1cbn07XG4vKipcbiAqIFN0cmVhbWluZyBVVEYtOCBkZWNvZGluZ1xuICovXG52YXIgRGVjb2RlVVRGOCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVVRGLTggZGVjb2Rpbmcgc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVjb2RlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY29kZVVURjgoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgaWYgKHRkcylcbiAgICAgICAgICAgIHRoaXMudCA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnAgPSBldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVjb2RlZCBmcm9tIFVURi04IGJpbmFyeVxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWNvZGVVVEY4LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICBmaW5hbCA9ICEhZmluYWw7XG4gICAgICAgIGlmICh0aGlzLnQpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKHRoaXMudC5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLCBmaW5hbCk7XG4gICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50LmRlY29kZSgpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgZXJyKDgpO1xuICAgICAgICAgICAgICAgIHRoaXMudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnApXG4gICAgICAgICAgICBlcnIoNCk7XG4gICAgICAgIHZhciBkYXQgPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgIGRhdC5zZXQodGhpcy5wKTtcbiAgICAgICAgZGF0LnNldChjaHVuaywgdGhpcy5wLmxlbmd0aCk7XG4gICAgICAgIHZhciBfYSA9IGR1dGY4KGRhdCksIHMgPSBfYS5zLCByID0gX2EucjtcbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAoci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZXJyKDgpO1xuICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnAgPSByO1xuICAgICAgICB0aGlzLm9uZGF0YShzLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjb2RlVVRGODtcbn0oKSk7XG5leHBvcnRzLkRlY29kZVVURjggPSBEZWNvZGVVVEY4O1xuLyoqXG4gKiBTdHJlYW1pbmcgVVRGLTggZW5jb2RpbmdcbiAqL1xudmFyIEVuY29kZVVURjggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFVURi04IGRlY29kaW5nIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGVuY29kZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbmNvZGVVVEY4KGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGVuY29kZWQgdG8gVVRGLThcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIHN0cmluZyBkYXRhIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRW5jb2RlVVRGOC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgIGVycig0KTtcbiAgICAgICAgdGhpcy5vbmRhdGEoc3RyVG9VOChjaHVuayksIHRoaXMuZCA9IGZpbmFsIHx8IGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBFbmNvZGVVVEY4O1xufSgpKTtcbmV4cG9ydHMuRW5jb2RlVVRGOCA9IEVuY29kZVVURjg7XG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBVaW50OEFycmF5IGZvciB1c2Ugd2l0aCBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIG1ldGhvZHNcbiAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGRlY29kaW5nIGEgYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcgZW5jb2RlZCBpbiBVVEYtOC9MYXRpbi0xIGJpbmFyeVxuICovXG5mdW5jdGlvbiBzdHJUb1U4KHN0ciwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgYXJfMSA9IG5ldyB1OChzdHIubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBhcl8xW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJldHVybiBhcl8xO1xuICAgIH1cbiAgICBpZiAodGUpXG4gICAgICAgIHJldHVybiB0ZS5lbmNvZGUoc3RyKTtcbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGFyID0gbmV3IHU4KHN0ci5sZW5ndGggKyAoc3RyLmxlbmd0aCA+PiAxKSk7XG4gICAgdmFyIGFpID0gMDtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGFyW2FpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICBpZiAoYWkgKyA1ID4gYXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG5ldyB1OChhaSArIDggKyAoKGwgLSBpKSA8PCAxKSk7XG4gICAgICAgICAgICBuLnNldChhcik7XG4gICAgICAgICAgICBhciA9IG47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjggfHwgbGF0aW4xKVxuICAgICAgICAgICAgdyhjKTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXG4gICAgICAgICAgICB3KDE5MiB8IChjID4+IDYpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2UgaWYgKGMgPiA1NTI5NSAmJiBjIDwgNTczNDQpXG4gICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAmIDEwMjMgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAxMDIzKSxcbiAgICAgICAgICAgICAgICB3KDI0MCB8IChjID4+IDE4KSksIHcoMTI4IHwgKChjID4+IDEyKSAmIDYzKSksIHcoMTI4IHwgKChjID4+IDYpICYgNjMpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHcoMjI0IHwgKGMgPj4gMTIpKSwgdygxMjggfCAoKGMgPj4gNikgJiA2MykpLCB3KDEyOCB8IChjICYgNjMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhhciwgMCwgYWkpO1xufVxuZXhwb3J0cy5zdHJUb1U4ID0gc3RyVG9VODtcbi8qKlxuICogQ29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0gZGF0IFRoZSBkYXRhIHRvIGRlY29kZSB0byBzdHJpbmdcbiAqIEBwYXJhbSBsYXRpbjEgV2hldGhlciBvciBub3QgdG8gaW50ZXJwcmV0IHRoZSBkYXRhIGFzIExhdGluLTEuIFRoaXMgc2hvdWxkXG4gKiAgICAgICAgICAgICAgIG5vdCBuZWVkIHRvIGJlIHRydWUgdW5sZXNzIGVuY29kaW5nIHRvIGJpbmFyeSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgb3JpZ2luYWwgVVRGLTgvTGF0aW4tMSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gc3RyRnJvbVU4KGRhdCwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdC5sZW5ndGg7IGkgKz0gMTYzODQpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0LnN1YmFycmF5KGksIGkgKyAxNjM4NCkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGQpIHtcbiAgICAgICAgcmV0dXJuIHRkLmRlY29kZShkYXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgcyA9IF9hLnMsIHIgPSBfYS5yO1xuICAgICAgICBpZiAoci5sZW5ndGgpXG4gICAgICAgICAgICBlcnIoOCk7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbn1cbmV4cG9ydHMuc3RyRnJvbVU4ID0gc3RyRnJvbVU4O1xuO1xuLy8gZGVmbGF0ZSBiaXQgZmxhZ1xudmFyIGRiZiA9IGZ1bmN0aW9uIChsKSB7IHJldHVybiBsID09IDEgPyAzIDogbCA8IDYgPyAyIDogbCA9PSA5ID8gMSA6IDA7IH07XG4vLyBza2lwIGxvY2FsIHppcCBoZWFkZXJcbnZhciBzbHpoID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIGIgKyAzMCArIGIyKGQsIGIgKyAyNikgKyBiMihkLCBiICsgMjgpOyB9O1xuLy8gcmVhZCB6aXAgaGVhZGVyXG52YXIgemggPSBmdW5jdGlvbiAoZCwgYiwgeikge1xuICAgIHZhciBmbmwgPSBiMihkLCBiICsgMjgpLCBmbiA9IHN0ckZyb21VOChkLnN1YmFycmF5KGIgKyA0NiwgYiArIDQ2ICsgZm5sKSwgIShiMihkLCBiICsgOCkgJiAyMDQ4KSksIGVzID0gYiArIDQ2ICsgZm5sLCBicyA9IGI0KGQsIGIgKyAyMCk7XG4gICAgdmFyIF9hID0geiAmJiBicyA9PSA0Mjk0OTY3Mjk1ID8gejY0ZShkLCBlcykgOiBbYnMsIGI0KGQsIGIgKyAyNCksIGI0KGQsIGIgKyA0MildLCBzYyA9IF9hWzBdLCBzdSA9IF9hWzFdLCBvZmYgPSBfYVsyXTtcbiAgICByZXR1cm4gW2IyKGQsIGIgKyAxMCksIHNjLCBzdSwgZm4sIGVzICsgYjIoZCwgYiArIDMwKSArIGIyKGQsIGIgKyAzMiksIG9mZl07XG59O1xuLy8gcmVhZCB6aXA2NCBleHRyYSBmaWVsZFxudmFyIHo2NGUgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAoOyBiMihkLCBiKSAhPSAxOyBiICs9IDQgKyBiMihkLCBiICsgMikpXG4gICAgICAgIDtcbiAgICByZXR1cm4gW2I4KGQsIGIgKyAxMiksIGI4KGQsIGIgKyA0KSwgYjgoZCwgYiArIDIwKV07XG59O1xuLy8gZXh0cmEgZmllbGQgbGVuZ3RoXG52YXIgZXhmbCA9IGZ1bmN0aW9uIChleCkge1xuICAgIHZhciBsZSA9IDA7XG4gICAgaWYgKGV4KSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZXgpIHtcbiAgICAgICAgICAgIHZhciBsID0gZXhba10ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGwgPiA2NTUzNSlcbiAgICAgICAgICAgICAgICBlcnIoOSk7XG4gICAgICAgICAgICBsZSArPSBsICsgNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGU7XG59O1xuLy8gd3JpdGUgemlwIGhlYWRlclxudmFyIHd6aCA9IGZ1bmN0aW9uIChkLCBiLCBmLCBmbiwgdSwgYywgY2UsIGNvKSB7XG4gICAgdmFyIGZsID0gZm4ubGVuZ3RoLCBleCA9IGYuZXh0cmEsIGNvbCA9IGNvICYmIGNvLmxlbmd0aDtcbiAgICB2YXIgZXhsID0gZXhmbChleCk7XG4gICAgd2J5dGVzKGQsIGIsIGNlICE9IG51bGwgPyAweDIwMTRCNTAgOiAweDQwMzRCNTApLCBiICs9IDQ7XG4gICAgaWYgKGNlICE9IG51bGwpXG4gICAgICAgIGRbYisrXSA9IDIwLCBkW2IrK10gPSBmLm9zO1xuICAgIGRbYl0gPSAyMCwgYiArPSAyOyAvLyBzcGVjIGNvbXBsaWFuY2U/IHdoYXQncyB0aGF0P1xuICAgIGRbYisrXSA9IChmLmZsYWcgPDwgMSkgfCAoYyA8IDAgJiYgOCksIGRbYisrXSA9IHUgJiYgODtcbiAgICBkW2IrK10gPSBmLmNvbXByZXNzaW9uICYgMjU1LCBkW2IrK10gPSBmLmNvbXByZXNzaW9uID4+IDg7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUoZi5tdGltZSA9PSBudWxsID8gRGF0ZS5ub3coKSA6IGYubXRpbWUpLCB5ID0gZHQuZ2V0RnVsbFllYXIoKSAtIDE5ODA7XG4gICAgaWYgKHkgPCAwIHx8IHkgPiAxMTkpXG4gICAgICAgIGVycigxMCk7XG4gICAgd2J5dGVzKGQsIGIsICh5IDw8IDI1KSB8ICgoZHQuZ2V0TW9udGgoKSArIDEpIDw8IDIxKSB8IChkdC5nZXREYXRlKCkgPDwgMTYpIHwgKGR0LmdldEhvdXJzKCkgPDwgMTEpIHwgKGR0LmdldE1pbnV0ZXMoKSA8PCA1KSB8IChkdC5nZXRTZWNvbmRzKCkgPj4gMSkpLCBiICs9IDQ7XG4gICAgaWYgKGMgIT0gLTEpIHtcbiAgICAgICAgd2J5dGVzKGQsIGIsIGYuY3JjKTtcbiAgICAgICAgd2J5dGVzKGQsIGIgKyA0LCBjIDwgMCA/IC1jIC0gMiA6IGMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDgsIGYuc2l6ZSk7XG4gICAgfVxuICAgIHdieXRlcyhkLCBiICsgMTIsIGZsKTtcbiAgICB3Ynl0ZXMoZCwgYiArIDE0LCBleGwpLCBiICs9IDE2O1xuICAgIGlmIChjZSAhPSBudWxsKSB7XG4gICAgICAgIHdieXRlcyhkLCBiLCBjb2wpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDYsIGYuYXR0cnMpO1xuICAgICAgICB3Ynl0ZXMoZCwgYiArIDEwLCBjZSksIGIgKz0gMTQ7XG4gICAgfVxuICAgIGQuc2V0KGZuLCBiKTtcbiAgICBiICs9IGZsO1xuICAgIGlmIChleGwpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiBleCkge1xuICAgICAgICAgICAgdmFyIGV4ZiA9IGV4W2tdLCBsID0gZXhmLmxlbmd0aDtcbiAgICAgICAgICAgIHdieXRlcyhkLCBiLCArayk7XG4gICAgICAgICAgICB3Ynl0ZXMoZCwgYiArIDIsIGwpO1xuICAgICAgICAgICAgZC5zZXQoZXhmLCBiICsgNCksIGIgKz0gNCArIGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbClcbiAgICAgICAgZC5zZXQoY28sIGIpLCBiICs9IGNvbDtcbiAgICByZXR1cm4gYjtcbn07XG4vLyB3cml0ZSB6aXAgZm9vdGVyIChlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnkpXG52YXIgd3pmID0gZnVuY3Rpb24gKG8sIGIsIGMsIGQsIGUpIHtcbiAgICB3Ynl0ZXMobywgYiwgMHg2MDU0QjUwKTsgLy8gc2tpcCBkaXNrXG4gICAgd2J5dGVzKG8sIGIgKyA4LCBjKTtcbiAgICB3Ynl0ZXMobywgYiArIDEwLCBjKTtcbiAgICB3Ynl0ZXMobywgYiArIDEyLCBkKTtcbiAgICB3Ynl0ZXMobywgYiArIDE2LCBlKTtcbn07XG4vKipcbiAqIEEgcGFzcy10aHJvdWdoIHN0cmVhbSB0byBrZWVwIGRhdGEgdW5jb21wcmVzc2VkIGluIGEgWklQIGFyY2hpdmUuXG4gKi9cbnZhciBaaXBQYXNzVGhyb3VnaCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGFzcy10aHJvdWdoIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaaXBQYXNzVGhyb3VnaChmaWxlbmFtZSkge1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMuYyA9IGNyYygpO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIGEgY2h1bmsgYW5kIHB1c2hlcyB0byB0aGUgb3V0cHV0IHN0cmVhbS4gWW91IGNhbiBvdmVycmlkZSB0aGlzXG4gICAgICogbWV0aG9kIGluIGEgc3ViY2xhc3MgZm9yIGN1c3RvbSBiZWhhdmlvciwgYnV0IGJ5IGRlZmF1bHQgdGhpcyBwYXNzZXNcbiAgICAgKiB0aGUgZGF0YSB0aHJvdWdoLiBZb3UgbXVzdCBjYWxsIHRoaXMub25kYXRhKGVyciwgY2h1bmssIGZpbmFsKSBhdCBzb21lXG4gICAgICogcG9pbnQgaW4gdGhpcyBtZXRob2QuXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwcm9jZXNzXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgYWRkZWQuIElmIHlvdSBhcmUgc3ViY2xhc3NpbmcgdGhpcyB3aXRoIGEgY3VzdG9tXG4gICAgICogY29tcHJlc3Npb24gYWxnb3JpdGhtLCBub3RlIHRoYXQgeW91IG11c3QgcHVzaCBkYXRhIGZyb20gdGhlIHNvdXJjZVxuICAgICAqIGZpbGUgb25seSwgcHJlLWNvbXByZXNzaW9uLlxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBaaXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgdGhpcy5jLnAoY2h1bmspO1xuICAgICAgICB0aGlzLnNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoZmluYWwpXG4gICAgICAgICAgICB0aGlzLmNyYyA9IHRoaXMuYy5kKCk7XG4gICAgICAgIHRoaXMucHJvY2VzcyhjaHVuaywgZmluYWwgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydHMuWmlwUGFzc1Rocm91Z2ggPSBaaXBQYXNzVGhyb3VnaDtcbi8vIEkgZG9uJ3QgZXh0ZW5kIGJlY2F1c2UgVHlwZVNjcmlwdCBleHRlbnNpb24gYWRkcyAxa0Igb2YgcnVudGltZSBibG9hdFxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzLiBQcmVmZXIgdXNpbmcgQXN5bmNaaXBEZWZsYXRlXG4gKiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gKi9cbnZhciBaaXBEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcERlZmxhdGUoZmlsZW5hbWUsIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5jYWxsKHRoaXMsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kID0gbmV3IERlZmxhdGUob3B0cywgZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzLm9uZGF0YShudWxsLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSA4O1xuICAgICAgICB0aGlzLmZsYWcgPSBkYmYob3B0cy5sZXZlbCk7XG4gICAgfVxuICAgIFppcERlZmxhdGUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmQucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlLCBudWxsLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGRlZmxhdGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcERlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydHMuWmlwRGVmbGF0ZSA9IFppcERlZmxhdGU7XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzXG4gKi9cbnZhciBBc3luY1ppcERlZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhc3luY2hyb25vdXMgREVGTEFURSBzdHJlYW0gdGhhdCBjYW4gYmUgYWRkZWQgdG8gWklQIGFyY2hpdmVzXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIFRoZSBmaWxlbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRhdGEgc3RyZWFtXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY1ppcERlZmxhdGUoZmlsZW5hbWUsIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5jYWxsKHRoaXMsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kID0gbmV3IEFzeW5jRGVmbGF0ZShvcHRzLCBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpcy5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSA4O1xuICAgICAgICB0aGlzLmZsYWcgPSBkYmYob3B0cy5sZXZlbCk7XG4gICAgICAgIHRoaXMudGVybWluYXRlID0gdGhpcy5kLnRlcm1pbmF0ZTtcbiAgICB9XG4gICAgQXN5bmNaaXBEZWZsYXRlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLmQucHVzaChjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgQXN5bmNaaXBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNaaXBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydHMuQXN5bmNaaXBEZWZsYXRlID0gQXN5bmNaaXBEZWZsYXRlO1xuLy8gVE9ETzogQmV0dGVyIHRyZWUgc2hha2luZ1xuLyoqXG4gKiBBIHppcHBhYmxlIGFyY2hpdmUgdG8gd2hpY2ggZmlsZXMgY2FuIGluY3JlbWVudGFsbHkgYmUgYWRkZWRcbiAqL1xudmFyIFppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IFpJUCBhcmNoaXZlIHRvIHdoaWNoIGZpbGVzIGNhbiBiZSBhZGRlZFxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGZvciB0aGUgZ2VuZXJhdGVkIFpJUCBhcmNoaXZlXG4gICAgICogICAgICAgICAgIGlzIGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLnUgPSBbXTtcbiAgICAgICAgdGhpcy5kID0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZpbGUgdG8gdGhlIFpJUCBhcmNoaXZlXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgc3RyZWFtIHRvIGFkZFxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIGVycig1KTtcbiAgICAgICAgLy8gZmluaXNoaW5nIG9yIGZpbmlzaGVkXG4gICAgICAgIGlmICh0aGlzLmQgJiAyKVxuICAgICAgICAgICAgdGhpcy5vbmRhdGEoZXJyKDQgKyAodGhpcy5kICYgMSkgKiA4LCAwLCAxKSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmID0gc3RyVG9VOChmaWxlLmZpbGVuYW1lKSwgZmxfMSA9IGYubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNvbSA9IGZpbGUuY29tbWVudCwgbyA9IGNvbSAmJiBzdHJUb1U4KGNvbSk7XG4gICAgICAgICAgICB2YXIgdSA9IGZsXzEgIT0gZmlsZS5maWxlbmFtZS5sZW5ndGggfHwgKG8gJiYgKGNvbS5sZW5ndGggIT0gby5sZW5ndGgpKTtcbiAgICAgICAgICAgIHZhciBobF8xID0gZmxfMSArIGV4ZmwoZmlsZS5leHRyYSkgKyAzMDtcbiAgICAgICAgICAgIGlmIChmbF8xID4gNjU1MzUpXG4gICAgICAgICAgICAgICAgdGhpcy5vbmRhdGEoZXJyKDExLCAwLCAxKSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IG5ldyB1OChobF8xKTtcbiAgICAgICAgICAgIHd6aChoZWFkZXIsIDAsIGZpbGUsIGYsIHUsIC0xKTtcbiAgICAgICAgICAgIHZhciBjaGtzXzEgPSBbaGVhZGVyXTtcbiAgICAgICAgICAgIHZhciBwQWxsXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGtzXzIgPSBjaGtzXzE7IF9pIDwgY2hrc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hrID0gY2hrc18yW19pXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25kYXRhKG51bGwsIGNoaywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGtzXzEgPSBbXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdHJfMSA9IHRoaXMuZDtcbiAgICAgICAgICAgIHRoaXMuZCA9IDA7XG4gICAgICAgICAgICB2YXIgaW5kXzEgPSB0aGlzLnUubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHVmXzEgPSBtcmcoZmlsZSwge1xuICAgICAgICAgICAgICAgIGY6IGYsXG4gICAgICAgICAgICAgICAgdTogdSxcbiAgICAgICAgICAgICAgICBvOiBvLFxuICAgICAgICAgICAgICAgIHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUudGVybWluYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcEFsbF8xKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cl8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gX3RoaXMudVtpbmRfMSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG54dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueHQucigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyXzEgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNsXzEgPSAwO1xuICAgICAgICAgICAgZmlsZS5vbmRhdGEgPSBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbF8xICs9IGRhdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNoa3NfMS5wdXNoKGRhdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRkID0gbmV3IHU4KDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgMCwgMHg4MDc0QjUwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgNCwgZmlsZS5jcmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCA4LCBjbF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgMTIsIGZpbGUuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGtzXzEucHVzaChkZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1Zl8xLmMgPSBjbF8xLCB1Zl8xLmIgPSBobF8xICsgY2xfMSArIDE2LCB1Zl8xLmNyYyA9IGZpbGUuY3JjLCB1Zl8xLnNpemUgPSBmaWxlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1Zl8xLnIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyXzEgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyXzEpXG4gICAgICAgICAgICAgICAgICAgICAgICBwQWxsXzEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy51LnB1c2godWZfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuZHMgdGhlIHByb2Nlc3Mgb2YgYWRkaW5nIGZpbGVzIGFuZCBwcmVwYXJlcyB0byBlbWl0IHRoZSBmaW5hbCBjaHVua3MuXG4gICAgICogVGhpcyAqbXVzdCogYmUgY2FsbGVkIGFmdGVyIGFkZGluZyBhbGwgZGVzaXJlZCBmaWxlcyBmb3IgdGhlIHJlc3VsdGluZ1xuICAgICAqIFpJUCBmaWxlIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgICovXG4gICAgWmlwLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmQgJiAyKSB7XG4gICAgICAgICAgICB0aGlzLm9uZGF0YShlcnIoNCArICh0aGlzLmQgJiAxKSAqIDgsIDAsIDEpLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhpcy5lKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudS5wdXNoKHtcbiAgICAgICAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF90aGlzLmQgJiAxKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudS5zcGxpY2UoLTEsIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0OiBmdW5jdGlvbiAoKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmQgPSAzO1xuICAgIH07XG4gICAgWmlwLnByb3RvdHlwZS5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnQgPSAwLCBsID0gMCwgdGwgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy51OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfYVtfaV07XG4gICAgICAgICAgICB0bCArPSA0NiArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpICsgKGYubyA/IGYuby5sZW5ndGggOiAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gbmV3IHU4KHRsICsgMjIpO1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy51OyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfY1tfYl07XG4gICAgICAgICAgICB3emgob3V0LCBidCwgZiwgZi5mLCBmLnUsIC1mLmMgLSAyLCBsLCBmLm8pO1xuICAgICAgICAgICAgYnQgKz0gNDYgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKSArIChmLm8gPyBmLm8ubGVuZ3RoIDogMCksIGwgKz0gZi5iO1xuICAgICAgICB9XG4gICAgICAgIHd6ZihvdXQsIGJ0LCB0aGlzLnUubGVuZ3RoLCB0bCwgbCk7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIG91dCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZCA9IDI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCB0byB0ZXJtaW5hdGUgYW55IGludGVybmFsIHdvcmtlcnMgdXNlZCBieSB0aGUgc3RyZWFtLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gYWRkKCkgd2lsbCBmYWlsLlxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUudGVybWluYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy51OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfYVtfaV07XG4gICAgICAgICAgICBmLnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmQgPSAyO1xuICAgIH07XG4gICAgcmV0dXJuIFppcDtcbn0oKSk7XG5leHBvcnRzLlppcCA9IFppcDtcbmZ1bmN0aW9uIHppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHZhciByID0ge307XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIGsgPSBPYmplY3Qua2V5cyhyKTtcbiAgICB2YXIgbGZ0ID0gay5sZW5ndGgsIG8gPSAwLCB0b3QgPSAwO1xuICAgIHZhciBzbGZ0ID0gbGZ0LCBmaWxlcyA9IG5ldyBBcnJheShsZnQpO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBjYmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBtdChmdW5jdGlvbiAoKSB7IGNiKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIG10KGZ1bmN0aW9uICgpIHsgY2JkID0gY2I7IH0pO1xuICAgIHZhciBjYmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgICAgIHRvdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xmdDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGYuYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd3poKG91dCwgdG90LCBmLCBmLmYsIGYudSwgbCk7XG4gICAgICAgICAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSB0b3QgKyBiYWRkO1xuICAgICAgICAgICAgICAgIG91dC5zZXQoZi5jLCBsb2MpO1xuICAgICAgICAgICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBsLCB0b3QsIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKSwgdG90ID0gbG9jICsgbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiZChlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3emYob3V0LCBvLCBmaWxlcy5sZW5ndGgsIGNkbCwgb2UpO1xuICAgICAgICBjYmQobnVsbCwgb3V0KTtcbiAgICB9O1xuICAgIGlmICghbGZ0KVxuICAgICAgICBjYmYoKTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBmbiA9IGtbaV07XG4gICAgICAgIHZhciBfYSA9IHJbZm5dLCBmaWxlID0gX2FbMF0sIHAgPSBfYVsxXTtcbiAgICAgICAgdmFyIGMgPSBjcmMoKSwgc2l6ZSA9IGZpbGUubGVuZ3RoO1xuICAgICAgICBjLnAoZmlsZSk7XG4gICAgICAgIHZhciBmID0gc3RyVG9VOChmbiksIHMgPSBmLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbSA9IHAuY29tbWVudCwgbSA9IGNvbSAmJiBzdHJUb1U4KGNvbSksIG1zID0gbSAmJiBtLmxlbmd0aDtcbiAgICAgICAgdmFyIGV4bCA9IGV4ZmwocC5leHRyYSk7XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9IHAubGV2ZWwgPT0gMCA/IDAgOiA4O1xuICAgICAgICB2YXIgY2JsID0gZnVuY3Rpb24gKGUsIGQpIHtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgdEFsbCgpO1xuICAgICAgICAgICAgICAgIGNiZChlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZmlsZXNbaV0gPSBtcmcocCwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgICAgICBjcmM6IGMuZCgpLFxuICAgICAgICAgICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgICAgICAgICBmOiBmLFxuICAgICAgICAgICAgICAgICAgICBtOiBtLFxuICAgICAgICAgICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvICs9IDMwICsgcyArIGV4bCArIGw7XG4gICAgICAgICAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgICAgICAgICAgICAgaWYgKCEtLWxmdClcbiAgICAgICAgICAgICAgICAgICAgY2JmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzID4gNjU1MzUpXG4gICAgICAgICAgICBjYmwoZXJyKDExLCAwLCAxKSwgbnVsbCk7XG4gICAgICAgIGlmICghY29tcHJlc3Npb24pXG4gICAgICAgICAgICBjYmwobnVsbCwgZmlsZSk7XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPCAxNjAwMDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2JsKG51bGwsIGRlZmxhdGVTeW5jKGZpbGUsIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRlcm0ucHVzaChkZWZsYXRlKGZpbGUsIHAsIGNibCkpO1xuICAgIH07XG4gICAgLy8gQ2Fubm90IHVzZSBsZnQgYmVjYXVzZSBpdCBjYW4gZGVjcmVhc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsZnQ7ICsraSkge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdEFsbDtcbn1cbmV4cG9ydHMuemlwID0gemlwO1xuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGNyZWF0ZXMgYSBaSVAgZmlsZS4gUHJlZmVyIHVzaW5nIGB6aXBgIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAqIHdpdGggbW9yZSB0aGFuIG9uZSBmaWxlLlxuICogQHBhcmFtIGRhdGEgVGhlIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgZm9yIHRoZSBaSVAgYXJjaGl2ZVxuICogQHBhcmFtIG9wdHMgVGhlIG1haW4gb3B0aW9ucywgbWVyZ2VkIHdpdGggcGVyLWZpbGUgb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBaSVAgYXJjaGl2ZVxuICovXG5mdW5jdGlvbiB6aXBTeW5jKGRhdGEsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpXG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB2YXIgciA9IHt9O1xuICAgIHZhciBmaWxlcyA9IFtdO1xuICAgIGZsdG4oZGF0YSwgJycsIHIsIG9wdHMpO1xuICAgIHZhciBvID0gMDtcbiAgICB2YXIgdG90ID0gMDtcbiAgICBmb3IgKHZhciBmbiBpbiByKSB7XG4gICAgICAgIHZhciBfYSA9IHJbZm5dLCBmaWxlID0gX2FbMF0sIHAgPSBfYVsxXTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gcC5sZXZlbCA9PSAwID8gMCA6IDg7XG4gICAgICAgIHZhciBmID0gc3RyVG9VOChmbiksIHMgPSBmLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbSA9IHAuY29tbWVudCwgbSA9IGNvbSAmJiBzdHJUb1U4KGNvbSksIG1zID0gbSAmJiBtLmxlbmd0aDtcbiAgICAgICAgdmFyIGV4bCA9IGV4ZmwocC5leHRyYSk7XG4gICAgICAgIGlmIChzID4gNjU1MzUpXG4gICAgICAgICAgICBlcnIoMTEpO1xuICAgICAgICB2YXIgZCA9IGNvbXByZXNzaW9uID8gZGVmbGF0ZVN5bmMoZmlsZSwgcCkgOiBmaWxlLCBsID0gZC5sZW5ndGg7XG4gICAgICAgIHZhciBjID0gY3JjKCk7XG4gICAgICAgIGMucChmaWxlKTtcbiAgICAgICAgZmlsZXMucHVzaChtcmcocCwge1xuICAgICAgICAgICAgc2l6ZTogZmlsZS5sZW5ndGgsXG4gICAgICAgICAgICBjcmM6IGMuZCgpLFxuICAgICAgICAgICAgYzogZCxcbiAgICAgICAgICAgIGY6IGYsXG4gICAgICAgICAgICBtOiBtLFxuICAgICAgICAgICAgdTogcyAhPSBmbi5sZW5ndGggfHwgKG0gJiYgKGNvbS5sZW5ndGggIT0gbXMpKSxcbiAgICAgICAgICAgIG86IG8sXG4gICAgICAgICAgICBjb21wcmVzc2lvbjogY29tcHJlc3Npb25cbiAgICAgICAgfSkpO1xuICAgICAgICBvICs9IDMwICsgcyArIGV4bCArIGw7XG4gICAgICAgIHRvdCArPSA3NiArIDIgKiAocyArIGV4bCkgKyAobXMgfHwgMCkgKyBsO1xuICAgIH1cbiAgICB2YXIgb3V0ID0gbmV3IHU4KHRvdCArIDIyKSwgb2UgPSBvLCBjZGwgPSB0b3QgLSBvO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGYgPSBmaWxlc1tpXTtcbiAgICAgICAgd3poKG91dCwgZi5vLCBmLCBmLmYsIGYudSwgZi5jLmxlbmd0aCk7XG4gICAgICAgIHZhciBiYWRkID0gMzAgKyBmLmYubGVuZ3RoICsgZXhmbChmLmV4dHJhKTtcbiAgICAgICAgb3V0LnNldChmLmMsIGYubyArIGJhZGQpO1xuICAgICAgICB3emgob3V0LCBvLCBmLCBmLmYsIGYudSwgZi5jLmxlbmd0aCwgZi5vLCBmLm0pLCBvICs9IDE2ICsgYmFkZCArIChmLm0gPyBmLm0ubGVuZ3RoIDogMCk7XG4gICAgfVxuICAgIHd6ZihvdXQsIG8sIGZpbGVzLmxlbmd0aCwgY2RsLCBvZSk7XG4gICAgcmV0dXJuIG91dDtcbn1cbmV4cG9ydHMuemlwU3luYyA9IHppcFN5bmM7XG4vKipcbiAqIFN0cmVhbWluZyBwYXNzLXRocm91Z2ggZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzXG4gKi9cbnZhciBVbnppcFBhc3NUaHJvdWdoID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuemlwUGFzc1Rocm91Z2goKSB7XG4gICAgfVxuICAgIFVuemlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmluYWwpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEobnVsbCwgZGF0YSwgZmluYWwpO1xuICAgIH07XG4gICAgVW56aXBQYXNzVGhyb3VnaC5jb21wcmVzc2lvbiA9IDA7XG4gICAgcmV0dXJuIFVuemlwUGFzc1Rocm91Z2g7XG59KCkpO1xuZXhwb3J0cy5VbnppcFBhc3NUaHJvdWdoID0gVW56aXBQYXNzVGhyb3VnaDtcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzLiBQcmVmZXIgQXN5bmNaaXBJbmZsYXRlIGZvclxuICogYmV0dGVyIHBlcmZvcm1hbmNlLlxuICovXG52YXIgVW56aXBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIGRlY29tcHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCBpbiBaSVAgYXJjaGl2ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnppcEluZmxhdGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBfdGhpcy5vbmRhdGEobnVsbCwgZGF0LCBmaW5hbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBVbnppcEluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmluYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaS5wdXNoKGRhdGEsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbmRhdGEoZSwgbnVsbCwgZmluYWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVbnppcEluZmxhdGUuY29tcHJlc3Npb24gPSA4O1xuICAgIHJldHVybiBVbnppcEluZmxhdGU7XG59KCkpO1xuZXhwb3J0cy5VbnppcEluZmxhdGUgPSBVbnppcEluZmxhdGU7XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBkZWNvbXByZXNzaW9uIGZvciBaSVAgYXJjaGl2ZXNcbiAqL1xudmFyIEFzeW5jVW56aXBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIGRlY29tcHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCBpbiBaSVAgYXJjaGl2ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY1VuemlwSW5mbGF0ZShfLCBzeikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc3ogPCAzMjAwMDApIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmkgPSBuZXcgQXN5bmNJbmZsYXRlKGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUgPSB0aGlzLmkudGVybWluYXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFzeW5jVW56aXBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmkudGVybWluYXRlKVxuICAgICAgICAgICAgZGF0YSA9IHNsYyhkYXRhLCAwKTtcbiAgICAgICAgdGhpcy5pLnB1c2goZGF0YSwgZmluYWwpO1xuICAgIH07XG4gICAgQXN5bmNVbnppcEluZmxhdGUuY29tcHJlc3Npb24gPSA4O1xuICAgIHJldHVybiBBc3luY1VuemlwSW5mbGF0ZTtcbn0oKSk7XG5leHBvcnRzLkFzeW5jVW56aXBJbmZsYXRlID0gQXN5bmNVbnppcEluZmxhdGU7XG4vKipcbiAqIEEgWklQIGFyY2hpdmUgZGVjb21wcmVzc2lvbiBzdHJlYW0gdGhhdCBlbWl0cyBmaWxlcyBhcyB0aGV5IGFyZSBkaXNjb3ZlcmVkXG4gKi9cbnZhciBVbnppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgWklQIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGEgZmlsZSBpbiB0aGUgWklQIGFyY2hpdmUgaXMgZm91bmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnppcChjYikge1xuICAgICAgICB0aGlzLm9uZmlsZSA9IGNiO1xuICAgICAgICB0aGlzLmsgPSBbXTtcbiAgICAgICAgdGhpcy5vID0ge1xuICAgICAgICAgICAgMDogVW56aXBQYXNzVGhyb3VnaFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnAgPSBldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgdW56aXBwZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgVW56aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5vbmZpbGUpXG4gICAgICAgICAgICBlcnIoNSk7XG4gICAgICAgIGlmICghdGhpcy5wKVxuICAgICAgICAgICAgZXJyKDQpO1xuICAgICAgICBpZiAodGhpcy5jID4gMCkge1xuICAgICAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKHRoaXMuYywgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciB0b0FkZCA9IGNodW5rLnN1YmFycmF5KDAsIGxlbik7XG4gICAgICAgICAgICB0aGlzLmMgLT0gbGVuO1xuICAgICAgICAgICAgaWYgKHRoaXMuZClcbiAgICAgICAgICAgICAgICB0aGlzLmQucHVzaCh0b0FkZCwgIXRoaXMuYyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5rWzBdLnB1c2godG9BZGQpO1xuICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zdWJhcnJheShsZW4pO1xuICAgICAgICAgICAgaWYgKGNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZiA9IDAsIGkgPSAwLCBpcyA9IHZvaWQgMCwgYnVmID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnAubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJ1ZiA9IGNodW5rO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWNodW5rLmxlbmd0aClcbiAgICAgICAgICAgICAgICBidWYgPSB0aGlzLnA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWYgPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYnVmLnNldCh0aGlzLnApLCBidWYuc2V0KGNodW5rLCB0aGlzLnAubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsID0gYnVmLmxlbmd0aCwgb2MgPSB0aGlzLmMsIGFkZCA9IG9jICYmIHRoaXMuZDtcbiAgICAgICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YXIgc2lnID0gYjQoYnVmLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnID09IDB4NDAzNEI1MCkge1xuICAgICAgICAgICAgICAgICAgICBmID0gMSwgaXMgPSBpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJmID0gYjIoYnVmLCBpICsgNiksIGNtcF8xID0gYjIoYnVmLCBpICsgOCksIHUgPSBiZiAmIDIwNDgsIGRkID0gYmYgJiA4LCBmbmwgPSBiMihidWYsIGkgKyAyNiksIGVzID0gYjIoYnVmLCBpICsgMjgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobCA+IGkgKyAzMCArIGZubCArIGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hrc18zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzXzEuay51bnNoaWZ0KGNoa3NfMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY18xID0gYjQoYnVmLCBpICsgMTgpLCBzdV8xID0gYjQoYnVmLCBpICsgMjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuXzEgPSBzdHJGcm9tVTgoYnVmLnN1YmFycmF5KGkgKyAzMCwgaSArPSAzMCArIGZubCksICF1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY18xID09IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGRkID8gWy0yXSA6IHo2NGUoYnVmLCBpKSwgc2NfMSA9IF9hWzBdLCBzdV8xID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY18xID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmMgPSBzY18xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlXzEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZm5fMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY21wXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlXzEub25kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyKDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjXzEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlXzEub25kYXRhKG51bGwsIGV0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3RyID0gX3RoaXMub1tjbXBfMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN0cilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlXzEub25kYXRhKGVycigxNCwgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY21wXzEsIDEpLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEgPSBzY18xIDwgMCA/IG5ldyBjdHIoZm5fMSkgOiBuZXcgY3RyKGZuXzEsIHNjXzEsIHN1XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLm9uZGF0YSA9IGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHsgZmlsZV8xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGtzXzQgPSBjaGtzXzM7IF9pIDwgY2hrc180Lmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXQgPSBjaGtzXzRbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5wdXNoKGRhdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmtbMF0gPT0gY2hrc18zICYmIF90aGlzLmMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZCA9IGRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEucHVzaChldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZF8xICYmIGRfMS50ZXJtaW5hdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY18xID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV8xLnNpemUgPSBzY18xLCBmaWxlXzEub3JpZ2luYWxTaXplID0gc3VfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5vbmZpbGUoZmlsZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnID09IDB4ODA3NEI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXMgPSBpICs9IDEyICsgKG9jID09IC0yICYmIDgpLCBmID0gMywgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWcgPT0gMHgyMDE0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyA9IGkgLT0gNCwgZiA9IDMsIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGwgLSA0OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgICAgICAgICAgaWYgKG9jIDwgMCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXQgPSBmID8gYnVmLnN1YmFycmF5KDAsIGlzIC0gMTIgLSAob2MgPT0gLTIgJiYgOCkgLSAoYjQoYnVmLCBpcyAtIDE2KSA9PSAweDgwNzRCNTAgJiYgNCkpIDogYnVmLnN1YmFycmF5KDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpXG4gICAgICAgICAgICAgICAgICAgIGFkZC5wdXNoKGRhdCwgISFmKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua1srKGYgPT0gMildLnB1c2goZGF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmICYgMilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoKGJ1Zi5zdWJhcnJheShpKSwgZmluYWwpO1xuICAgICAgICAgICAgdGhpcy5wID0gYnVmLnN1YmFycmF5KGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYylcbiAgICAgICAgICAgICAgICBlcnIoMTMpO1xuICAgICAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZGVjb2RlciB3aXRoIHRoZSBzdHJlYW0sIGFsbG93aW5nIGZvciBmaWxlcyBjb21wcmVzc2VkIHdpdGhcbiAgICAgKiB0aGUgY29tcHJlc3Npb24gdHlwZSBwcm92aWRlZCB0byBiZSBleHBhbmRlZCBjb3JyZWN0bHlcbiAgICAgKiBAcGFyYW0gZGVjb2RlciBUaGUgZGVjb2RlciBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIFVuemlwLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChkZWNvZGVyKSB7XG4gICAgICAgIHRoaXMub1tkZWNvZGVyLmNvbXByZXNzaW9uXSA9IGRlY29kZXI7XG4gICAgfTtcbiAgICByZXR1cm4gVW56aXA7XG59KCkpO1xuZXhwb3J0cy5VbnppcCA9IFVuemlwO1xudmFyIG10ID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09ICdmdW5jdGlvbicgPyBxdWV1ZU1pY3JvdGFzayA6IHR5cGVvZiBzZXRUaW1lb3V0ID09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogZnVuY3Rpb24gKGZuKSB7IGZuKCk7IH07XG5mdW5jdGlvbiB1bnppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgZXJyKDcpO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBjYmQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBtdChmdW5jdGlvbiAoKSB7IGNiKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIG10KGZ1bmN0aW9uICgpIHsgY2JkID0gY2I7IH0pO1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KSB7XG4gICAgICAgICAgICBjYmQoZXJyKDEzLCAwLCAxKSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdEFsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgdmFyIGxmdCA9IGIyKGRhdGEsIGUgKyA4KTtcbiAgICBpZiAobGZ0KSB7XG4gICAgICAgIHZhciBjID0gbGZ0O1xuICAgICAgICB2YXIgbyA9IGI0KGRhdGEsIGUgKyAxNik7XG4gICAgICAgIHZhciB6ID0gbyA9PSA0Mjk0OTY3Mjk1IHx8IGMgPT0gNjU1MzU7XG4gICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICB2YXIgemUgPSBiNChkYXRhLCBlIC0gMTIpO1xuICAgICAgICAgICAgeiA9IGI0KGRhdGEsIHplKSA9PSAweDYwNjRCNTA7XG4gICAgICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgICAgIGMgPSBsZnQgPSBiNChkYXRhLCB6ZSArIDMyKTtcbiAgICAgICAgICAgICAgICBvID0gYjQoZGF0YSwgemUgKyA0OCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsdHIgPSBvcHRzICYmIG9wdHMuZmlsdGVyO1xuICAgICAgICB2YXIgX2xvb3BfMyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB6aChkYXRhLCBvLCB6KSwgY18xID0gX2FbMF0sIHNjID0gX2FbMV0sIHN1ID0gX2FbMl0sIGZuID0gX2FbM10sIG5vID0gX2FbNF0sIG9mZiA9IF9hWzVdLCBiID0gc2x6aChkYXRhLCBvZmYpO1xuICAgICAgICAgICAgbyA9IG5vO1xuICAgICAgICAgICAgdmFyIGNibCA9IGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdEFsbCgpO1xuICAgICAgICAgICAgICAgICAgICBjYmQoZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzW2ZuXSA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1sZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYmQobnVsbCwgZmlsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWZsdHIgfHwgZmx0cih7XG4gICAgICAgICAgICAgICAgbmFtZTogZm4sXG4gICAgICAgICAgICAgICAgc2l6ZTogc2MsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTaXplOiBzdSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY18xXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGlmICghY18xKVxuICAgICAgICAgICAgICAgICAgICBjYmwobnVsbCwgc2xjKGRhdGEsIGIsIGIgKyBzYykpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNfMSA9PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZsID0gZGF0YS5zdWJhcnJheShiLCBiICsgc2MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTeW5jaHJvbm91c2x5IGRlY29tcHJlc3MgdW5kZXIgNTEyS0IsIG9yIGJhcmVseS1jb21wcmVzc2VkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1IDwgNTI0Mjg4IHx8IHNjID4gMC44ICogc3UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2JsKG51bGwsIGluZmxhdGVTeW5jKGluZmwsIHsgb3V0OiBuZXcgdTgoc3UpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm0ucHVzaChpbmZsYXRlKGluZmwsIHsgc2l6ZTogc3UgfSwgY2JsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2JsKGVycigxNCwgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY18xLCAxKSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2JsKG51bGwsIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7ICsraSkge1xuICAgICAgICAgICAgX2xvb3BfMyhpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIGNiZChudWxsLCB7fSk7XG4gICAgcmV0dXJuIHRBbGw7XG59XG5leHBvcnRzLnVuemlwID0gdW56aXA7XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgZGVjb21wcmVzc2VzIGEgWklQIGFyY2hpdmUuIFByZWZlciB1c2luZyBgdW56aXBgIGZvciBiZXR0ZXJcbiAqIHBlcmZvcm1hbmNlIHdpdGggbW9yZSB0aGFuIG9uZSBmaWxlLlxuICogQHBhcmFtIGRhdGEgVGhlIHJhdyBjb21wcmVzc2VkIFpJUCBmaWxlXG4gKiBAcGFyYW0gb3B0cyBUaGUgWklQIGV4dHJhY3Rpb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGRlY29tcHJlc3NlZCBmaWxlc1xuICovXG5mdW5jdGlvbiB1bnppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KVxuICAgICAgICAgICAgZXJyKDEzKTtcbiAgICB9XG4gICAgO1xuICAgIHZhciBjID0gYjIoZGF0YSwgZSArIDgpO1xuICAgIGlmICghYylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIHZhciBvID0gYjQoZGF0YSwgZSArIDE2KTtcbiAgICB2YXIgeiA9IG8gPT0gNDI5NDk2NzI5NSB8fCBjID09IDY1NTM1O1xuICAgIGlmICh6KSB7XG4gICAgICAgIHZhciB6ZSA9IGI0KGRhdGEsIGUgLSAxMik7XG4gICAgICAgIHogPSBiNChkYXRhLCB6ZSkgPT0gMHg2MDY0QjUwO1xuICAgICAgICBpZiAoeikge1xuICAgICAgICAgICAgYyA9IGI0KGRhdGEsIHplICsgMzIpO1xuICAgICAgICAgICAgbyA9IGI0KGRhdGEsIHplICsgNDgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBmbHRyID0gb3B0cyAmJiBvcHRzLmZpbHRlcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7ICsraSkge1xuICAgICAgICB2YXIgX2EgPSB6aChkYXRhLCBvLCB6KSwgY18yID0gX2FbMF0sIHNjID0gX2FbMV0sIHN1ID0gX2FbMl0sIGZuID0gX2FbM10sIG5vID0gX2FbNF0sIG9mZiA9IF9hWzVdLCBiID0gc2x6aChkYXRhLCBvZmYpO1xuICAgICAgICBvID0gbm87XG4gICAgICAgIGlmICghZmx0ciB8fCBmbHRyKHtcbiAgICAgICAgICAgIG5hbWU6IGZuLFxuICAgICAgICAgICAgc2l6ZTogc2MsXG4gICAgICAgICAgICBvcmlnaW5hbFNpemU6IHN1LFxuICAgICAgICAgICAgY29tcHJlc3Npb246IGNfMlxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgaWYgKCFjXzIpXG4gICAgICAgICAgICAgICAgZmlsZXNbZm5dID0gc2xjKGRhdGEsIGIsIGIgKyBzYyk7XG4gICAgICAgICAgICBlbHNlIGlmIChjXzIgPT0gOClcbiAgICAgICAgICAgICAgICBmaWxlc1tmbl0gPSBpbmZsYXRlU3luYyhkYXRhLnN1YmFycmF5KGIsIGIgKyBzYyksIHsgb3V0OiBuZXcgdTgoc3UpIH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVycigxNCwgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY18yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsZXM7XG59XG5leHBvcnRzLnVuemlwU3luYyA9IHVuemlwU3luYztcbiJdLCJuYW1lcyI6WyJXb3JrZXIiLCJ3b3JrZXJBZGQiLCJyZXF1aXJlIiwiZSIsIm5vZGVfd29ya2VyXzEiLCJjIiwiXyIsIm1zZyIsInRyYW5zZmVyIiwiY2IiLCJkb25lIiwidyIsImV2YWwiLCJvbiIsIm0iLCJFcnJvciIsInBvc3RNZXNzYWdlIiwidGVybWluYXRlIiwicHJvdG90eXBlIiwiY2FsbCIsIl9fIiwiX19fIiwiX19fXyIsInNldEltbWVkaWF0ZSIsIk5PUCIsInU4IiwiVWludDhBcnJheSIsInUxNiIsIlVpbnQxNkFycmF5IiwiaTMyIiwiSW50MzJBcnJheSIsImZsZWIiLCJmZGViIiwiY2xpbSIsImZyZWIiLCJlYiIsInN0YXJ0IiwiYiIsImkiLCJyIiwiaiIsIl9hIiwiZmwiLCJyZXZmbCIsIl9iIiwiZmQiLCJyZXZmZCIsInJldiIsIngiLCJoTWFwIiwiY2QiLCJtYiIsInMiLCJsZW5ndGgiLCJsIiwibGUiLCJjbyIsInJ2YiIsInN2Iiwicl8xIiwidiIsImZsdCIsImZkdCIsImZsbSIsImZscm0iLCJmZG0iLCJmZHJtIiwibWF4IiwiYSIsImJpdHMiLCJkIiwicCIsIm8iLCJiaXRzMTYiLCJzaGZ0Iiwic2xjIiwic3ViYXJyYXkiLCJleHBvcnRzIiwiRmxhdGVFcnJvckNvZGUiLCJVbmV4cGVjdGVkRU9GIiwiSW52YWxpZEJsb2NrVHlwZSIsIkludmFsaWRMZW5ndGhMaXRlcmFsIiwiSW52YWxpZERpc3RhbmNlIiwiU3RyZWFtRmluaXNoZWQiLCJOb1N0cmVhbUhhbmRsZXIiLCJJbnZhbGlkSGVhZGVyIiwiTm9DYWxsYmFjayIsIkludmFsaWRVVEY4IiwiRXh0cmFGaWVsZFRvb0xvbmciLCJJbnZhbGlkRGF0ZSIsIkZpbGVuYW1lVG9vTG9uZyIsIlN0cmVhbUZpbmlzaGluZyIsIkludmFsaWRaaXBEYXRhIiwiVW5rbm93bkNvbXByZXNzaW9uTWV0aG9kIiwiZWMiLCJlcnIiLCJpbmQiLCJudCIsImNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImluZmx0IiwiZGF0Iiwic3QiLCJidWYiLCJkaWN0Iiwic2wiLCJkbCIsImYiLCJub0J1ZiIsInJlc2l6ZSIsIm5vU3QiLCJjYnVmIiwiYmwiLCJuYnVmIiwiTWF0aCIsInNldCIsImZpbmFsIiwicG9zIiwiYnQiLCJsbSIsImRtIiwibGJ0IiwiZGJ0IiwibiIsInRidHMiLCJ0eXBlIiwidCIsImhMaXQiLCJoY0xlbiIsInRsIiwibGR0IiwiY2x0IiwiY2xiIiwiY2xibXNrIiwiY2xtIiwibHQiLCJkdCIsImxtcyIsImRtcyIsImxwb3MiLCJzeW0iLCJhZGQiLCJkc3ltIiwiZW5kIiwic2hpZnQiLCJkZW5kIiwibWluIiwid2JpdHMiLCJ3Yml0czE2IiwiaFRyZWUiLCJwdXNoIiwidDIiLCJzbGljZSIsImV0Iiwic29ydCIsImkwIiwiaTEiLCJpMiIsIm1heFN5bSIsInRyIiwibWJ0IiwibG4iLCJsZnQiLCJjc3QiLCJpMl8xIiwiaTJfMiIsImkyXzMiLCJsYyIsImNsIiwiY2xpIiwiY2xuIiwiY2xzIiwiY2xlbiIsImNmIiwid2ZibGsiLCJvdXQiLCJ3YmxrIiwic3ltcyIsImxmIiwiZGYiLCJsaSIsImJzIiwiZGx0IiwibWxiIiwiZGR0IiwibWRiIiwiX2MiLCJsY2x0IiwibmxjIiwiX2QiLCJsY2R0IiwibmRjIiwibGNmcmVxIiwiX2UiLCJsY3QiLCJtbGNiIiwibmxjYyIsImZsZW4iLCJmdGxlbiIsImR0bGVuIiwibGwiLCJsbG0iLCJsY3RzIiwiaXQiLCJjbGN0IiwibGVuIiwiZHN0IiwiZGVvIiwiZGZsdCIsImx2bCIsInBsdmwiLCJwcmUiLCJwb3N0IiwieiIsImNlaWwiLCJsc3QiLCJvcHQiLCJtc2tfMSIsInByZXYiLCJoZWFkIiwiaCIsImJzMV8xIiwiYnMyXzEiLCJoc2giLCJsY18xIiwid2kiLCJodiIsImltb2QiLCJwaW1vZCIsInJlbSIsImNoXzEiLCJkaWYiLCJtYXhuIiwibWF4ZCIsIm1sIiwibmwiLCJtbWQiLCJtZCIsInRpIiwicHRpIiwibGluIiwiZGluIiwiY3JjdCIsImsiLCJjcmMiLCJjciIsImFkbGVyIiwiZG9wdCIsImRpY3Rpb25hcnkiLCJuZXdEYXQiLCJsZXZlbCIsIm1lbSIsImxvZyIsIm1yZyIsIndjbG4iLCJmbiIsImZuU3RyIiwidGQiLCJ0b1N0cmluZyIsImtzIiwiaW5kZXhPZiIsImxhc3RJbmRleE9mIiwicmVwbGFjZSIsInNwbGl0Iiwic3RfMSIsInNwSW5kIiwiY2giLCJjYmZzIiwiYnVmZmVyIiwiY29uc3RydWN0b3IiLCJ3cmtyIiwiZm5zIiwiaW5pdCIsImlkIiwidGRfMSIsImRlZmF1bHQiLCJiSW5mbHQiLCJpbmZsYXRlU3luYyIsInBiZiIsImdvcHQiLCJiRGZsdCIsImRlZmxhdGVTeW5jIiwiZ3plIiwiZ3poIiwiZ3pobCIsIndieXRlcyIsImd1emUiLCJnenMiLCJnemwiLCJ6bGUiLCJ6bGgiLCJ6dWxlIiwiemxzIiwic2l6ZSIsImNiaWZ5Iiwib3B0cyIsImNvbnN1bWUiLCJhc3RybSIsInN0cm0iLCJvbmRhdGEiLCJldiIsImRhdGEiLCJmbHVzaCIsImFzdHJtaWZ5IiwiZXh0IiwiQXJyYXkiLCJpc0FycmF5IiwicXVldWVkU2l6ZSIsIm9uZHJhaW4iLCJiMiIsImI0IiwiYjgiLCJmaWxlbmFtZSIsIm10aW1lIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiY2hhckNvZGVBdCIsImZsZyIsInpzIiwibHYiLCJTdHJtT3B0IiwiRGVmbGF0ZSIsImNodW5rIiwiZW5kTGVuIiwibmV3QnVmIiwiQXN5bmNEZWZsYXRlIiwib25tZXNzYWdlIiwiZGVmbGF0ZSIsIkluZmxhdGUiLCJidHMiLCJBc3luY0luZmxhdGUiLCJpbmZsYXRlIiwiR3ppcCIsInJhdyIsIkNvbXByZXNzIiwiQXN5bmNHemlwIiwiQXN5bmNDb21wcmVzcyIsImd6aXAiLCJnemlwU3luYyIsImNvbXByZXNzIiwiY29tcHJlc3NTeW5jIiwiR3VuemlwIiwib25tZW1iZXIiLCJBc3luY0d1bnppcCIsIl90aGlzIiwib2Zmc2V0IiwiZ3VuemlwIiwiZ3VuemlwU3luYyIsIlpsaWIiLCJBc3luY1psaWIiLCJ6bGliIiwiemxpYlN5bmMiLCJVbnpsaWIiLCJBc3luY1VuemxpYiIsInVuemxpYiIsInVuemxpYlN5bmMiLCJEZWNvbXByZXNzIiwiRyIsIkkiLCJaIiwiQXN5bmNEZWNvbXByZXNzIiwiZGVjb21wcmVzcyIsImRlY29tcHJlc3NTeW5jIiwiZmx0biIsInZhbCIsIm9wIiwidGUiLCJUZXh0RW5jb2RlciIsIlRleHREZWNvZGVyIiwidGRzIiwiZGVjb2RlIiwic3RyZWFtIiwiZHV0ZjgiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJEZWNvZGVVVEY4IiwiRW5jb2RlVVRGOCIsInN0clRvVTgiLCJzdHIiLCJsYXRpbjEiLCJhcl8xIiwiZW5jb2RlIiwiYXIiLCJhaSIsInN0ckZyb21VOCIsImFwcGx5IiwiZGJmIiwic2x6aCIsInpoIiwiZm5sIiwiZXMiLCJ6NjRlIiwic2MiLCJzdSIsIm9mZiIsImV4ZmwiLCJleCIsInd6aCIsInUiLCJjZSIsImV4dHJhIiwiY29sIiwiZXhsIiwib3MiLCJmbGFnIiwiY29tcHJlc3Npb24iLCJ5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiYXR0cnMiLCJleGYiLCJ3emYiLCJaaXBQYXNzVGhyb3VnaCIsInByb2Nlc3MiLCJaaXBEZWZsYXRlIiwiQXN5bmNaaXBEZWZsYXRlIiwiWmlwIiwiZmlsZSIsImZsXzEiLCJjb20iLCJjb21tZW50IiwiaGxfMSIsImhlYWRlciIsImNoa3NfMSIsInBBbGxfMSIsIl9pIiwiY2hrc18yIiwiY2hrIiwidHJfMSIsImluZF8xIiwidWZfMSIsIm54dCIsImNsXzEiLCJkZCIsInNwbGljZSIsInppcCIsIk9iamVjdCIsImtleXMiLCJ0b3QiLCJzbGZ0IiwiZmlsZXMiLCJ0ZXJtIiwidEFsbCIsImNiZCIsIm10IiwiY2JmIiwib2UiLCJjZGwiLCJiYWRkIiwibG9jIiwiX2xvb3BfMSIsIm1zIiwiY2JsIiwiemlwU3luYyIsIlVuemlwUGFzc1Rocm91Z2giLCJVbnppcEluZmxhdGUiLCJBc3luY1VuemlwSW5mbGF0ZSIsInN6IiwiVW56aXAiLCJvbmZpbGUiLCJ0b0FkZCIsImlzIiwib2MiLCJfbG9vcF8yIiwic2lnIiwidGhpc18xIiwiYmYiLCJjbXBfMSIsImNoa3NfMyIsInVuc2hpZnQiLCJzY18xIiwic3VfMSIsImZuXzEiLCJkXzEiLCJmaWxlXzEiLCJuYW1lIiwiY3RyIiwiY2hrc180Iiwib3JpZ2luYWxTaXplIiwic3RhdGVfMSIsInJlZ2lzdGVyIiwiZGVjb2RlciIsInF1ZXVlTWljcm90YXNrIiwic2V0VGltZW91dCIsInVuemlwIiwiemUiLCJmbHRyIiwiZmlsdGVyIiwiX2xvb3BfMyIsImNfMSIsIm5vIiwiaW5mbCIsInVuemlwU3luYyIsImNfMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fflate/lib/node.cjs\n");

/***/ })

};
;